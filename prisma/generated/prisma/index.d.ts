
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model NotificationQueue
 * 
 */
export type NotificationQueue = $Result.DefaultSelection<Prisma.$NotificationQueuePayload>
/**
 * Model Clinic
 * 
 */
export type Clinic = $Result.DefaultSelection<Prisma.$ClinicPayload>
/**
 * Model ConsentVersion
 * 
 */
export type ConsentVersion = $Result.DefaultSelection<Prisma.$ConsentVersionPayload>
/**
 * Model PatientConsent
 * 
 */
export type PatientConsent = $Result.DefaultSelection<Prisma.$PatientConsentPayload>
/**
 * Model KeyManagement
 * 
 */
export type KeyManagement = $Result.DefaultSelection<Prisma.$KeyManagementPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model DataRequest
 * 
 */
export type DataRequest = $Result.DefaultSelection<Prisma.$DataRequestPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Call
 * 
 */
export type Call = $Result.DefaultSelection<Prisma.$CallPayload>
/**
 * Model Diagnosis
 * 
 */
export type Diagnosis = $Result.DefaultSelection<Prisma.$DiagnosisPayload>
/**
 * Model Lab
 * 
 */
export type Lab = $Result.DefaultSelection<Prisma.$LabPayload>
/**
 * Model LabResult
 * 
 */
export type LabResult = $Result.DefaultSelection<Prisma.$LabResultPayload>
/**
 * Model Prescription
 * 
 */
export type Prescription = $Result.DefaultSelection<Prisma.$PrescriptionPayload>
/**
 * Model PrescriptionMedicine
 * 
 */
export type PrescriptionMedicine = $Result.DefaultSelection<Prisma.$PrescriptionMedicinePayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model EmergencyContact
 * 
 */
export type EmergencyContact = $Result.DefaultSelection<Prisma.$EmergencyContactPayload>
/**
 * Model StaffPersonalInfo
 * 
 */
export type StaffPersonalInfo = $Result.DefaultSelection<Prisma.$StaffPersonalInfoPayload>
/**
 * Model StaffEmploymentInfo
 * 
 */
export type StaffEmploymentInfo = $Result.DefaultSelection<Prisma.$StaffEmploymentInfoPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model SystemMetric
 * 
 */
export type SystemMetric = $Result.DefaultSelection<Prisma.$SystemMetricPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Doctor
 * 
 */
export type Doctor = $Result.DefaultSelection<Prisma.$DoctorPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHERS: 'OTHERS'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const AppointmentStatus: {
  NEW: 'NEW',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const CallStatus: {
  STARTED: 'STARTED',
  ENDED: 'ENDED',
  MISSED: 'MISSED',
  FAILED: 'FAILED'
};

export type CallStatus = (typeof CallStatus)[keyof typeof CallStatus]


export const Sentiment: {
  POSITIVE: 'POSITIVE',
  NEGATIVE: 'NEGATIVE',
  NEUTRAL: 'NEUTRAL'
};

export type Sentiment = (typeof Sentiment)[keyof typeof Sentiment]


export const Flag: {
  LOW: 'LOW',
  HIGH: 'HIGH',
  NORMAL: 'NORMAL'
};

export type Flag = (typeof Flag)[keyof typeof Flag]


export const PrescriptionStatus: {
  ACTIVE: 'ACTIVE',
  CANCELLED: 'CANCELLED'
};

export type PrescriptionStatus = (typeof PrescriptionStatus)[keyof typeof PrescriptionStatus]


export const TaskStatus: {
  TODO: 'TODO',
  IN_PROGRESS: 'IN_PROGRESS',
  DONE: 'DONE'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const Plan: {
  BASIC: 'BASIC',
  PROFESSIONAL: 'PROFESSIONAL',
  ENTERPRISE: 'ENTERPRISE'
};

export type Plan = (typeof Plan)[keyof typeof Plan]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  PAST_DUE: 'PAST_DUE',
  CANCELLED: 'CANCELLED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const NotificationType: {
  IN_APP: 'IN_APP',
  SMS: 'SMS',
  EMAIL: 'EMAIL'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  FAILED: 'FAILED'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const ConsentType: {
  MARKETING: 'MARKETING',
  CARE_ANALYTICS: 'CARE_ANALYTICS'
};

export type ConsentType = (typeof ConsentType)[keyof typeof ConsentType]


export const DataRequestType: {
  EXPORT: 'EXPORT',
  ERASURE: 'ERASURE'
};

export type DataRequestType = (typeof DataRequestType)[keyof typeof DataRequestType]


export const DataRequestStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type DataRequestStatus = (typeof DataRequestStatus)[keyof typeof DataRequestStatus]


export const Department: {
  CARDIOLOGY: 'CARDIOLOGY',
  NEUROLOGY: 'NEUROLOGY',
  PEDIATRICS: 'PEDIATRICS',
  ORTHOPEDICS: 'ORTHOPEDICS',
  DERMATOLOGY: 'DERMATOLOGY',
  RADIOLOGY: 'RADIOLOGY',
  PHARMACY: 'PHARMACY',
  ADMINISTRATION: 'ADMINISTRATION',
  RECEPTION: 'RECEPTION',
  NURSING: 'NURSING',
  LABORATORY: 'LABORATORY'
};

export type Department = (typeof Department)[keyof typeof Department]


export const EmploymentType: {
  FULL_TIME: 'FULL_TIME',
  PART_TIME: 'PART_TIME',
  CONTRACT: 'CONTRACT',
  TEMPORARY: 'TEMPORARY',
  INTERN: 'INTERN'
};

export type EmploymentType = (typeof EmploymentType)[keyof typeof EmploymentType]


export const MetricType: {
  CPU: 'CPU',
  MEMORY: 'MEMORY',
  DISK: 'DISK',
  NETWORK: 'NETWORK',
  DATABASE_CONNECTIONS: 'DATABASE_CONNECTIONS',
  REQUEST_RATE: 'REQUEST_RATE',
  ERROR_RATE: 'ERROR_RATE'
};

export type MetricType = (typeof MetricType)[keyof typeof MetricType]


export const ServiceName: {
  API_GATEWAY: 'API_GATEWAY',
  DATABASE_PRIMARY: 'DATABASE_PRIMARY',
  DATABASE_REPLICA: 'DATABASE_REPLICA',
  VOICEBOT_SERVICE: 'VOICEBOT_SERVICE',
  AUTHENTICATION_SERVICE: 'AUTHENTICATION_SERVICE',
  PAYMENT_GATEWAY: 'PAYMENT_GATEWAY',
  NOTIFICATION_SERVICE: 'NOTIFICATION_SERVICE',
  PRESCRIPTION_SERVICE: 'PRESCRIPTION_SERVICE',
  APPOINTMENT_SERVICE: 'APPOINTMENT_SERVICE',
  PATIENT_SERVICE: 'PATIENT_SERVICE',
  LAB_SERVICE: 'LAB_SERVICE'
};

export type ServiceName = (typeof ServiceName)[keyof typeof ServiceName]


export const ServiceStatus: {
  OPERATIONAL: 'OPERATIONAL',
  DEGRADED: 'DEGRADED',
  PARTIAL_OUTAGE: 'PARTIAL_OUTAGE',
  MAJOR_OUTAGE: 'MAJOR_OUTAGE',
  MAINTENANCE: 'MAINTENANCE'
};

export type ServiceStatus = (typeof ServiceStatus)[keyof typeof ServiceStatus]


export const IncidentSeverity: {
  CRITICAL: 'CRITICAL',
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type IncidentSeverity = (typeof IncidentSeverity)[keyof typeof IncidentSeverity]


export const IncidentStatus: {
  INVESTIGATING: 'INVESTIGATING',
  IDENTIFIED: 'IDENTIFIED',
  MONITORING: 'MONITORING',
  RESOLVED: 'RESOLVED',
  POSTMORTEM: 'POSTMORTEM'
};

export type IncidentStatus = (typeof IncidentStatus)[keyof typeof IncidentStatus]


export const HealthCheckStatus: {
  HEALTHY: 'HEALTHY',
  UNHEALTHY: 'UNHEALTHY',
  TIMEOUT: 'TIMEOUT'
};

export type HealthCheckStatus = (typeof HealthCheckStatus)[keyof typeof HealthCheckStatus]

}

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type CallStatus = $Enums.CallStatus

export const CallStatus: typeof $Enums.CallStatus

export type Sentiment = $Enums.Sentiment

export const Sentiment: typeof $Enums.Sentiment

export type Flag = $Enums.Flag

export const Flag: typeof $Enums.Flag

export type PrescriptionStatus = $Enums.PrescriptionStatus

export const PrescriptionStatus: typeof $Enums.PrescriptionStatus

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type Plan = $Enums.Plan

export const Plan: typeof $Enums.Plan

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type ConsentType = $Enums.ConsentType

export const ConsentType: typeof $Enums.ConsentType

export type DataRequestType = $Enums.DataRequestType

export const DataRequestType: typeof $Enums.DataRequestType

export type DataRequestStatus = $Enums.DataRequestStatus

export const DataRequestStatus: typeof $Enums.DataRequestStatus

export type Department = $Enums.Department

export const Department: typeof $Enums.Department

export type EmploymentType = $Enums.EmploymentType

export const EmploymentType: typeof $Enums.EmploymentType

export type MetricType = $Enums.MetricType

export const MetricType: typeof $Enums.MetricType

export type ServiceName = $Enums.ServiceName

export const ServiceName: typeof $Enums.ServiceName

export type ServiceStatus = $Enums.ServiceStatus

export const ServiceStatus: typeof $Enums.ServiceStatus

export type IncidentSeverity = $Enums.IncidentSeverity

export const IncidentSeverity: typeof $Enums.IncidentSeverity

export type IncidentStatus = $Enums.IncidentStatus

export const IncidentStatus: typeof $Enums.IncidentStatus

export type HealthCheckStatus = $Enums.HealthCheckStatus

export const HealthCheckStatus: typeof $Enums.HealthCheckStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Subscriptions
 * const subscriptions = await prisma.subscription.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Subscriptions
   * const subscriptions = await prisma.subscription.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationQueue`: Exposes CRUD operations for the **NotificationQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationQueues
    * const notificationQueues = await prisma.notificationQueue.findMany()
    * ```
    */
  get notificationQueue(): Prisma.NotificationQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinic`: Exposes CRUD operations for the **Clinic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinics
    * const clinics = await prisma.clinic.findMany()
    * ```
    */
  get clinic(): Prisma.ClinicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consentVersion`: Exposes CRUD operations for the **ConsentVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsentVersions
    * const consentVersions = await prisma.consentVersion.findMany()
    * ```
    */
  get consentVersion(): Prisma.ConsentVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patientConsent`: Exposes CRUD operations for the **PatientConsent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientConsents
    * const patientConsents = await prisma.patientConsent.findMany()
    * ```
    */
  get patientConsent(): Prisma.PatientConsentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keyManagement`: Exposes CRUD operations for the **KeyManagement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KeyManagements
    * const keyManagements = await prisma.keyManagement.findMany()
    * ```
    */
  get keyManagement(): Prisma.KeyManagementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataRequest`: Exposes CRUD operations for the **DataRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataRequests
    * const dataRequests = await prisma.dataRequest.findMany()
    * ```
    */
  get dataRequest(): Prisma.DataRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.call`: Exposes CRUD operations for the **Call** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calls
    * const calls = await prisma.call.findMany()
    * ```
    */
  get call(): Prisma.CallDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.diagnosis`: Exposes CRUD operations for the **Diagnosis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diagnoses
    * const diagnoses = await prisma.diagnosis.findMany()
    * ```
    */
  get diagnosis(): Prisma.DiagnosisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lab`: Exposes CRUD operations for the **Lab** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Labs
    * const labs = await prisma.lab.findMany()
    * ```
    */
  get lab(): Prisma.LabDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labResult`: Exposes CRUD operations for the **LabResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabResults
    * const labResults = await prisma.labResult.findMany()
    * ```
    */
  get labResult(): Prisma.LabResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **Prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.PrescriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescriptionMedicine`: Exposes CRUD operations for the **PrescriptionMedicine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrescriptionMedicines
    * const prescriptionMedicines = await prisma.prescriptionMedicine.findMany()
    * ```
    */
  get prescriptionMedicine(): Prisma.PrescriptionMedicineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emergencyContact`: Exposes CRUD operations for the **EmergencyContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmergencyContacts
    * const emergencyContacts = await prisma.emergencyContact.findMany()
    * ```
    */
  get emergencyContact(): Prisma.EmergencyContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staffPersonalInfo`: Exposes CRUD operations for the **StaffPersonalInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffPersonalInfos
    * const staffPersonalInfos = await prisma.staffPersonalInfo.findMany()
    * ```
    */
  get staffPersonalInfo(): Prisma.StaffPersonalInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staffEmploymentInfo`: Exposes CRUD operations for the **StaffEmploymentInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffEmploymentInfos
    * const staffEmploymentInfos = await prisma.staffEmploymentInfo.findMany()
    * ```
    */
  get staffEmploymentInfo(): Prisma.StaffEmploymentInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemMetric`: Exposes CRUD operations for the **SystemMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemMetrics
    * const systemMetrics = await prisma.systemMetric.findMany()
    * ```
    */
  get systemMetric(): Prisma.SystemMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.doctor`: Exposes CRUD operations for the **Doctor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctors
    * const doctors = await prisma.doctor.findMany()
    * ```
    */
  get doctor(): Prisma.DoctorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Subscription: 'Subscription',
    Invoice: 'Invoice',
    NotificationQueue: 'NotificationQueue',
    Clinic: 'Clinic',
    ConsentVersion: 'ConsentVersion',
    PatientConsent: 'PatientConsent',
    KeyManagement: 'KeyManagement',
    AuditLog: 'AuditLog',
    DataRequest: 'DataRequest',
    Appointment: 'Appointment',
    Call: 'Call',
    Diagnosis: 'Diagnosis',
    Lab: 'Lab',
    LabResult: 'LabResult',
    Prescription: 'Prescription',
    PrescriptionMedicine: 'PrescriptionMedicine',
    Patient: 'Patient',
    EmergencyContact: 'EmergencyContact',
    StaffPersonalInfo: 'StaffPersonalInfo',
    StaffEmploymentInfo: 'StaffEmploymentInfo',
    Task: 'Task',
    SystemMetric: 'SystemMetric',
    Admin: 'Admin',
    Doctor: 'Doctor',
    Session: 'Session'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "subscription" | "invoice" | "notificationQueue" | "clinic" | "consentVersion" | "patientConsent" | "keyManagement" | "auditLog" | "dataRequest" | "appointment" | "call" | "diagnosis" | "lab" | "labResult" | "prescription" | "prescriptionMedicine" | "patient" | "emergencyContact" | "staffPersonalInfo" | "staffEmploymentInfo" | "task" | "systemMetric" | "admin" | "doctor" | "session"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      NotificationQueue: {
        payload: Prisma.$NotificationQueuePayload<ExtArgs>
        fields: Prisma.NotificationQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          findFirst: {
            args: Prisma.NotificationQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          findMany: {
            args: Prisma.NotificationQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>[]
          }
          create: {
            args: Prisma.NotificationQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          createMany: {
            args: Prisma.NotificationQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>[]
          }
          delete: {
            args: Prisma.NotificationQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          update: {
            args: Prisma.NotificationQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          deleteMany: {
            args: Prisma.NotificationQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationQueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>[]
          }
          upsert: {
            args: Prisma.NotificationQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          aggregate: {
            args: Prisma.NotificationQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationQueue>
          }
          groupBy: {
            args: Prisma.NotificationQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationQueueCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationQueueCountAggregateOutputType> | number
          }
        }
      }
      Clinic: {
        payload: Prisma.$ClinicPayload<ExtArgs>
        fields: Prisma.ClinicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          findFirst: {
            args: Prisma.ClinicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          findMany: {
            args: Prisma.ClinicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          create: {
            args: Prisma.ClinicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          createMany: {
            args: Prisma.ClinicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          delete: {
            args: Prisma.ClinicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          update: {
            args: Prisma.ClinicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          deleteMany: {
            args: Prisma.ClinicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          upsert: {
            args: Prisma.ClinicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          aggregate: {
            args: Prisma.ClinicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinic>
          }
          groupBy: {
            args: Prisma.ClinicGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicCountAggregateOutputType> | number
          }
        }
      }
      ConsentVersion: {
        payload: Prisma.$ConsentVersionPayload<ExtArgs>
        fields: Prisma.ConsentVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsentVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsentVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentVersionPayload>
          }
          findFirst: {
            args: Prisma.ConsentVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsentVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentVersionPayload>
          }
          findMany: {
            args: Prisma.ConsentVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentVersionPayload>[]
          }
          create: {
            args: Prisma.ConsentVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentVersionPayload>
          }
          createMany: {
            args: Prisma.ConsentVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsentVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentVersionPayload>[]
          }
          delete: {
            args: Prisma.ConsentVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentVersionPayload>
          }
          update: {
            args: Prisma.ConsentVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentVersionPayload>
          }
          deleteMany: {
            args: Prisma.ConsentVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsentVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConsentVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentVersionPayload>[]
          }
          upsert: {
            args: Prisma.ConsentVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentVersionPayload>
          }
          aggregate: {
            args: Prisma.ConsentVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsentVersion>
          }
          groupBy: {
            args: Prisma.ConsentVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsentVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsentVersionCountArgs<ExtArgs>
            result: $Utils.Optional<ConsentVersionCountAggregateOutputType> | number
          }
        }
      }
      PatientConsent: {
        payload: Prisma.$PatientConsentPayload<ExtArgs>
        fields: Prisma.PatientConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientConsentPayload>
          }
          findFirst: {
            args: Prisma.PatientConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientConsentPayload>
          }
          findMany: {
            args: Prisma.PatientConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientConsentPayload>[]
          }
          create: {
            args: Prisma.PatientConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientConsentPayload>
          }
          createMany: {
            args: Prisma.PatientConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientConsentPayload>[]
          }
          delete: {
            args: Prisma.PatientConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientConsentPayload>
          }
          update: {
            args: Prisma.PatientConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientConsentPayload>
          }
          deleteMany: {
            args: Prisma.PatientConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientConsentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientConsentPayload>[]
          }
          upsert: {
            args: Prisma.PatientConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientConsentPayload>
          }
          aggregate: {
            args: Prisma.PatientConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientConsent>
          }
          groupBy: {
            args: Prisma.PatientConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientConsentCountArgs<ExtArgs>
            result: $Utils.Optional<PatientConsentCountAggregateOutputType> | number
          }
        }
      }
      KeyManagement: {
        payload: Prisma.$KeyManagementPayload<ExtArgs>
        fields: Prisma.KeyManagementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeyManagementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyManagementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeyManagementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyManagementPayload>
          }
          findFirst: {
            args: Prisma.KeyManagementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyManagementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeyManagementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyManagementPayload>
          }
          findMany: {
            args: Prisma.KeyManagementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyManagementPayload>[]
          }
          create: {
            args: Prisma.KeyManagementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyManagementPayload>
          }
          createMany: {
            args: Prisma.KeyManagementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KeyManagementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyManagementPayload>[]
          }
          delete: {
            args: Prisma.KeyManagementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyManagementPayload>
          }
          update: {
            args: Prisma.KeyManagementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyManagementPayload>
          }
          deleteMany: {
            args: Prisma.KeyManagementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeyManagementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KeyManagementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyManagementPayload>[]
          }
          upsert: {
            args: Prisma.KeyManagementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyManagementPayload>
          }
          aggregate: {
            args: Prisma.KeyManagementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeyManagement>
          }
          groupBy: {
            args: Prisma.KeyManagementGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeyManagementGroupByOutputType>[]
          }
          count: {
            args: Prisma.KeyManagementCountArgs<ExtArgs>
            result: $Utils.Optional<KeyManagementCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      DataRequest: {
        payload: Prisma.$DataRequestPayload<ExtArgs>
        fields: Prisma.DataRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRequestPayload>
          }
          findFirst: {
            args: Prisma.DataRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRequestPayload>
          }
          findMany: {
            args: Prisma.DataRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRequestPayload>[]
          }
          create: {
            args: Prisma.DataRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRequestPayload>
          }
          createMany: {
            args: Prisma.DataRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRequestPayload>[]
          }
          delete: {
            args: Prisma.DataRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRequestPayload>
          }
          update: {
            args: Prisma.DataRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRequestPayload>
          }
          deleteMany: {
            args: Prisma.DataRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DataRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRequestPayload>[]
          }
          upsert: {
            args: Prisma.DataRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRequestPayload>
          }
          aggregate: {
            args: Prisma.DataRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataRequest>
          }
          groupBy: {
            args: Prisma.DataRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataRequestCountArgs<ExtArgs>
            result: $Utils.Optional<DataRequestCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Call: {
        payload: Prisma.$CallPayload<ExtArgs>
        fields: Prisma.CallFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallPayload>
          }
          findFirst: {
            args: Prisma.CallFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallPayload>
          }
          findMany: {
            args: Prisma.CallFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallPayload>[]
          }
          create: {
            args: Prisma.CallCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallPayload>
          }
          createMany: {
            args: Prisma.CallCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallPayload>[]
          }
          delete: {
            args: Prisma.CallDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallPayload>
          }
          update: {
            args: Prisma.CallUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallPayload>
          }
          deleteMany: {
            args: Prisma.CallDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CallUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallPayload>[]
          }
          upsert: {
            args: Prisma.CallUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallPayload>
          }
          aggregate: {
            args: Prisma.CallAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCall>
          }
          groupBy: {
            args: Prisma.CallGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallCountArgs<ExtArgs>
            result: $Utils.Optional<CallCountAggregateOutputType> | number
          }
        }
      }
      Diagnosis: {
        payload: Prisma.$DiagnosisPayload<ExtArgs>
        fields: Prisma.DiagnosisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiagnosisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiagnosisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          findFirst: {
            args: Prisma.DiagnosisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiagnosisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          findMany: {
            args: Prisma.DiagnosisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          create: {
            args: Prisma.DiagnosisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          createMany: {
            args: Prisma.DiagnosisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiagnosisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          delete: {
            args: Prisma.DiagnosisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          update: {
            args: Prisma.DiagnosisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          deleteMany: {
            args: Prisma.DiagnosisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiagnosisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiagnosisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          upsert: {
            args: Prisma.DiagnosisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          aggregate: {
            args: Prisma.DiagnosisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiagnosis>
          }
          groupBy: {
            args: Prisma.DiagnosisGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiagnosisGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiagnosisCountArgs<ExtArgs>
            result: $Utils.Optional<DiagnosisCountAggregateOutputType> | number
          }
        }
      }
      Lab: {
        payload: Prisma.$LabPayload<ExtArgs>
        fields: Prisma.LabFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          findFirst: {
            args: Prisma.LabFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          findMany: {
            args: Prisma.LabFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>[]
          }
          create: {
            args: Prisma.LabCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          createMany: {
            args: Prisma.LabCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>[]
          }
          delete: {
            args: Prisma.LabDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          update: {
            args: Prisma.LabUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          deleteMany: {
            args: Prisma.LabDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>[]
          }
          upsert: {
            args: Prisma.LabUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          aggregate: {
            args: Prisma.LabAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLab>
          }
          groupBy: {
            args: Prisma.LabGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabCountArgs<ExtArgs>
            result: $Utils.Optional<LabCountAggregateOutputType> | number
          }
        }
      }
      LabResult: {
        payload: Prisma.$LabResultPayload<ExtArgs>
        fields: Prisma.LabResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          findFirst: {
            args: Prisma.LabResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          findMany: {
            args: Prisma.LabResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>[]
          }
          create: {
            args: Prisma.LabResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          createMany: {
            args: Prisma.LabResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>[]
          }
          delete: {
            args: Prisma.LabResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          update: {
            args: Prisma.LabResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          deleteMany: {
            args: Prisma.LabResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>[]
          }
          upsert: {
            args: Prisma.LabResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          aggregate: {
            args: Prisma.LabResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabResult>
          }
          groupBy: {
            args: Prisma.LabResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabResultCountArgs<ExtArgs>
            result: $Utils.Optional<LabResultCountAggregateOutputType> | number
          }
        }
      }
      Prescription: {
        payload: Prisma.$PrescriptionPayload<ExtArgs>
        fields: Prisma.PrescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findMany: {
            args: Prisma.PrescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          create: {
            args: Prisma.PrescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          createMany: {
            args: Prisma.PrescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          update: {
            args: Prisma.PrescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.PrescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      PrescriptionMedicine: {
        payload: Prisma.$PrescriptionMedicinePayload<ExtArgs>
        fields: Prisma.PrescriptionMedicineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionMedicineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionMedicineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>
          }
          findFirst: {
            args: Prisma.PrescriptionMedicineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionMedicineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>
          }
          findMany: {
            args: Prisma.PrescriptionMedicineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>[]
          }
          create: {
            args: Prisma.PrescriptionMedicineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>
          }
          createMany: {
            args: Prisma.PrescriptionMedicineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionMedicineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>[]
          }
          delete: {
            args: Prisma.PrescriptionMedicineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>
          }
          update: {
            args: Prisma.PrescriptionMedicineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionMedicineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionMedicineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionMedicineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionMedicineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionMedicinePayload>
          }
          aggregate: {
            args: Prisma.PrescriptionMedicineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescriptionMedicine>
          }
          groupBy: {
            args: Prisma.PrescriptionMedicineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionMedicineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionMedicineCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionMedicineCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      EmergencyContact: {
        payload: Prisma.$EmergencyContactPayload<ExtArgs>
        fields: Prisma.EmergencyContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmergencyContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmergencyContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          findFirst: {
            args: Prisma.EmergencyContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmergencyContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          findMany: {
            args: Prisma.EmergencyContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>[]
          }
          create: {
            args: Prisma.EmergencyContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          createMany: {
            args: Prisma.EmergencyContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmergencyContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>[]
          }
          delete: {
            args: Prisma.EmergencyContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          update: {
            args: Prisma.EmergencyContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          deleteMany: {
            args: Prisma.EmergencyContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmergencyContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmergencyContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>[]
          }
          upsert: {
            args: Prisma.EmergencyContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          aggregate: {
            args: Prisma.EmergencyContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergencyContact>
          }
          groupBy: {
            args: Prisma.EmergencyContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmergencyContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmergencyContactCountArgs<ExtArgs>
            result: $Utils.Optional<EmergencyContactCountAggregateOutputType> | number
          }
        }
      }
      StaffPersonalInfo: {
        payload: Prisma.$StaffPersonalInfoPayload<ExtArgs>
        fields: Prisma.StaffPersonalInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffPersonalInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPersonalInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffPersonalInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPersonalInfoPayload>
          }
          findFirst: {
            args: Prisma.StaffPersonalInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPersonalInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffPersonalInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPersonalInfoPayload>
          }
          findMany: {
            args: Prisma.StaffPersonalInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPersonalInfoPayload>[]
          }
          create: {
            args: Prisma.StaffPersonalInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPersonalInfoPayload>
          }
          createMany: {
            args: Prisma.StaffPersonalInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffPersonalInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPersonalInfoPayload>[]
          }
          delete: {
            args: Prisma.StaffPersonalInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPersonalInfoPayload>
          }
          update: {
            args: Prisma.StaffPersonalInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPersonalInfoPayload>
          }
          deleteMany: {
            args: Prisma.StaffPersonalInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffPersonalInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffPersonalInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPersonalInfoPayload>[]
          }
          upsert: {
            args: Prisma.StaffPersonalInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPersonalInfoPayload>
          }
          aggregate: {
            args: Prisma.StaffPersonalInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaffPersonalInfo>
          }
          groupBy: {
            args: Prisma.StaffPersonalInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffPersonalInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffPersonalInfoCountArgs<ExtArgs>
            result: $Utils.Optional<StaffPersonalInfoCountAggregateOutputType> | number
          }
        }
      }
      StaffEmploymentInfo: {
        payload: Prisma.$StaffEmploymentInfoPayload<ExtArgs>
        fields: Prisma.StaffEmploymentInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffEmploymentInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffEmploymentInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffEmploymentInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffEmploymentInfoPayload>
          }
          findFirst: {
            args: Prisma.StaffEmploymentInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffEmploymentInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffEmploymentInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffEmploymentInfoPayload>
          }
          findMany: {
            args: Prisma.StaffEmploymentInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffEmploymentInfoPayload>[]
          }
          create: {
            args: Prisma.StaffEmploymentInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffEmploymentInfoPayload>
          }
          createMany: {
            args: Prisma.StaffEmploymentInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffEmploymentInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffEmploymentInfoPayload>[]
          }
          delete: {
            args: Prisma.StaffEmploymentInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffEmploymentInfoPayload>
          }
          update: {
            args: Prisma.StaffEmploymentInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffEmploymentInfoPayload>
          }
          deleteMany: {
            args: Prisma.StaffEmploymentInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffEmploymentInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffEmploymentInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffEmploymentInfoPayload>[]
          }
          upsert: {
            args: Prisma.StaffEmploymentInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffEmploymentInfoPayload>
          }
          aggregate: {
            args: Prisma.StaffEmploymentInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaffEmploymentInfo>
          }
          groupBy: {
            args: Prisma.StaffEmploymentInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffEmploymentInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffEmploymentInfoCountArgs<ExtArgs>
            result: $Utils.Optional<StaffEmploymentInfoCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      SystemMetric: {
        payload: Prisma.$SystemMetricPayload<ExtArgs>
        fields: Prisma.SystemMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>
          }
          findFirst: {
            args: Prisma.SystemMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>
          }
          findMany: {
            args: Prisma.SystemMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>[]
          }
          create: {
            args: Prisma.SystemMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>
          }
          createMany: {
            args: Prisma.SystemMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>[]
          }
          delete: {
            args: Prisma.SystemMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>
          }
          update: {
            args: Prisma.SystemMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>
          }
          deleteMany: {
            args: Prisma.SystemMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>[]
          }
          upsert: {
            args: Prisma.SystemMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>
          }
          aggregate: {
            args: Prisma.SystemMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemMetric>
          }
          groupBy: {
            args: Prisma.SystemMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemMetricCountArgs<ExtArgs>
            result: $Utils.Optional<SystemMetricCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Doctor: {
        payload: Prisma.$DoctorPayload<ExtArgs>
        fields: Prisma.DoctorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          findFirst: {
            args: Prisma.DoctorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          findMany: {
            args: Prisma.DoctorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          create: {
            args: Prisma.DoctorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          createMany: {
            args: Prisma.DoctorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          delete: {
            args: Prisma.DoctorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          update: {
            args: Prisma.DoctorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          deleteMany: {
            args: Prisma.DoctorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DoctorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          upsert: {
            args: Prisma.DoctorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          aggregate: {
            args: Prisma.DoctorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctor>
          }
          groupBy: {
            args: Prisma.DoctorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    subscription?: SubscriptionOmit
    invoice?: InvoiceOmit
    notificationQueue?: NotificationQueueOmit
    clinic?: ClinicOmit
    consentVersion?: ConsentVersionOmit
    patientConsent?: PatientConsentOmit
    keyManagement?: KeyManagementOmit
    auditLog?: AuditLogOmit
    dataRequest?: DataRequestOmit
    appointment?: AppointmentOmit
    call?: CallOmit
    diagnosis?: DiagnosisOmit
    lab?: LabOmit
    labResult?: LabResultOmit
    prescription?: PrescriptionOmit
    prescriptionMedicine?: PrescriptionMedicineOmit
    patient?: PatientOmit
    emergencyContact?: EmergencyContactOmit
    staffPersonalInfo?: StaffPersonalInfoOmit
    staffEmploymentInfo?: StaffEmploymentInfoOmit
    task?: TaskOmit
    systemMetric?: SystemMetricOmit
    admin?: AdminOmit
    doctor?: DoctorOmit
    session?: SessionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClinicCountOutputType
   */

  export type ClinicCountOutputType = {
    admins: number
    doctors: number
    patients: number
    appointments: number
    calls: number
    labs: number
    prescriptions: number
    tasks: number
    invoices: number
    notificationQueues: number
    auditLogs: number
    dataRequests: number
    consentVersions: number
  }

  export type ClinicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | ClinicCountOutputTypeCountAdminsArgs
    doctors?: boolean | ClinicCountOutputTypeCountDoctorsArgs
    patients?: boolean | ClinicCountOutputTypeCountPatientsArgs
    appointments?: boolean | ClinicCountOutputTypeCountAppointmentsArgs
    calls?: boolean | ClinicCountOutputTypeCountCallsArgs
    labs?: boolean | ClinicCountOutputTypeCountLabsArgs
    prescriptions?: boolean | ClinicCountOutputTypeCountPrescriptionsArgs
    tasks?: boolean | ClinicCountOutputTypeCountTasksArgs
    invoices?: boolean | ClinicCountOutputTypeCountInvoicesArgs
    notificationQueues?: boolean | ClinicCountOutputTypeCountNotificationQueuesArgs
    auditLogs?: boolean | ClinicCountOutputTypeCountAuditLogsArgs
    dataRequests?: boolean | ClinicCountOutputTypeCountDataRequestsArgs
    consentVersions?: boolean | ClinicCountOutputTypeCountConsentVersionsArgs
  }

  // Custom InputTypes
  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicCountOutputType
     */
    select?: ClinicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountDoctorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountLabsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountNotificationQueuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationQueueWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountDataRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataRequestWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountConsentVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsentVersionWhereInput
  }


  /**
   * Count Type ConsentVersionCountOutputType
   */

  export type ConsentVersionCountOutputType = {
    patientConsents: number
  }

  export type ConsentVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientConsents?: boolean | ConsentVersionCountOutputTypeCountPatientConsentsArgs
  }

  // Custom InputTypes
  /**
   * ConsentVersionCountOutputType without action
   */
  export type ConsentVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersionCountOutputType
     */
    select?: ConsentVersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConsentVersionCountOutputType without action
   */
  export type ConsentVersionCountOutputTypeCountPatientConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientConsentWhereInput
  }


  /**
   * Count Type LabCountOutputType
   */

  export type LabCountOutputType = {
    results: number
  }

  export type LabCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | LabCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * LabCountOutputType without action
   */
  export type LabCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabCountOutputType
     */
    select?: LabCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabCountOutputType without action
   */
  export type LabCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabResultWhereInput
  }


  /**
   * Count Type PrescriptionCountOutputType
   */

  export type PrescriptionCountOutputType = {
    medicines: number
  }

  export type PrescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicines?: boolean | PrescriptionCountOutputTypeCountMedicinesArgs
  }

  // Custom InputTypes
  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCountOutputType
     */
    select?: PrescriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountMedicinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionMedicineWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    appointments: number
    calls: number
    labs: number
    prescriptions: number
    tasks: number
    dataRequests: number
    emergencyContacts: number
    diagnoses: number
    consents: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | PatientCountOutputTypeCountAppointmentsArgs
    calls?: boolean | PatientCountOutputTypeCountCallsArgs
    labs?: boolean | PatientCountOutputTypeCountLabsArgs
    prescriptions?: boolean | PatientCountOutputTypeCountPrescriptionsArgs
    tasks?: boolean | PatientCountOutputTypeCountTasksArgs
    dataRequests?: boolean | PatientCountOutputTypeCountDataRequestsArgs
    emergencyContacts?: boolean | PatientCountOutputTypeCountEmergencyContactsArgs
    diagnoses?: boolean | PatientCountOutputTypeCountDiagnosesArgs
    consents?: boolean | PatientCountOutputTypeCountConsentsArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountLabsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountDataRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataRequestWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountEmergencyContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyContactWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountDiagnosesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientConsentWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    sessions: number
    auditLogs: number
    assignedTasks: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | AdminCountOutputTypeCountSessionsArgs
    auditLogs?: boolean | AdminCountOutputTypeCountAuditLogsArgs
    assignedTasks?: boolean | AdminCountOutputTypeCountAssignedTasksArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type DoctorCountOutputType
   */

  export type DoctorCountOutputType = {
    sessions: number
    appointments: number
    calls: number
    prescriptions: number
    diagnoses: number
    assignedTasks: number
    auditLogs: number
    subordinates: number
  }

  export type DoctorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | DoctorCountOutputTypeCountSessionsArgs
    appointments?: boolean | DoctorCountOutputTypeCountAppointmentsArgs
    calls?: boolean | DoctorCountOutputTypeCountCallsArgs
    prescriptions?: boolean | DoctorCountOutputTypeCountPrescriptionsArgs
    diagnoses?: boolean | DoctorCountOutputTypeCountDiagnosesArgs
    assignedTasks?: boolean | DoctorCountOutputTypeCountAssignedTasksArgs
    auditLogs?: boolean | DoctorCountOutputTypeCountAuditLogsArgs
    subordinates?: boolean | DoctorCountOutputTypeCountSubordinatesArgs
  }

  // Custom InputTypes
  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorCountOutputType
     */
    select?: DoctorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountDiagnosesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountAssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountSubordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffEmploymentInfoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    plan: $Enums.Plan | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    plan: $Enums.Plan | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    clinicId: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    plan: number
    status: number
    currentPeriodStart: number
    currentPeriodEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    clinicId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    plan?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    clinicId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    plan?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    clinicId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    plan?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    clinicId: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    plan: $Enums.Plan | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    plan?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | Subscription$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    plan?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | Subscription$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    plan?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | Subscription$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    clinicId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    plan?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "stripeCustomerId" | "stripeSubscriptionId" | "plan" | "status" | "currentPeriodStart" | "currentPeriodEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Subscription$clinicArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Subscription$clinicArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Subscription$clinicArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string | null
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      plan: $Enums.Plan | null
      status: $Enums.SubscriptionStatus | null
      currentPeriodStart: Date | null
      currentPeriodEnd: Date | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends Subscription$clinicArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly clinicId: FieldRef<"Subscription", 'String'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly plan: FieldRef<"Subscription", 'Plan'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data?: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.clinic
   */
  export type Subscription$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amountDue: number | null
    amountPaid: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amountDue: number | null
    amountPaid: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    stripeInvoiceId: string | null
    invoiceNo: string | null
    amountDue: number | null
    amountPaid: number | null
    currency: string | null
    status: string | null
    invoicePdfUrl: string | null
    createdAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    stripeInvoiceId: string | null
    invoiceNo: string | null
    amountDue: number | null
    amountPaid: number | null
    currency: string | null
    status: string | null
    invoicePdfUrl: string | null
    createdAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    clinicId: number
    stripeInvoiceId: number
    invoiceNo: number
    amountDue: number
    amountPaid: number
    currency: number
    status: number
    invoicePdfUrl: number
    createdAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amountDue?: true
    amountPaid?: true
  }

  export type InvoiceSumAggregateInputType = {
    amountDue?: true
    amountPaid?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    clinicId?: true
    stripeInvoiceId?: true
    invoiceNo?: true
    amountDue?: true
    amountPaid?: true
    currency?: true
    status?: true
    invoicePdfUrl?: true
    createdAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    clinicId?: true
    stripeInvoiceId?: true
    invoiceNo?: true
    amountDue?: true
    amountPaid?: true
    currency?: true
    status?: true
    invoicePdfUrl?: true
    createdAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    clinicId?: true
    stripeInvoiceId?: true
    invoiceNo?: true
    amountDue?: true
    amountPaid?: true
    currency?: true
    status?: true
    invoicePdfUrl?: true
    createdAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    clinicId: string | null
    stripeInvoiceId: string | null
    invoiceNo: string | null
    amountDue: number | null
    amountPaid: number | null
    currency: string | null
    status: string | null
    invoicePdfUrl: string | null
    createdAt: Date | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    stripeInvoiceId?: boolean
    invoiceNo?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    currency?: boolean
    status?: boolean
    invoicePdfUrl?: boolean
    createdAt?: boolean
    clinic?: boolean | Invoice$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    stripeInvoiceId?: boolean
    invoiceNo?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    currency?: boolean
    status?: boolean
    invoicePdfUrl?: boolean
    createdAt?: boolean
    clinic?: boolean | Invoice$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    stripeInvoiceId?: boolean
    invoiceNo?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    currency?: boolean
    status?: boolean
    invoicePdfUrl?: boolean
    createdAt?: boolean
    clinic?: boolean | Invoice$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    clinicId?: boolean
    stripeInvoiceId?: boolean
    invoiceNo?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    currency?: boolean
    status?: boolean
    invoicePdfUrl?: boolean
    createdAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "stripeInvoiceId" | "invoiceNo" | "amountDue" | "amountPaid" | "currency" | "status" | "invoicePdfUrl" | "createdAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Invoice$clinicArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Invoice$clinicArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Invoice$clinicArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string | null
      stripeInvoiceId: string | null
      invoiceNo: string | null
      amountDue: number | null
      amountPaid: number | null
      currency: string | null
      status: string | null
      invoicePdfUrl: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends Invoice$clinicArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly clinicId: FieldRef<"Invoice", 'String'>
    readonly stripeInvoiceId: FieldRef<"Invoice", 'String'>
    readonly invoiceNo: FieldRef<"Invoice", 'String'>
    readonly amountDue: FieldRef<"Invoice", 'Int'>
    readonly amountPaid: FieldRef<"Invoice", 'Int'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly invoicePdfUrl: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data?: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.clinic
   */
  export type Invoice$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model NotificationQueue
   */

  export type AggregateNotificationQueue = {
    _count: NotificationQueueCountAggregateOutputType | null
    _min: NotificationQueueMinAggregateOutputType | null
    _max: NotificationQueueMaxAggregateOutputType | null
  }

  export type NotificationQueueMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    type: $Enums.NotificationType | null
    recipient: string | null
    status: $Enums.NotificationStatus | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type NotificationQueueMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    type: $Enums.NotificationType | null
    recipient: string | null
    status: $Enums.NotificationStatus | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type NotificationQueueCountAggregateOutputType = {
    id: number
    clinicId: number
    type: number
    recipient: number
    payload: number
    status: number
    sentAt: number
    createdAt: number
    _all: number
  }


  export type NotificationQueueMinAggregateInputType = {
    id?: true
    clinicId?: true
    type?: true
    recipient?: true
    status?: true
    sentAt?: true
    createdAt?: true
  }

  export type NotificationQueueMaxAggregateInputType = {
    id?: true
    clinicId?: true
    type?: true
    recipient?: true
    status?: true
    sentAt?: true
    createdAt?: true
  }

  export type NotificationQueueCountAggregateInputType = {
    id?: true
    clinicId?: true
    type?: true
    recipient?: true
    payload?: true
    status?: true
    sentAt?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationQueue to aggregate.
     */
    where?: NotificationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?: NotificationQueueOrderByWithRelationInput | NotificationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationQueues
    **/
    _count?: true | NotificationQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationQueueMaxAggregateInputType
  }

  export type GetNotificationQueueAggregateType<T extends NotificationQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationQueue[P]>
      : GetScalarType<T[P], AggregateNotificationQueue[P]>
  }




  export type NotificationQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationQueueWhereInput
    orderBy?: NotificationQueueOrderByWithAggregationInput | NotificationQueueOrderByWithAggregationInput[]
    by: NotificationQueueScalarFieldEnum[] | NotificationQueueScalarFieldEnum
    having?: NotificationQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationQueueCountAggregateInputType | true
    _min?: NotificationQueueMinAggregateInputType
    _max?: NotificationQueueMaxAggregateInputType
  }

  export type NotificationQueueGroupByOutputType = {
    id: string
    clinicId: string | null
    type: $Enums.NotificationType | null
    recipient: string | null
    payload: JsonValue | null
    status: $Enums.NotificationStatus | null
    sentAt: Date | null
    createdAt: Date | null
    _count: NotificationQueueCountAggregateOutputType | null
    _min: NotificationQueueMinAggregateOutputType | null
    _max: NotificationQueueMaxAggregateOutputType | null
  }

  type GetNotificationQueueGroupByPayload<T extends NotificationQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationQueueGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationQueueGroupByOutputType[P]>
        }
      >
    >


  export type NotificationQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    type?: boolean
    recipient?: boolean
    payload?: boolean
    status?: boolean
    sentAt?: boolean
    createdAt?: boolean
    clinic?: boolean | NotificationQueue$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["notificationQueue"]>

  export type NotificationQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    type?: boolean
    recipient?: boolean
    payload?: boolean
    status?: boolean
    sentAt?: boolean
    createdAt?: boolean
    clinic?: boolean | NotificationQueue$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["notificationQueue"]>

  export type NotificationQueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    type?: boolean
    recipient?: boolean
    payload?: boolean
    status?: boolean
    sentAt?: boolean
    createdAt?: boolean
    clinic?: boolean | NotificationQueue$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["notificationQueue"]>

  export type NotificationQueueSelectScalar = {
    id?: boolean
    clinicId?: boolean
    type?: boolean
    recipient?: boolean
    payload?: boolean
    status?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }

  export type NotificationQueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "type" | "recipient" | "payload" | "status" | "sentAt" | "createdAt", ExtArgs["result"]["notificationQueue"]>
  export type NotificationQueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | NotificationQueue$clinicArgs<ExtArgs>
  }
  export type NotificationQueueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | NotificationQueue$clinicArgs<ExtArgs>
  }
  export type NotificationQueueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | NotificationQueue$clinicArgs<ExtArgs>
  }

  export type $NotificationQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationQueue"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string | null
      type: $Enums.NotificationType | null
      recipient: string | null
      payload: Prisma.JsonValue | null
      status: $Enums.NotificationStatus | null
      sentAt: Date | null
      createdAt: Date | null
    }, ExtArgs["result"]["notificationQueue"]>
    composites: {}
  }

  type NotificationQueueGetPayload<S extends boolean | null | undefined | NotificationQueueDefaultArgs> = $Result.GetResult<Prisma.$NotificationQueuePayload, S>

  type NotificationQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationQueueCountAggregateInputType | true
    }

  export interface NotificationQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationQueue'], meta: { name: 'NotificationQueue' } }
    /**
     * Find zero or one NotificationQueue that matches the filter.
     * @param {NotificationQueueFindUniqueArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationQueueFindUniqueArgs>(args: SelectSubset<T, NotificationQueueFindUniqueArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationQueueFindUniqueOrThrowArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueFindFirstArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationQueueFindFirstArgs>(args?: SelectSubset<T, NotificationQueueFindFirstArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueFindFirstOrThrowArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationQueues
     * const notificationQueues = await prisma.notificationQueue.findMany()
     * 
     * // Get first 10 NotificationQueues
     * const notificationQueues = await prisma.notificationQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationQueueWithIdOnly = await prisma.notificationQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationQueueFindManyArgs>(args?: SelectSubset<T, NotificationQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationQueue.
     * @param {NotificationQueueCreateArgs} args - Arguments to create a NotificationQueue.
     * @example
     * // Create one NotificationQueue
     * const NotificationQueue = await prisma.notificationQueue.create({
     *   data: {
     *     // ... data to create a NotificationQueue
     *   }
     * })
     * 
     */
    create<T extends NotificationQueueCreateArgs>(args: SelectSubset<T, NotificationQueueCreateArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationQueues.
     * @param {NotificationQueueCreateManyArgs} args - Arguments to create many NotificationQueues.
     * @example
     * // Create many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationQueueCreateManyArgs>(args?: SelectSubset<T, NotificationQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationQueues and returns the data saved in the database.
     * @param {NotificationQueueCreateManyAndReturnArgs} args - Arguments to create many NotificationQueues.
     * @example
     * // Create many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationQueues and only return the `id`
     * const notificationQueueWithIdOnly = await prisma.notificationQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationQueue.
     * @param {NotificationQueueDeleteArgs} args - Arguments to delete one NotificationQueue.
     * @example
     * // Delete one NotificationQueue
     * const NotificationQueue = await prisma.notificationQueue.delete({
     *   where: {
     *     // ... filter to delete one NotificationQueue
     *   }
     * })
     * 
     */
    delete<T extends NotificationQueueDeleteArgs>(args: SelectSubset<T, NotificationQueueDeleteArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationQueue.
     * @param {NotificationQueueUpdateArgs} args - Arguments to update one NotificationQueue.
     * @example
     * // Update one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationQueueUpdateArgs>(args: SelectSubset<T, NotificationQueueUpdateArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationQueues.
     * @param {NotificationQueueDeleteManyArgs} args - Arguments to filter NotificationQueues to delete.
     * @example
     * // Delete a few NotificationQueues
     * const { count } = await prisma.notificationQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationQueueDeleteManyArgs>(args?: SelectSubset<T, NotificationQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationQueueUpdateManyArgs>(args: SelectSubset<T, NotificationQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationQueues and returns the data updated in the database.
     * @param {NotificationQueueUpdateManyAndReturnArgs} args - Arguments to update many NotificationQueues.
     * @example
     * // Update many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationQueues and only return the `id`
     * const notificationQueueWithIdOnly = await prisma.notificationQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationQueueUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationQueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationQueue.
     * @param {NotificationQueueUpsertArgs} args - Arguments to update or create a NotificationQueue.
     * @example
     * // Update or create a NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.upsert({
     *   create: {
     *     // ... data to create a NotificationQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationQueue we want to update
     *   }
     * })
     */
    upsert<T extends NotificationQueueUpsertArgs>(args: SelectSubset<T, NotificationQueueUpsertArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueCountArgs} args - Arguments to filter NotificationQueues to count.
     * @example
     * // Count the number of NotificationQueues
     * const count = await prisma.notificationQueue.count({
     *   where: {
     *     // ... the filter for the NotificationQueues we want to count
     *   }
     * })
    **/
    count<T extends NotificationQueueCountArgs>(
      args?: Subset<T, NotificationQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationQueueAggregateArgs>(args: Subset<T, NotificationQueueAggregateArgs>): Prisma.PrismaPromise<GetNotificationQueueAggregateType<T>>

    /**
     * Group by NotificationQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationQueueGroupByArgs['orderBy'] }
        : { orderBy?: NotificationQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationQueue model
   */
  readonly fields: NotificationQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends NotificationQueue$clinicArgs<ExtArgs> = {}>(args?: Subset<T, NotificationQueue$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationQueue model
   */
  interface NotificationQueueFieldRefs {
    readonly id: FieldRef<"NotificationQueue", 'String'>
    readonly clinicId: FieldRef<"NotificationQueue", 'String'>
    readonly type: FieldRef<"NotificationQueue", 'NotificationType'>
    readonly recipient: FieldRef<"NotificationQueue", 'String'>
    readonly payload: FieldRef<"NotificationQueue", 'Json'>
    readonly status: FieldRef<"NotificationQueue", 'NotificationStatus'>
    readonly sentAt: FieldRef<"NotificationQueue", 'DateTime'>
    readonly createdAt: FieldRef<"NotificationQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationQueue findUnique
   */
  export type NotificationQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where: NotificationQueueWhereUniqueInput
  }

  /**
   * NotificationQueue findUniqueOrThrow
   */
  export type NotificationQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where: NotificationQueueWhereUniqueInput
  }

  /**
   * NotificationQueue findFirst
   */
  export type NotificationQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where?: NotificationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?: NotificationQueueOrderByWithRelationInput | NotificationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationQueues.
     */
    cursor?: NotificationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationQueues.
     */
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[]
  }

  /**
   * NotificationQueue findFirstOrThrow
   */
  export type NotificationQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where?: NotificationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?: NotificationQueueOrderByWithRelationInput | NotificationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationQueues.
     */
    cursor?: NotificationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationQueues.
     */
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[]
  }

  /**
   * NotificationQueue findMany
   */
  export type NotificationQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null
    /**
     * Filter, which NotificationQueues to fetch.
     */
    where?: NotificationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?: NotificationQueueOrderByWithRelationInput | NotificationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationQueues.
     */
    cursor?: NotificationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationQueues.
     */
    skip?: number
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[]
  }

  /**
   * NotificationQueue create
   */
  export type NotificationQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationQueue.
     */
    data?: XOR<NotificationQueueCreateInput, NotificationQueueUncheckedCreateInput>
  }

  /**
   * NotificationQueue createMany
   */
  export type NotificationQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationQueues.
     */
    data: NotificationQueueCreateManyInput | NotificationQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationQueue createManyAndReturn
   */
  export type NotificationQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationQueues.
     */
    data: NotificationQueueCreateManyInput | NotificationQueueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationQueue update
   */
  export type NotificationQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationQueue.
     */
    data: XOR<NotificationQueueUpdateInput, NotificationQueueUncheckedUpdateInput>
    /**
     * Choose, which NotificationQueue to update.
     */
    where: NotificationQueueWhereUniqueInput
  }

  /**
   * NotificationQueue updateMany
   */
  export type NotificationQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationQueues.
     */
    data: XOR<NotificationQueueUpdateManyMutationInput, NotificationQueueUncheckedUpdateManyInput>
    /**
     * Filter which NotificationQueues to update
     */
    where?: NotificationQueueWhereInput
    /**
     * Limit how many NotificationQueues to update.
     */
    limit?: number
  }

  /**
   * NotificationQueue updateManyAndReturn
   */
  export type NotificationQueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * The data used to update NotificationQueues.
     */
    data: XOR<NotificationQueueUpdateManyMutationInput, NotificationQueueUncheckedUpdateManyInput>
    /**
     * Filter which NotificationQueues to update
     */
    where?: NotificationQueueWhereInput
    /**
     * Limit how many NotificationQueues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationQueue upsert
   */
  export type NotificationQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationQueue to update in case it exists.
     */
    where: NotificationQueueWhereUniqueInput
    /**
     * In case the NotificationQueue found by the `where` argument doesn't exist, create a new NotificationQueue with this data.
     */
    create: XOR<NotificationQueueCreateInput, NotificationQueueUncheckedCreateInput>
    /**
     * In case the NotificationQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationQueueUpdateInput, NotificationQueueUncheckedUpdateInput>
  }

  /**
   * NotificationQueue delete
   */
  export type NotificationQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null
    /**
     * Filter which NotificationQueue to delete.
     */
    where: NotificationQueueWhereUniqueInput
  }

  /**
   * NotificationQueue deleteMany
   */
  export type NotificationQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationQueues to delete
     */
    where?: NotificationQueueWhereInput
    /**
     * Limit how many NotificationQueues to delete.
     */
    limit?: number
  }

  /**
   * NotificationQueue.clinic
   */
  export type NotificationQueue$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * NotificationQueue without action
   */
  export type NotificationQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null
  }


  /**
   * Model Clinic
   */

  export type AggregateClinic = {
    _count: ClinicCountAggregateOutputType | null
    _min: ClinicMinAggregateOutputType | null
    _max: ClinicMaxAggregateOutputType | null
  }

  export type ClinicMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    vatId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    vatId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicCountAggregateOutputType = {
    id: number
    name: number
    address: number
    vatId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    vatId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    vatId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    vatId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinic to aggregate.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clinics
    **/
    _count?: true | ClinicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicMaxAggregateInputType
  }

  export type GetClinicAggregateType<T extends ClinicAggregateArgs> = {
        [P in keyof T & keyof AggregateClinic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinic[P]>
      : GetScalarType<T[P], AggregateClinic[P]>
  }




  export type ClinicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicWhereInput
    orderBy?: ClinicOrderByWithAggregationInput | ClinicOrderByWithAggregationInput[]
    by: ClinicScalarFieldEnum[] | ClinicScalarFieldEnum
    having?: ClinicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicCountAggregateInputType | true
    _min?: ClinicMinAggregateInputType
    _max?: ClinicMaxAggregateInputType
  }

  export type ClinicGroupByOutputType = {
    id: string
    name: string | null
    address: string | null
    vatId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: ClinicCountAggregateOutputType | null
    _min: ClinicMinAggregateOutputType | null
    _max: ClinicMaxAggregateOutputType | null
  }

  type GetClinicGroupByPayload<T extends ClinicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicGroupByOutputType[P]>
        }
      >
    >


  export type ClinicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    vatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admins?: boolean | Clinic$adminsArgs<ExtArgs>
    doctors?: boolean | Clinic$doctorsArgs<ExtArgs>
    patients?: boolean | Clinic$patientsArgs<ExtArgs>
    appointments?: boolean | Clinic$appointmentsArgs<ExtArgs>
    calls?: boolean | Clinic$callsArgs<ExtArgs>
    labs?: boolean | Clinic$labsArgs<ExtArgs>
    prescriptions?: boolean | Clinic$prescriptionsArgs<ExtArgs>
    tasks?: boolean | Clinic$tasksArgs<ExtArgs>
    subscription?: boolean | Clinic$subscriptionArgs<ExtArgs>
    invoices?: boolean | Clinic$invoicesArgs<ExtArgs>
    notificationQueues?: boolean | Clinic$notificationQueuesArgs<ExtArgs>
    auditLogs?: boolean | Clinic$auditLogsArgs<ExtArgs>
    dataRequests?: boolean | Clinic$dataRequestsArgs<ExtArgs>
    consentVersions?: boolean | Clinic$consentVersionsArgs<ExtArgs>
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    vatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    vatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    vatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClinicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "vatId" | "createdAt" | "updatedAt", ExtArgs["result"]["clinic"]>
  export type ClinicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | Clinic$adminsArgs<ExtArgs>
    doctors?: boolean | Clinic$doctorsArgs<ExtArgs>
    patients?: boolean | Clinic$patientsArgs<ExtArgs>
    appointments?: boolean | Clinic$appointmentsArgs<ExtArgs>
    calls?: boolean | Clinic$callsArgs<ExtArgs>
    labs?: boolean | Clinic$labsArgs<ExtArgs>
    prescriptions?: boolean | Clinic$prescriptionsArgs<ExtArgs>
    tasks?: boolean | Clinic$tasksArgs<ExtArgs>
    subscription?: boolean | Clinic$subscriptionArgs<ExtArgs>
    invoices?: boolean | Clinic$invoicesArgs<ExtArgs>
    notificationQueues?: boolean | Clinic$notificationQueuesArgs<ExtArgs>
    auditLogs?: boolean | Clinic$auditLogsArgs<ExtArgs>
    dataRequests?: boolean | Clinic$dataRequestsArgs<ExtArgs>
    consentVersions?: boolean | Clinic$consentVersionsArgs<ExtArgs>
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClinicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClinicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClinicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clinic"
    objects: {
      admins: Prisma.$AdminPayload<ExtArgs>[]
      doctors: Prisma.$DoctorPayload<ExtArgs>[]
      patients: Prisma.$PatientPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      calls: Prisma.$CallPayload<ExtArgs>[]
      labs: Prisma.$LabPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      notificationQueues: Prisma.$NotificationQueuePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      dataRequests: Prisma.$DataRequestPayload<ExtArgs>[]
      consentVersions: Prisma.$ConsentVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      address: string | null
      vatId: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["clinic"]>
    composites: {}
  }

  type ClinicGetPayload<S extends boolean | null | undefined | ClinicDefaultArgs> = $Result.GetResult<Prisma.$ClinicPayload, S>

  type ClinicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicCountAggregateInputType | true
    }

  export interface ClinicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clinic'], meta: { name: 'Clinic' } }
    /**
     * Find zero or one Clinic that matches the filter.
     * @param {ClinicFindUniqueArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicFindUniqueArgs>(args: SelectSubset<T, ClinicFindUniqueArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clinic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicFindUniqueOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clinic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindFirstArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicFindFirstArgs>(args?: SelectSubset<T, ClinicFindFirstArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clinic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindFirstOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clinics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinics
     * const clinics = await prisma.clinic.findMany()
     * 
     * // Get first 10 Clinics
     * const clinics = await prisma.clinic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicWithIdOnly = await prisma.clinic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicFindManyArgs>(args?: SelectSubset<T, ClinicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clinic.
     * @param {ClinicCreateArgs} args - Arguments to create a Clinic.
     * @example
     * // Create one Clinic
     * const Clinic = await prisma.clinic.create({
     *   data: {
     *     // ... data to create a Clinic
     *   }
     * })
     * 
     */
    create<T extends ClinicCreateArgs>(args: SelectSubset<T, ClinicCreateArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clinics.
     * @param {ClinicCreateManyArgs} args - Arguments to create many Clinics.
     * @example
     * // Create many Clinics
     * const clinic = await prisma.clinic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicCreateManyArgs>(args?: SelectSubset<T, ClinicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clinics and returns the data saved in the database.
     * @param {ClinicCreateManyAndReturnArgs} args - Arguments to create many Clinics.
     * @example
     * // Create many Clinics
     * const clinic = await prisma.clinic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clinics and only return the `id`
     * const clinicWithIdOnly = await prisma.clinic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Clinic.
     * @param {ClinicDeleteArgs} args - Arguments to delete one Clinic.
     * @example
     * // Delete one Clinic
     * const Clinic = await prisma.clinic.delete({
     *   where: {
     *     // ... filter to delete one Clinic
     *   }
     * })
     * 
     */
    delete<T extends ClinicDeleteArgs>(args: SelectSubset<T, ClinicDeleteArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clinic.
     * @param {ClinicUpdateArgs} args - Arguments to update one Clinic.
     * @example
     * // Update one Clinic
     * const clinic = await prisma.clinic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicUpdateArgs>(args: SelectSubset<T, ClinicUpdateArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clinics.
     * @param {ClinicDeleteManyArgs} args - Arguments to filter Clinics to delete.
     * @example
     * // Delete a few Clinics
     * const { count } = await prisma.clinic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicDeleteManyArgs>(args?: SelectSubset<T, ClinicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinics
     * const clinic = await prisma.clinic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicUpdateManyArgs>(args: SelectSubset<T, ClinicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinics and returns the data updated in the database.
     * @param {ClinicUpdateManyAndReturnArgs} args - Arguments to update many Clinics.
     * @example
     * // Update many Clinics
     * const clinic = await prisma.clinic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clinics and only return the `id`
     * const clinicWithIdOnly = await prisma.clinic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Clinic.
     * @param {ClinicUpsertArgs} args - Arguments to update or create a Clinic.
     * @example
     * // Update or create a Clinic
     * const clinic = await prisma.clinic.upsert({
     *   create: {
     *     // ... data to create a Clinic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinic we want to update
     *   }
     * })
     */
    upsert<T extends ClinicUpsertArgs>(args: SelectSubset<T, ClinicUpsertArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicCountArgs} args - Arguments to filter Clinics to count.
     * @example
     * // Count the number of Clinics
     * const count = await prisma.clinic.count({
     *   where: {
     *     // ... the filter for the Clinics we want to count
     *   }
     * })
    **/
    count<T extends ClinicCountArgs>(
      args?: Subset<T, ClinicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicAggregateArgs>(args: Subset<T, ClinicAggregateArgs>): Prisma.PrismaPromise<GetClinicAggregateType<T>>

    /**
     * Group by Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicGroupByArgs['orderBy'] }
        : { orderBy?: ClinicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clinic model
   */
  readonly fields: ClinicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clinic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admins<T extends Clinic$adminsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$adminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    doctors<T extends Clinic$doctorsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$doctorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patients<T extends Clinic$patientsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Clinic$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calls<T extends Clinic$callsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$callsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labs<T extends Clinic$labsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$labsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends Clinic$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Clinic$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends Clinic$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoices<T extends Clinic$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationQueues<T extends Clinic$notificationQueuesArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$notificationQueuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Clinic$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dataRequests<T extends Clinic$dataRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$dataRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    consentVersions<T extends Clinic$consentVersionsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$consentVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Clinic model
   */
  interface ClinicFieldRefs {
    readonly id: FieldRef<"Clinic", 'String'>
    readonly name: FieldRef<"Clinic", 'String'>
    readonly address: FieldRef<"Clinic", 'String'>
    readonly vatId: FieldRef<"Clinic", 'String'>
    readonly createdAt: FieldRef<"Clinic", 'DateTime'>
    readonly updatedAt: FieldRef<"Clinic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Clinic findUnique
   */
  export type ClinicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic findUniqueOrThrow
   */
  export type ClinicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic findFirst
   */
  export type ClinicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic findFirstOrThrow
   */
  export type ClinicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic findMany
   */
  export type ClinicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinics to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic create
   */
  export type ClinicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The data needed to create a Clinic.
     */
    data?: XOR<ClinicCreateInput, ClinicUncheckedCreateInput>
  }

  /**
   * Clinic createMany
   */
  export type ClinicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clinics.
     */
    data: ClinicCreateManyInput | ClinicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clinic createManyAndReturn
   */
  export type ClinicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * The data used to create many Clinics.
     */
    data: ClinicCreateManyInput | ClinicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clinic update
   */
  export type ClinicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The data needed to update a Clinic.
     */
    data: XOR<ClinicUpdateInput, ClinicUncheckedUpdateInput>
    /**
     * Choose, which Clinic to update.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic updateMany
   */
  export type ClinicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clinics.
     */
    data: XOR<ClinicUpdateManyMutationInput, ClinicUncheckedUpdateManyInput>
    /**
     * Filter which Clinics to update
     */
    where?: ClinicWhereInput
    /**
     * Limit how many Clinics to update.
     */
    limit?: number
  }

  /**
   * Clinic updateManyAndReturn
   */
  export type ClinicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * The data used to update Clinics.
     */
    data: XOR<ClinicUpdateManyMutationInput, ClinicUncheckedUpdateManyInput>
    /**
     * Filter which Clinics to update
     */
    where?: ClinicWhereInput
    /**
     * Limit how many Clinics to update.
     */
    limit?: number
  }

  /**
   * Clinic upsert
   */
  export type ClinicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The filter to search for the Clinic to update in case it exists.
     */
    where: ClinicWhereUniqueInput
    /**
     * In case the Clinic found by the `where` argument doesn't exist, create a new Clinic with this data.
     */
    create: XOR<ClinicCreateInput, ClinicUncheckedCreateInput>
    /**
     * In case the Clinic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicUpdateInput, ClinicUncheckedUpdateInput>
  }

  /**
   * Clinic delete
   */
  export type ClinicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter which Clinic to delete.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic deleteMany
   */
  export type ClinicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinics to delete
     */
    where?: ClinicWhereInput
    /**
     * Limit how many Clinics to delete.
     */
    limit?: number
  }

  /**
   * Clinic.admins
   */
  export type Clinic$adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Clinic.doctors
   */
  export type Clinic$doctorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    cursor?: DoctorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Clinic.patients
   */
  export type Clinic$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Clinic.appointments
   */
  export type Clinic$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Clinic.calls
   */
  export type Clinic$callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallInclude<ExtArgs> | null
    where?: CallWhereInput
    orderBy?: CallOrderByWithRelationInput | CallOrderByWithRelationInput[]
    cursor?: CallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallScalarFieldEnum | CallScalarFieldEnum[]
  }

  /**
   * Clinic.labs
   */
  export type Clinic$labsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    where?: LabWhereInput
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    cursor?: LabWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * Clinic.prescriptions
   */
  export type Clinic$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Clinic.tasks
   */
  export type Clinic$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Clinic.subscription
   */
  export type Clinic$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Clinic.invoices
   */
  export type Clinic$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Clinic.notificationQueues
   */
  export type Clinic$notificationQueuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null
    where?: NotificationQueueWhereInput
    orderBy?: NotificationQueueOrderByWithRelationInput | NotificationQueueOrderByWithRelationInput[]
    cursor?: NotificationQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[]
  }

  /**
   * Clinic.auditLogs
   */
  export type Clinic$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Clinic.dataRequests
   */
  export type Clinic$dataRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRequest
     */
    select?: DataRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRequest
     */
    omit?: DataRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRequestInclude<ExtArgs> | null
    where?: DataRequestWhereInput
    orderBy?: DataRequestOrderByWithRelationInput | DataRequestOrderByWithRelationInput[]
    cursor?: DataRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataRequestScalarFieldEnum | DataRequestScalarFieldEnum[]
  }

  /**
   * Clinic.consentVersions
   */
  export type Clinic$consentVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersion
     */
    select?: ConsentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConsentVersion
     */
    omit?: ConsentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentVersionInclude<ExtArgs> | null
    where?: ConsentVersionWhereInput
    orderBy?: ConsentVersionOrderByWithRelationInput | ConsentVersionOrderByWithRelationInput[]
    cursor?: ConsentVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsentVersionScalarFieldEnum | ConsentVersionScalarFieldEnum[]
  }

  /**
   * Clinic without action
   */
  export type ClinicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
  }


  /**
   * Model ConsentVersion
   */

  export type AggregateConsentVersion = {
    _count: ConsentVersionCountAggregateOutputType | null
    _min: ConsentVersionMinAggregateOutputType | null
    _max: ConsentVersionMaxAggregateOutputType | null
  }

  export type ConsentVersionMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    type: $Enums.ConsentType | null
    version: string | null
    title: string | null
    body: string | null
    effectiveDate: Date | null
    createdAt: Date | null
  }

  export type ConsentVersionMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    type: $Enums.ConsentType | null
    version: string | null
    title: string | null
    body: string | null
    effectiveDate: Date | null
    createdAt: Date | null
  }

  export type ConsentVersionCountAggregateOutputType = {
    id: number
    clinicId: number
    type: number
    version: number
    title: number
    body: number
    effectiveDate: number
    createdAt: number
    _all: number
  }


  export type ConsentVersionMinAggregateInputType = {
    id?: true
    clinicId?: true
    type?: true
    version?: true
    title?: true
    body?: true
    effectiveDate?: true
    createdAt?: true
  }

  export type ConsentVersionMaxAggregateInputType = {
    id?: true
    clinicId?: true
    type?: true
    version?: true
    title?: true
    body?: true
    effectiveDate?: true
    createdAt?: true
  }

  export type ConsentVersionCountAggregateInputType = {
    id?: true
    clinicId?: true
    type?: true
    version?: true
    title?: true
    body?: true
    effectiveDate?: true
    createdAt?: true
    _all?: true
  }

  export type ConsentVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsentVersion to aggregate.
     */
    where?: ConsentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentVersions to fetch.
     */
    orderBy?: ConsentVersionOrderByWithRelationInput | ConsentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConsentVersions
    **/
    _count?: true | ConsentVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsentVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsentVersionMaxAggregateInputType
  }

  export type GetConsentVersionAggregateType<T extends ConsentVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateConsentVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsentVersion[P]>
      : GetScalarType<T[P], AggregateConsentVersion[P]>
  }




  export type ConsentVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsentVersionWhereInput
    orderBy?: ConsentVersionOrderByWithAggregationInput | ConsentVersionOrderByWithAggregationInput[]
    by: ConsentVersionScalarFieldEnum[] | ConsentVersionScalarFieldEnum
    having?: ConsentVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsentVersionCountAggregateInputType | true
    _min?: ConsentVersionMinAggregateInputType
    _max?: ConsentVersionMaxAggregateInputType
  }

  export type ConsentVersionGroupByOutputType = {
    id: string
    clinicId: string | null
    type: $Enums.ConsentType | null
    version: string | null
    title: string | null
    body: string | null
    effectiveDate: Date | null
    createdAt: Date | null
    _count: ConsentVersionCountAggregateOutputType | null
    _min: ConsentVersionMinAggregateOutputType | null
    _max: ConsentVersionMaxAggregateOutputType | null
  }

  type GetConsentVersionGroupByPayload<T extends ConsentVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsentVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsentVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsentVersionGroupByOutputType[P]>
            : GetScalarType<T[P], ConsentVersionGroupByOutputType[P]>
        }
      >
    >


  export type ConsentVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    type?: boolean
    version?: boolean
    title?: boolean
    body?: boolean
    effectiveDate?: boolean
    createdAt?: boolean
    clinic?: boolean | ConsentVersion$clinicArgs<ExtArgs>
    patientConsents?: boolean | ConsentVersion$patientConsentsArgs<ExtArgs>
    _count?: boolean | ConsentVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consentVersion"]>

  export type ConsentVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    type?: boolean
    version?: boolean
    title?: boolean
    body?: boolean
    effectiveDate?: boolean
    createdAt?: boolean
    clinic?: boolean | ConsentVersion$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["consentVersion"]>

  export type ConsentVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    type?: boolean
    version?: boolean
    title?: boolean
    body?: boolean
    effectiveDate?: boolean
    createdAt?: boolean
    clinic?: boolean | ConsentVersion$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["consentVersion"]>

  export type ConsentVersionSelectScalar = {
    id?: boolean
    clinicId?: boolean
    type?: boolean
    version?: boolean
    title?: boolean
    body?: boolean
    effectiveDate?: boolean
    createdAt?: boolean
  }

  export type ConsentVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "type" | "version" | "title" | "body" | "effectiveDate" | "createdAt", ExtArgs["result"]["consentVersion"]>
  export type ConsentVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ConsentVersion$clinicArgs<ExtArgs>
    patientConsents?: boolean | ConsentVersion$patientConsentsArgs<ExtArgs>
    _count?: boolean | ConsentVersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConsentVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ConsentVersion$clinicArgs<ExtArgs>
  }
  export type ConsentVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ConsentVersion$clinicArgs<ExtArgs>
  }

  export type $ConsentVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConsentVersion"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      patientConsents: Prisma.$PatientConsentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string | null
      type: $Enums.ConsentType | null
      version: string | null
      title: string | null
      body: string | null
      effectiveDate: Date | null
      createdAt: Date | null
    }, ExtArgs["result"]["consentVersion"]>
    composites: {}
  }

  type ConsentVersionGetPayload<S extends boolean | null | undefined | ConsentVersionDefaultArgs> = $Result.GetResult<Prisma.$ConsentVersionPayload, S>

  type ConsentVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConsentVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsentVersionCountAggregateInputType | true
    }

  export interface ConsentVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConsentVersion'], meta: { name: 'ConsentVersion' } }
    /**
     * Find zero or one ConsentVersion that matches the filter.
     * @param {ConsentVersionFindUniqueArgs} args - Arguments to find a ConsentVersion
     * @example
     * // Get one ConsentVersion
     * const consentVersion = await prisma.consentVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsentVersionFindUniqueArgs>(args: SelectSubset<T, ConsentVersionFindUniqueArgs<ExtArgs>>): Prisma__ConsentVersionClient<$Result.GetResult<Prisma.$ConsentVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConsentVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConsentVersionFindUniqueOrThrowArgs} args - Arguments to find a ConsentVersion
     * @example
     * // Get one ConsentVersion
     * const consentVersion = await prisma.consentVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsentVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsentVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsentVersionClient<$Result.GetResult<Prisma.$ConsentVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConsentVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentVersionFindFirstArgs} args - Arguments to find a ConsentVersion
     * @example
     * // Get one ConsentVersion
     * const consentVersion = await prisma.consentVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsentVersionFindFirstArgs>(args?: SelectSubset<T, ConsentVersionFindFirstArgs<ExtArgs>>): Prisma__ConsentVersionClient<$Result.GetResult<Prisma.$ConsentVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConsentVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentVersionFindFirstOrThrowArgs} args - Arguments to find a ConsentVersion
     * @example
     * // Get one ConsentVersion
     * const consentVersion = await prisma.consentVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsentVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsentVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsentVersionClient<$Result.GetResult<Prisma.$ConsentVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConsentVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsentVersions
     * const consentVersions = await prisma.consentVersion.findMany()
     * 
     * // Get first 10 ConsentVersions
     * const consentVersions = await prisma.consentVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consentVersionWithIdOnly = await prisma.consentVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsentVersionFindManyArgs>(args?: SelectSubset<T, ConsentVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConsentVersion.
     * @param {ConsentVersionCreateArgs} args - Arguments to create a ConsentVersion.
     * @example
     * // Create one ConsentVersion
     * const ConsentVersion = await prisma.consentVersion.create({
     *   data: {
     *     // ... data to create a ConsentVersion
     *   }
     * })
     * 
     */
    create<T extends ConsentVersionCreateArgs>(args: SelectSubset<T, ConsentVersionCreateArgs<ExtArgs>>): Prisma__ConsentVersionClient<$Result.GetResult<Prisma.$ConsentVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConsentVersions.
     * @param {ConsentVersionCreateManyArgs} args - Arguments to create many ConsentVersions.
     * @example
     * // Create many ConsentVersions
     * const consentVersion = await prisma.consentVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsentVersionCreateManyArgs>(args?: SelectSubset<T, ConsentVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConsentVersions and returns the data saved in the database.
     * @param {ConsentVersionCreateManyAndReturnArgs} args - Arguments to create many ConsentVersions.
     * @example
     * // Create many ConsentVersions
     * const consentVersion = await prisma.consentVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConsentVersions and only return the `id`
     * const consentVersionWithIdOnly = await prisma.consentVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsentVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsentVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConsentVersion.
     * @param {ConsentVersionDeleteArgs} args - Arguments to delete one ConsentVersion.
     * @example
     * // Delete one ConsentVersion
     * const ConsentVersion = await prisma.consentVersion.delete({
     *   where: {
     *     // ... filter to delete one ConsentVersion
     *   }
     * })
     * 
     */
    delete<T extends ConsentVersionDeleteArgs>(args: SelectSubset<T, ConsentVersionDeleteArgs<ExtArgs>>): Prisma__ConsentVersionClient<$Result.GetResult<Prisma.$ConsentVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConsentVersion.
     * @param {ConsentVersionUpdateArgs} args - Arguments to update one ConsentVersion.
     * @example
     * // Update one ConsentVersion
     * const consentVersion = await prisma.consentVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsentVersionUpdateArgs>(args: SelectSubset<T, ConsentVersionUpdateArgs<ExtArgs>>): Prisma__ConsentVersionClient<$Result.GetResult<Prisma.$ConsentVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConsentVersions.
     * @param {ConsentVersionDeleteManyArgs} args - Arguments to filter ConsentVersions to delete.
     * @example
     * // Delete a few ConsentVersions
     * const { count } = await prisma.consentVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsentVersionDeleteManyArgs>(args?: SelectSubset<T, ConsentVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsentVersions
     * const consentVersion = await prisma.consentVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsentVersionUpdateManyArgs>(args: SelectSubset<T, ConsentVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsentVersions and returns the data updated in the database.
     * @param {ConsentVersionUpdateManyAndReturnArgs} args - Arguments to update many ConsentVersions.
     * @example
     * // Update many ConsentVersions
     * const consentVersion = await prisma.consentVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConsentVersions and only return the `id`
     * const consentVersionWithIdOnly = await prisma.consentVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConsentVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, ConsentVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConsentVersion.
     * @param {ConsentVersionUpsertArgs} args - Arguments to update or create a ConsentVersion.
     * @example
     * // Update or create a ConsentVersion
     * const consentVersion = await prisma.consentVersion.upsert({
     *   create: {
     *     // ... data to create a ConsentVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsentVersion we want to update
     *   }
     * })
     */
    upsert<T extends ConsentVersionUpsertArgs>(args: SelectSubset<T, ConsentVersionUpsertArgs<ExtArgs>>): Prisma__ConsentVersionClient<$Result.GetResult<Prisma.$ConsentVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConsentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentVersionCountArgs} args - Arguments to filter ConsentVersions to count.
     * @example
     * // Count the number of ConsentVersions
     * const count = await prisma.consentVersion.count({
     *   where: {
     *     // ... the filter for the ConsentVersions we want to count
     *   }
     * })
    **/
    count<T extends ConsentVersionCountArgs>(
      args?: Subset<T, ConsentVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsentVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsentVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsentVersionAggregateArgs>(args: Subset<T, ConsentVersionAggregateArgs>): Prisma.PrismaPromise<GetConsentVersionAggregateType<T>>

    /**
     * Group by ConsentVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsentVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsentVersionGroupByArgs['orderBy'] }
        : { orderBy?: ConsentVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsentVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsentVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConsentVersion model
   */
  readonly fields: ConsentVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsentVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsentVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ConsentVersion$clinicArgs<ExtArgs> = {}>(args?: Subset<T, ConsentVersion$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patientConsents<T extends ConsentVersion$patientConsentsArgs<ExtArgs> = {}>(args?: Subset<T, ConsentVersion$patientConsentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConsentVersion model
   */
  interface ConsentVersionFieldRefs {
    readonly id: FieldRef<"ConsentVersion", 'String'>
    readonly clinicId: FieldRef<"ConsentVersion", 'String'>
    readonly type: FieldRef<"ConsentVersion", 'ConsentType'>
    readonly version: FieldRef<"ConsentVersion", 'String'>
    readonly title: FieldRef<"ConsentVersion", 'String'>
    readonly body: FieldRef<"ConsentVersion", 'String'>
    readonly effectiveDate: FieldRef<"ConsentVersion", 'DateTime'>
    readonly createdAt: FieldRef<"ConsentVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConsentVersion findUnique
   */
  export type ConsentVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersion
     */
    select?: ConsentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConsentVersion
     */
    omit?: ConsentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ConsentVersion to fetch.
     */
    where: ConsentVersionWhereUniqueInput
  }

  /**
   * ConsentVersion findUniqueOrThrow
   */
  export type ConsentVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersion
     */
    select?: ConsentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConsentVersion
     */
    omit?: ConsentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ConsentVersion to fetch.
     */
    where: ConsentVersionWhereUniqueInput
  }

  /**
   * ConsentVersion findFirst
   */
  export type ConsentVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersion
     */
    select?: ConsentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConsentVersion
     */
    omit?: ConsentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ConsentVersion to fetch.
     */
    where?: ConsentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentVersions to fetch.
     */
    orderBy?: ConsentVersionOrderByWithRelationInput | ConsentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsentVersions.
     */
    cursor?: ConsentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsentVersions.
     */
    distinct?: ConsentVersionScalarFieldEnum | ConsentVersionScalarFieldEnum[]
  }

  /**
   * ConsentVersion findFirstOrThrow
   */
  export type ConsentVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersion
     */
    select?: ConsentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConsentVersion
     */
    omit?: ConsentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ConsentVersion to fetch.
     */
    where?: ConsentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentVersions to fetch.
     */
    orderBy?: ConsentVersionOrderByWithRelationInput | ConsentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsentVersions.
     */
    cursor?: ConsentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsentVersions.
     */
    distinct?: ConsentVersionScalarFieldEnum | ConsentVersionScalarFieldEnum[]
  }

  /**
   * ConsentVersion findMany
   */
  export type ConsentVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersion
     */
    select?: ConsentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConsentVersion
     */
    omit?: ConsentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentVersionInclude<ExtArgs> | null
    /**
     * Filter, which ConsentVersions to fetch.
     */
    where?: ConsentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentVersions to fetch.
     */
    orderBy?: ConsentVersionOrderByWithRelationInput | ConsentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConsentVersions.
     */
    cursor?: ConsentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentVersions.
     */
    skip?: number
    distinct?: ConsentVersionScalarFieldEnum | ConsentVersionScalarFieldEnum[]
  }

  /**
   * ConsentVersion create
   */
  export type ConsentVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersion
     */
    select?: ConsentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConsentVersion
     */
    omit?: ConsentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a ConsentVersion.
     */
    data?: XOR<ConsentVersionCreateInput, ConsentVersionUncheckedCreateInput>
  }

  /**
   * ConsentVersion createMany
   */
  export type ConsentVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConsentVersions.
     */
    data: ConsentVersionCreateManyInput | ConsentVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConsentVersion createManyAndReturn
   */
  export type ConsentVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersion
     */
    select?: ConsentVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConsentVersion
     */
    omit?: ConsentVersionOmit<ExtArgs> | null
    /**
     * The data used to create many ConsentVersions.
     */
    data: ConsentVersionCreateManyInput | ConsentVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConsentVersion update
   */
  export type ConsentVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersion
     */
    select?: ConsentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConsentVersion
     */
    omit?: ConsentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a ConsentVersion.
     */
    data: XOR<ConsentVersionUpdateInput, ConsentVersionUncheckedUpdateInput>
    /**
     * Choose, which ConsentVersion to update.
     */
    where: ConsentVersionWhereUniqueInput
  }

  /**
   * ConsentVersion updateMany
   */
  export type ConsentVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConsentVersions.
     */
    data: XOR<ConsentVersionUpdateManyMutationInput, ConsentVersionUncheckedUpdateManyInput>
    /**
     * Filter which ConsentVersions to update
     */
    where?: ConsentVersionWhereInput
    /**
     * Limit how many ConsentVersions to update.
     */
    limit?: number
  }

  /**
   * ConsentVersion updateManyAndReturn
   */
  export type ConsentVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersion
     */
    select?: ConsentVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConsentVersion
     */
    omit?: ConsentVersionOmit<ExtArgs> | null
    /**
     * The data used to update ConsentVersions.
     */
    data: XOR<ConsentVersionUpdateManyMutationInput, ConsentVersionUncheckedUpdateManyInput>
    /**
     * Filter which ConsentVersions to update
     */
    where?: ConsentVersionWhereInput
    /**
     * Limit how many ConsentVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConsentVersion upsert
   */
  export type ConsentVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersion
     */
    select?: ConsentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConsentVersion
     */
    omit?: ConsentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the ConsentVersion to update in case it exists.
     */
    where: ConsentVersionWhereUniqueInput
    /**
     * In case the ConsentVersion found by the `where` argument doesn't exist, create a new ConsentVersion with this data.
     */
    create: XOR<ConsentVersionCreateInput, ConsentVersionUncheckedCreateInput>
    /**
     * In case the ConsentVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsentVersionUpdateInput, ConsentVersionUncheckedUpdateInput>
  }

  /**
   * ConsentVersion delete
   */
  export type ConsentVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersion
     */
    select?: ConsentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConsentVersion
     */
    omit?: ConsentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentVersionInclude<ExtArgs> | null
    /**
     * Filter which ConsentVersion to delete.
     */
    where: ConsentVersionWhereUniqueInput
  }

  /**
   * ConsentVersion deleteMany
   */
  export type ConsentVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsentVersions to delete
     */
    where?: ConsentVersionWhereInput
    /**
     * Limit how many ConsentVersions to delete.
     */
    limit?: number
  }

  /**
   * ConsentVersion.clinic
   */
  export type ConsentVersion$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * ConsentVersion.patientConsents
   */
  export type ConsentVersion$patientConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientConsent
     */
    select?: PatientConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientConsent
     */
    omit?: PatientConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientConsentInclude<ExtArgs> | null
    where?: PatientConsentWhereInput
    orderBy?: PatientConsentOrderByWithRelationInput | PatientConsentOrderByWithRelationInput[]
    cursor?: PatientConsentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientConsentScalarFieldEnum | PatientConsentScalarFieldEnum[]
  }

  /**
   * ConsentVersion without action
   */
  export type ConsentVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersion
     */
    select?: ConsentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConsentVersion
     */
    omit?: ConsentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentVersionInclude<ExtArgs> | null
  }


  /**
   * Model PatientConsent
   */

  export type AggregatePatientConsent = {
    _count: PatientConsentCountAggregateOutputType | null
    _min: PatientConsentMinAggregateOutputType | null
    _max: PatientConsentMaxAggregateOutputType | null
  }

  export type PatientConsentMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    consentVersionId: string | null
    type: $Enums.ConsentType | null
    given: boolean | null
    givenAt: Date | null
    withdrawnAt: Date | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientConsentMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    consentVersionId: string | null
    type: $Enums.ConsentType | null
    given: boolean | null
    givenAt: Date | null
    withdrawnAt: Date | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientConsentCountAggregateOutputType = {
    id: number
    patientId: number
    consentVersionId: number
    type: number
    given: number
    givenAt: number
    withdrawnAt: number
    ip: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientConsentMinAggregateInputType = {
    id?: true
    patientId?: true
    consentVersionId?: true
    type?: true
    given?: true
    givenAt?: true
    withdrawnAt?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientConsentMaxAggregateInputType = {
    id?: true
    patientId?: true
    consentVersionId?: true
    type?: true
    given?: true
    givenAt?: true
    withdrawnAt?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientConsentCountAggregateInputType = {
    id?: true
    patientId?: true
    consentVersionId?: true
    type?: true
    given?: true
    givenAt?: true
    withdrawnAt?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientConsent to aggregate.
     */
    where?: PatientConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientConsents to fetch.
     */
    orderBy?: PatientConsentOrderByWithRelationInput | PatientConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientConsents
    **/
    _count?: true | PatientConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientConsentMaxAggregateInputType
  }

  export type GetPatientConsentAggregateType<T extends PatientConsentAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientConsent[P]>
      : GetScalarType<T[P], AggregatePatientConsent[P]>
  }




  export type PatientConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientConsentWhereInput
    orderBy?: PatientConsentOrderByWithAggregationInput | PatientConsentOrderByWithAggregationInput[]
    by: PatientConsentScalarFieldEnum[] | PatientConsentScalarFieldEnum
    having?: PatientConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientConsentCountAggregateInputType | true
    _min?: PatientConsentMinAggregateInputType
    _max?: PatientConsentMaxAggregateInputType
  }

  export type PatientConsentGroupByOutputType = {
    id: string
    patientId: string | null
    consentVersionId: string | null
    type: $Enums.ConsentType | null
    given: boolean | null
    givenAt: Date | null
    withdrawnAt: Date | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: PatientConsentCountAggregateOutputType | null
    _min: PatientConsentMinAggregateOutputType | null
    _max: PatientConsentMaxAggregateOutputType | null
  }

  type GetPatientConsentGroupByPayload<T extends PatientConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientConsentGroupByOutputType[P]>
            : GetScalarType<T[P], PatientConsentGroupByOutputType[P]>
        }
      >
    >


  export type PatientConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    consentVersionId?: boolean
    type?: boolean
    given?: boolean
    givenAt?: boolean
    withdrawnAt?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientConsent$patientArgs<ExtArgs>
    consentVersion?: boolean | PatientConsent$consentVersionArgs<ExtArgs>
  }, ExtArgs["result"]["patientConsent"]>

  export type PatientConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    consentVersionId?: boolean
    type?: boolean
    given?: boolean
    givenAt?: boolean
    withdrawnAt?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientConsent$patientArgs<ExtArgs>
    consentVersion?: boolean | PatientConsent$consentVersionArgs<ExtArgs>
  }, ExtArgs["result"]["patientConsent"]>

  export type PatientConsentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    consentVersionId?: boolean
    type?: boolean
    given?: boolean
    givenAt?: boolean
    withdrawnAt?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientConsent$patientArgs<ExtArgs>
    consentVersion?: boolean | PatientConsent$consentVersionArgs<ExtArgs>
  }, ExtArgs["result"]["patientConsent"]>

  export type PatientConsentSelectScalar = {
    id?: boolean
    patientId?: boolean
    consentVersionId?: boolean
    type?: boolean
    given?: boolean
    givenAt?: boolean
    withdrawnAt?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientConsentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "consentVersionId" | "type" | "given" | "givenAt" | "withdrawnAt" | "ip" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["patientConsent"]>
  export type PatientConsentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientConsent$patientArgs<ExtArgs>
    consentVersion?: boolean | PatientConsent$consentVersionArgs<ExtArgs>
  }
  export type PatientConsentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientConsent$patientArgs<ExtArgs>
    consentVersion?: boolean | PatientConsent$consentVersionArgs<ExtArgs>
  }
  export type PatientConsentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientConsent$patientArgs<ExtArgs>
    consentVersion?: boolean | PatientConsent$consentVersionArgs<ExtArgs>
  }

  export type $PatientConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientConsent"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs> | null
      consentVersion: Prisma.$ConsentVersionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      consentVersionId: string | null
      type: $Enums.ConsentType | null
      given: boolean | null
      givenAt: Date | null
      withdrawnAt: Date | null
      ip: string | null
      userAgent: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["patientConsent"]>
    composites: {}
  }

  type PatientConsentGetPayload<S extends boolean | null | undefined | PatientConsentDefaultArgs> = $Result.GetResult<Prisma.$PatientConsentPayload, S>

  type PatientConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientConsentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientConsentCountAggregateInputType | true
    }

  export interface PatientConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientConsent'], meta: { name: 'PatientConsent' } }
    /**
     * Find zero or one PatientConsent that matches the filter.
     * @param {PatientConsentFindUniqueArgs} args - Arguments to find a PatientConsent
     * @example
     * // Get one PatientConsent
     * const patientConsent = await prisma.patientConsent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientConsentFindUniqueArgs>(args: SelectSubset<T, PatientConsentFindUniqueArgs<ExtArgs>>): Prisma__PatientConsentClient<$Result.GetResult<Prisma.$PatientConsentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PatientConsent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientConsentFindUniqueOrThrowArgs} args - Arguments to find a PatientConsent
     * @example
     * // Get one PatientConsent
     * const patientConsent = await prisma.patientConsent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientConsentClient<$Result.GetResult<Prisma.$PatientConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientConsent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientConsentFindFirstArgs} args - Arguments to find a PatientConsent
     * @example
     * // Get one PatientConsent
     * const patientConsent = await prisma.patientConsent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientConsentFindFirstArgs>(args?: SelectSubset<T, PatientConsentFindFirstArgs<ExtArgs>>): Prisma__PatientConsentClient<$Result.GetResult<Prisma.$PatientConsentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientConsent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientConsentFindFirstOrThrowArgs} args - Arguments to find a PatientConsent
     * @example
     * // Get one PatientConsent
     * const patientConsent = await prisma.patientConsent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientConsentClient<$Result.GetResult<Prisma.$PatientConsentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PatientConsents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientConsents
     * const patientConsents = await prisma.patientConsent.findMany()
     * 
     * // Get first 10 PatientConsents
     * const patientConsents = await prisma.patientConsent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientConsentWithIdOnly = await prisma.patientConsent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientConsentFindManyArgs>(args?: SelectSubset<T, PatientConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PatientConsent.
     * @param {PatientConsentCreateArgs} args - Arguments to create a PatientConsent.
     * @example
     * // Create one PatientConsent
     * const PatientConsent = await prisma.patientConsent.create({
     *   data: {
     *     // ... data to create a PatientConsent
     *   }
     * })
     * 
     */
    create<T extends PatientConsentCreateArgs>(args: SelectSubset<T, PatientConsentCreateArgs<ExtArgs>>): Prisma__PatientConsentClient<$Result.GetResult<Prisma.$PatientConsentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PatientConsents.
     * @param {PatientConsentCreateManyArgs} args - Arguments to create many PatientConsents.
     * @example
     * // Create many PatientConsents
     * const patientConsent = await prisma.patientConsent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientConsentCreateManyArgs>(args?: SelectSubset<T, PatientConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientConsents and returns the data saved in the database.
     * @param {PatientConsentCreateManyAndReturnArgs} args - Arguments to create many PatientConsents.
     * @example
     * // Create many PatientConsents
     * const patientConsent = await prisma.patientConsent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientConsents and only return the `id`
     * const patientConsentWithIdOnly = await prisma.patientConsent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientConsentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PatientConsent.
     * @param {PatientConsentDeleteArgs} args - Arguments to delete one PatientConsent.
     * @example
     * // Delete one PatientConsent
     * const PatientConsent = await prisma.patientConsent.delete({
     *   where: {
     *     // ... filter to delete one PatientConsent
     *   }
     * })
     * 
     */
    delete<T extends PatientConsentDeleteArgs>(args: SelectSubset<T, PatientConsentDeleteArgs<ExtArgs>>): Prisma__PatientConsentClient<$Result.GetResult<Prisma.$PatientConsentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PatientConsent.
     * @param {PatientConsentUpdateArgs} args - Arguments to update one PatientConsent.
     * @example
     * // Update one PatientConsent
     * const patientConsent = await prisma.patientConsent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientConsentUpdateArgs>(args: SelectSubset<T, PatientConsentUpdateArgs<ExtArgs>>): Prisma__PatientConsentClient<$Result.GetResult<Prisma.$PatientConsentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PatientConsents.
     * @param {PatientConsentDeleteManyArgs} args - Arguments to filter PatientConsents to delete.
     * @example
     * // Delete a few PatientConsents
     * const { count } = await prisma.patientConsent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientConsentDeleteManyArgs>(args?: SelectSubset<T, PatientConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientConsents
     * const patientConsent = await prisma.patientConsent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientConsentUpdateManyArgs>(args: SelectSubset<T, PatientConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientConsents and returns the data updated in the database.
     * @param {PatientConsentUpdateManyAndReturnArgs} args - Arguments to update many PatientConsents.
     * @example
     * // Update many PatientConsents
     * const patientConsent = await prisma.patientConsent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PatientConsents and only return the `id`
     * const patientConsentWithIdOnly = await prisma.patientConsent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientConsentUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientConsentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientConsentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PatientConsent.
     * @param {PatientConsentUpsertArgs} args - Arguments to update or create a PatientConsent.
     * @example
     * // Update or create a PatientConsent
     * const patientConsent = await prisma.patientConsent.upsert({
     *   create: {
     *     // ... data to create a PatientConsent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientConsent we want to update
     *   }
     * })
     */
    upsert<T extends PatientConsentUpsertArgs>(args: SelectSubset<T, PatientConsentUpsertArgs<ExtArgs>>): Prisma__PatientConsentClient<$Result.GetResult<Prisma.$PatientConsentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PatientConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientConsentCountArgs} args - Arguments to filter PatientConsents to count.
     * @example
     * // Count the number of PatientConsents
     * const count = await prisma.patientConsent.count({
     *   where: {
     *     // ... the filter for the PatientConsents we want to count
     *   }
     * })
    **/
    count<T extends PatientConsentCountArgs>(
      args?: Subset<T, PatientConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientConsentAggregateArgs>(args: Subset<T, PatientConsentAggregateArgs>): Prisma.PrismaPromise<GetPatientConsentAggregateType<T>>

    /**
     * Group by PatientConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientConsentGroupByArgs['orderBy'] }
        : { orderBy?: PatientConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientConsent model
   */
  readonly fields: PatientConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientConsent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientConsent$patientArgs<ExtArgs> = {}>(args?: Subset<T, PatientConsent$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    consentVersion<T extends PatientConsent$consentVersionArgs<ExtArgs> = {}>(args?: Subset<T, PatientConsent$consentVersionArgs<ExtArgs>>): Prisma__ConsentVersionClient<$Result.GetResult<Prisma.$ConsentVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientConsent model
   */
  interface PatientConsentFieldRefs {
    readonly id: FieldRef<"PatientConsent", 'String'>
    readonly patientId: FieldRef<"PatientConsent", 'String'>
    readonly consentVersionId: FieldRef<"PatientConsent", 'String'>
    readonly type: FieldRef<"PatientConsent", 'ConsentType'>
    readonly given: FieldRef<"PatientConsent", 'Boolean'>
    readonly givenAt: FieldRef<"PatientConsent", 'DateTime'>
    readonly withdrawnAt: FieldRef<"PatientConsent", 'DateTime'>
    readonly ip: FieldRef<"PatientConsent", 'String'>
    readonly userAgent: FieldRef<"PatientConsent", 'String'>
    readonly createdAt: FieldRef<"PatientConsent", 'DateTime'>
    readonly updatedAt: FieldRef<"PatientConsent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PatientConsent findUnique
   */
  export type PatientConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientConsent
     */
    select?: PatientConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientConsent
     */
    omit?: PatientConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientConsentInclude<ExtArgs> | null
    /**
     * Filter, which PatientConsent to fetch.
     */
    where: PatientConsentWhereUniqueInput
  }

  /**
   * PatientConsent findUniqueOrThrow
   */
  export type PatientConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientConsent
     */
    select?: PatientConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientConsent
     */
    omit?: PatientConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientConsentInclude<ExtArgs> | null
    /**
     * Filter, which PatientConsent to fetch.
     */
    where: PatientConsentWhereUniqueInput
  }

  /**
   * PatientConsent findFirst
   */
  export type PatientConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientConsent
     */
    select?: PatientConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientConsent
     */
    omit?: PatientConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientConsentInclude<ExtArgs> | null
    /**
     * Filter, which PatientConsent to fetch.
     */
    where?: PatientConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientConsents to fetch.
     */
    orderBy?: PatientConsentOrderByWithRelationInput | PatientConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientConsents.
     */
    cursor?: PatientConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientConsents.
     */
    distinct?: PatientConsentScalarFieldEnum | PatientConsentScalarFieldEnum[]
  }

  /**
   * PatientConsent findFirstOrThrow
   */
  export type PatientConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientConsent
     */
    select?: PatientConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientConsent
     */
    omit?: PatientConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientConsentInclude<ExtArgs> | null
    /**
     * Filter, which PatientConsent to fetch.
     */
    where?: PatientConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientConsents to fetch.
     */
    orderBy?: PatientConsentOrderByWithRelationInput | PatientConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientConsents.
     */
    cursor?: PatientConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientConsents.
     */
    distinct?: PatientConsentScalarFieldEnum | PatientConsentScalarFieldEnum[]
  }

  /**
   * PatientConsent findMany
   */
  export type PatientConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientConsent
     */
    select?: PatientConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientConsent
     */
    omit?: PatientConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientConsentInclude<ExtArgs> | null
    /**
     * Filter, which PatientConsents to fetch.
     */
    where?: PatientConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientConsents to fetch.
     */
    orderBy?: PatientConsentOrderByWithRelationInput | PatientConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientConsents.
     */
    cursor?: PatientConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientConsents.
     */
    skip?: number
    distinct?: PatientConsentScalarFieldEnum | PatientConsentScalarFieldEnum[]
  }

  /**
   * PatientConsent create
   */
  export type PatientConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientConsent
     */
    select?: PatientConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientConsent
     */
    omit?: PatientConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientConsentInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientConsent.
     */
    data?: XOR<PatientConsentCreateInput, PatientConsentUncheckedCreateInput>
  }

  /**
   * PatientConsent createMany
   */
  export type PatientConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientConsents.
     */
    data: PatientConsentCreateManyInput | PatientConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientConsent createManyAndReturn
   */
  export type PatientConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientConsent
     */
    select?: PatientConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientConsent
     */
    omit?: PatientConsentOmit<ExtArgs> | null
    /**
     * The data used to create many PatientConsents.
     */
    data: PatientConsentCreateManyInput | PatientConsentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientConsentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientConsent update
   */
  export type PatientConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientConsent
     */
    select?: PatientConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientConsent
     */
    omit?: PatientConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientConsentInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientConsent.
     */
    data: XOR<PatientConsentUpdateInput, PatientConsentUncheckedUpdateInput>
    /**
     * Choose, which PatientConsent to update.
     */
    where: PatientConsentWhereUniqueInput
  }

  /**
   * PatientConsent updateMany
   */
  export type PatientConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientConsents.
     */
    data: XOR<PatientConsentUpdateManyMutationInput, PatientConsentUncheckedUpdateManyInput>
    /**
     * Filter which PatientConsents to update
     */
    where?: PatientConsentWhereInput
    /**
     * Limit how many PatientConsents to update.
     */
    limit?: number
  }

  /**
   * PatientConsent updateManyAndReturn
   */
  export type PatientConsentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientConsent
     */
    select?: PatientConsentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientConsent
     */
    omit?: PatientConsentOmit<ExtArgs> | null
    /**
     * The data used to update PatientConsents.
     */
    data: XOR<PatientConsentUpdateManyMutationInput, PatientConsentUncheckedUpdateManyInput>
    /**
     * Filter which PatientConsents to update
     */
    where?: PatientConsentWhereInput
    /**
     * Limit how many PatientConsents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientConsentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientConsent upsert
   */
  export type PatientConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientConsent
     */
    select?: PatientConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientConsent
     */
    omit?: PatientConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientConsentInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientConsent to update in case it exists.
     */
    where: PatientConsentWhereUniqueInput
    /**
     * In case the PatientConsent found by the `where` argument doesn't exist, create a new PatientConsent with this data.
     */
    create: XOR<PatientConsentCreateInput, PatientConsentUncheckedCreateInput>
    /**
     * In case the PatientConsent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientConsentUpdateInput, PatientConsentUncheckedUpdateInput>
  }

  /**
   * PatientConsent delete
   */
  export type PatientConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientConsent
     */
    select?: PatientConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientConsent
     */
    omit?: PatientConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientConsentInclude<ExtArgs> | null
    /**
     * Filter which PatientConsent to delete.
     */
    where: PatientConsentWhereUniqueInput
  }

  /**
   * PatientConsent deleteMany
   */
  export type PatientConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientConsents to delete
     */
    where?: PatientConsentWhereInput
    /**
     * Limit how many PatientConsents to delete.
     */
    limit?: number
  }

  /**
   * PatientConsent.patient
   */
  export type PatientConsent$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * PatientConsent.consentVersion
   */
  export type PatientConsent$consentVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentVersion
     */
    select?: ConsentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConsentVersion
     */
    omit?: ConsentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentVersionInclude<ExtArgs> | null
    where?: ConsentVersionWhereInput
  }

  /**
   * PatientConsent without action
   */
  export type PatientConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientConsent
     */
    select?: PatientConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientConsent
     */
    omit?: PatientConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientConsentInclude<ExtArgs> | null
  }


  /**
   * Model KeyManagement
   */

  export type AggregateKeyManagement = {
    _count: KeyManagementCountAggregateOutputType | null
    _min: KeyManagementMinAggregateOutputType | null
    _max: KeyManagementMaxAggregateOutputType | null
  }

  export type KeyManagementMinAggregateOutputType = {
    id: string | null
    version: string | null
    dekCipher: Uint8Array | null
    createdAt: Date | null
    rotatedAt: Date | null
  }

  export type KeyManagementMaxAggregateOutputType = {
    id: string | null
    version: string | null
    dekCipher: Uint8Array | null
    createdAt: Date | null
    rotatedAt: Date | null
  }

  export type KeyManagementCountAggregateOutputType = {
    id: number
    version: number
    dekCipher: number
    createdAt: number
    rotatedAt: number
    _all: number
  }


  export type KeyManagementMinAggregateInputType = {
    id?: true
    version?: true
    dekCipher?: true
    createdAt?: true
    rotatedAt?: true
  }

  export type KeyManagementMaxAggregateInputType = {
    id?: true
    version?: true
    dekCipher?: true
    createdAt?: true
    rotatedAt?: true
  }

  export type KeyManagementCountAggregateInputType = {
    id?: true
    version?: true
    dekCipher?: true
    createdAt?: true
    rotatedAt?: true
    _all?: true
  }

  export type KeyManagementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeyManagement to aggregate.
     */
    where?: KeyManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyManagements to fetch.
     */
    orderBy?: KeyManagementOrderByWithRelationInput | KeyManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeyManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KeyManagements
    **/
    _count?: true | KeyManagementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeyManagementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeyManagementMaxAggregateInputType
  }

  export type GetKeyManagementAggregateType<T extends KeyManagementAggregateArgs> = {
        [P in keyof T & keyof AggregateKeyManagement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyManagement[P]>
      : GetScalarType<T[P], AggregateKeyManagement[P]>
  }




  export type KeyManagementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeyManagementWhereInput
    orderBy?: KeyManagementOrderByWithAggregationInput | KeyManagementOrderByWithAggregationInput[]
    by: KeyManagementScalarFieldEnum[] | KeyManagementScalarFieldEnum
    having?: KeyManagementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeyManagementCountAggregateInputType | true
    _min?: KeyManagementMinAggregateInputType
    _max?: KeyManagementMaxAggregateInputType
  }

  export type KeyManagementGroupByOutputType = {
    id: string
    version: string | null
    dekCipher: Uint8Array | null
    createdAt: Date | null
    rotatedAt: Date | null
    _count: KeyManagementCountAggregateOutputType | null
    _min: KeyManagementMinAggregateOutputType | null
    _max: KeyManagementMaxAggregateOutputType | null
  }

  type GetKeyManagementGroupByPayload<T extends KeyManagementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeyManagementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeyManagementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeyManagementGroupByOutputType[P]>
            : GetScalarType<T[P], KeyManagementGroupByOutputType[P]>
        }
      >
    >


  export type KeyManagementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    dekCipher?: boolean
    createdAt?: boolean
    rotatedAt?: boolean
  }, ExtArgs["result"]["keyManagement"]>

  export type KeyManagementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    dekCipher?: boolean
    createdAt?: boolean
    rotatedAt?: boolean
  }, ExtArgs["result"]["keyManagement"]>

  export type KeyManagementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    dekCipher?: boolean
    createdAt?: boolean
    rotatedAt?: boolean
  }, ExtArgs["result"]["keyManagement"]>

  export type KeyManagementSelectScalar = {
    id?: boolean
    version?: boolean
    dekCipher?: boolean
    createdAt?: boolean
    rotatedAt?: boolean
  }

  export type KeyManagementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "version" | "dekCipher" | "createdAt" | "rotatedAt", ExtArgs["result"]["keyManagement"]>

  export type $KeyManagementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KeyManagement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      version: string | null
      dekCipher: Uint8Array | null
      createdAt: Date | null
      rotatedAt: Date | null
    }, ExtArgs["result"]["keyManagement"]>
    composites: {}
  }

  type KeyManagementGetPayload<S extends boolean | null | undefined | KeyManagementDefaultArgs> = $Result.GetResult<Prisma.$KeyManagementPayload, S>

  type KeyManagementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeyManagementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeyManagementCountAggregateInputType | true
    }

  export interface KeyManagementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KeyManagement'], meta: { name: 'KeyManagement' } }
    /**
     * Find zero or one KeyManagement that matches the filter.
     * @param {KeyManagementFindUniqueArgs} args - Arguments to find a KeyManagement
     * @example
     * // Get one KeyManagement
     * const keyManagement = await prisma.keyManagement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeyManagementFindUniqueArgs>(args: SelectSubset<T, KeyManagementFindUniqueArgs<ExtArgs>>): Prisma__KeyManagementClient<$Result.GetResult<Prisma.$KeyManagementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KeyManagement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeyManagementFindUniqueOrThrowArgs} args - Arguments to find a KeyManagement
     * @example
     * // Get one KeyManagement
     * const keyManagement = await prisma.keyManagement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeyManagementFindUniqueOrThrowArgs>(args: SelectSubset<T, KeyManagementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeyManagementClient<$Result.GetResult<Prisma.$KeyManagementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeyManagement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyManagementFindFirstArgs} args - Arguments to find a KeyManagement
     * @example
     * // Get one KeyManagement
     * const keyManagement = await prisma.keyManagement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeyManagementFindFirstArgs>(args?: SelectSubset<T, KeyManagementFindFirstArgs<ExtArgs>>): Prisma__KeyManagementClient<$Result.GetResult<Prisma.$KeyManagementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeyManagement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyManagementFindFirstOrThrowArgs} args - Arguments to find a KeyManagement
     * @example
     * // Get one KeyManagement
     * const keyManagement = await prisma.keyManagement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeyManagementFindFirstOrThrowArgs>(args?: SelectSubset<T, KeyManagementFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeyManagementClient<$Result.GetResult<Prisma.$KeyManagementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KeyManagements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyManagementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KeyManagements
     * const keyManagements = await prisma.keyManagement.findMany()
     * 
     * // Get first 10 KeyManagements
     * const keyManagements = await prisma.keyManagement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keyManagementWithIdOnly = await prisma.keyManagement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeyManagementFindManyArgs>(args?: SelectSubset<T, KeyManagementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyManagementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KeyManagement.
     * @param {KeyManagementCreateArgs} args - Arguments to create a KeyManagement.
     * @example
     * // Create one KeyManagement
     * const KeyManagement = await prisma.keyManagement.create({
     *   data: {
     *     // ... data to create a KeyManagement
     *   }
     * })
     * 
     */
    create<T extends KeyManagementCreateArgs>(args: SelectSubset<T, KeyManagementCreateArgs<ExtArgs>>): Prisma__KeyManagementClient<$Result.GetResult<Prisma.$KeyManagementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KeyManagements.
     * @param {KeyManagementCreateManyArgs} args - Arguments to create many KeyManagements.
     * @example
     * // Create many KeyManagements
     * const keyManagement = await prisma.keyManagement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeyManagementCreateManyArgs>(args?: SelectSubset<T, KeyManagementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KeyManagements and returns the data saved in the database.
     * @param {KeyManagementCreateManyAndReturnArgs} args - Arguments to create many KeyManagements.
     * @example
     * // Create many KeyManagements
     * const keyManagement = await prisma.keyManagement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KeyManagements and only return the `id`
     * const keyManagementWithIdOnly = await prisma.keyManagement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KeyManagementCreateManyAndReturnArgs>(args?: SelectSubset<T, KeyManagementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyManagementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KeyManagement.
     * @param {KeyManagementDeleteArgs} args - Arguments to delete one KeyManagement.
     * @example
     * // Delete one KeyManagement
     * const KeyManagement = await prisma.keyManagement.delete({
     *   where: {
     *     // ... filter to delete one KeyManagement
     *   }
     * })
     * 
     */
    delete<T extends KeyManagementDeleteArgs>(args: SelectSubset<T, KeyManagementDeleteArgs<ExtArgs>>): Prisma__KeyManagementClient<$Result.GetResult<Prisma.$KeyManagementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KeyManagement.
     * @param {KeyManagementUpdateArgs} args - Arguments to update one KeyManagement.
     * @example
     * // Update one KeyManagement
     * const keyManagement = await prisma.keyManagement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeyManagementUpdateArgs>(args: SelectSubset<T, KeyManagementUpdateArgs<ExtArgs>>): Prisma__KeyManagementClient<$Result.GetResult<Prisma.$KeyManagementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KeyManagements.
     * @param {KeyManagementDeleteManyArgs} args - Arguments to filter KeyManagements to delete.
     * @example
     * // Delete a few KeyManagements
     * const { count } = await prisma.keyManagement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeyManagementDeleteManyArgs>(args?: SelectSubset<T, KeyManagementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeyManagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyManagementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KeyManagements
     * const keyManagement = await prisma.keyManagement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeyManagementUpdateManyArgs>(args: SelectSubset<T, KeyManagementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeyManagements and returns the data updated in the database.
     * @param {KeyManagementUpdateManyAndReturnArgs} args - Arguments to update many KeyManagements.
     * @example
     * // Update many KeyManagements
     * const keyManagement = await prisma.keyManagement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KeyManagements and only return the `id`
     * const keyManagementWithIdOnly = await prisma.keyManagement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KeyManagementUpdateManyAndReturnArgs>(args: SelectSubset<T, KeyManagementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyManagementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KeyManagement.
     * @param {KeyManagementUpsertArgs} args - Arguments to update or create a KeyManagement.
     * @example
     * // Update or create a KeyManagement
     * const keyManagement = await prisma.keyManagement.upsert({
     *   create: {
     *     // ... data to create a KeyManagement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KeyManagement we want to update
     *   }
     * })
     */
    upsert<T extends KeyManagementUpsertArgs>(args: SelectSubset<T, KeyManagementUpsertArgs<ExtArgs>>): Prisma__KeyManagementClient<$Result.GetResult<Prisma.$KeyManagementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KeyManagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyManagementCountArgs} args - Arguments to filter KeyManagements to count.
     * @example
     * // Count the number of KeyManagements
     * const count = await prisma.keyManagement.count({
     *   where: {
     *     // ... the filter for the KeyManagements we want to count
     *   }
     * })
    **/
    count<T extends KeyManagementCountArgs>(
      args?: Subset<T, KeyManagementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeyManagementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KeyManagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyManagementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeyManagementAggregateArgs>(args: Subset<T, KeyManagementAggregateArgs>): Prisma.PrismaPromise<GetKeyManagementAggregateType<T>>

    /**
     * Group by KeyManagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyManagementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeyManagementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeyManagementGroupByArgs['orderBy'] }
        : { orderBy?: KeyManagementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeyManagementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeyManagementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KeyManagement model
   */
  readonly fields: KeyManagementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KeyManagement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeyManagementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KeyManagement model
   */
  interface KeyManagementFieldRefs {
    readonly id: FieldRef<"KeyManagement", 'String'>
    readonly version: FieldRef<"KeyManagement", 'String'>
    readonly dekCipher: FieldRef<"KeyManagement", 'Bytes'>
    readonly createdAt: FieldRef<"KeyManagement", 'DateTime'>
    readonly rotatedAt: FieldRef<"KeyManagement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KeyManagement findUnique
   */
  export type KeyManagementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyManagement
     */
    select?: KeyManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyManagement
     */
    omit?: KeyManagementOmit<ExtArgs> | null
    /**
     * Filter, which KeyManagement to fetch.
     */
    where: KeyManagementWhereUniqueInput
  }

  /**
   * KeyManagement findUniqueOrThrow
   */
  export type KeyManagementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyManagement
     */
    select?: KeyManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyManagement
     */
    omit?: KeyManagementOmit<ExtArgs> | null
    /**
     * Filter, which KeyManagement to fetch.
     */
    where: KeyManagementWhereUniqueInput
  }

  /**
   * KeyManagement findFirst
   */
  export type KeyManagementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyManagement
     */
    select?: KeyManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyManagement
     */
    omit?: KeyManagementOmit<ExtArgs> | null
    /**
     * Filter, which KeyManagement to fetch.
     */
    where?: KeyManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyManagements to fetch.
     */
    orderBy?: KeyManagementOrderByWithRelationInput | KeyManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeyManagements.
     */
    cursor?: KeyManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeyManagements.
     */
    distinct?: KeyManagementScalarFieldEnum | KeyManagementScalarFieldEnum[]
  }

  /**
   * KeyManagement findFirstOrThrow
   */
  export type KeyManagementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyManagement
     */
    select?: KeyManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyManagement
     */
    omit?: KeyManagementOmit<ExtArgs> | null
    /**
     * Filter, which KeyManagement to fetch.
     */
    where?: KeyManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyManagements to fetch.
     */
    orderBy?: KeyManagementOrderByWithRelationInput | KeyManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeyManagements.
     */
    cursor?: KeyManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeyManagements.
     */
    distinct?: KeyManagementScalarFieldEnum | KeyManagementScalarFieldEnum[]
  }

  /**
   * KeyManagement findMany
   */
  export type KeyManagementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyManagement
     */
    select?: KeyManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyManagement
     */
    omit?: KeyManagementOmit<ExtArgs> | null
    /**
     * Filter, which KeyManagements to fetch.
     */
    where?: KeyManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyManagements to fetch.
     */
    orderBy?: KeyManagementOrderByWithRelationInput | KeyManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KeyManagements.
     */
    cursor?: KeyManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyManagements.
     */
    skip?: number
    distinct?: KeyManagementScalarFieldEnum | KeyManagementScalarFieldEnum[]
  }

  /**
   * KeyManagement create
   */
  export type KeyManagementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyManagement
     */
    select?: KeyManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyManagement
     */
    omit?: KeyManagementOmit<ExtArgs> | null
    /**
     * The data needed to create a KeyManagement.
     */
    data?: XOR<KeyManagementCreateInput, KeyManagementUncheckedCreateInput>
  }

  /**
   * KeyManagement createMany
   */
  export type KeyManagementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KeyManagements.
     */
    data: KeyManagementCreateManyInput | KeyManagementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KeyManagement createManyAndReturn
   */
  export type KeyManagementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyManagement
     */
    select?: KeyManagementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KeyManagement
     */
    omit?: KeyManagementOmit<ExtArgs> | null
    /**
     * The data used to create many KeyManagements.
     */
    data: KeyManagementCreateManyInput | KeyManagementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KeyManagement update
   */
  export type KeyManagementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyManagement
     */
    select?: KeyManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyManagement
     */
    omit?: KeyManagementOmit<ExtArgs> | null
    /**
     * The data needed to update a KeyManagement.
     */
    data: XOR<KeyManagementUpdateInput, KeyManagementUncheckedUpdateInput>
    /**
     * Choose, which KeyManagement to update.
     */
    where: KeyManagementWhereUniqueInput
  }

  /**
   * KeyManagement updateMany
   */
  export type KeyManagementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KeyManagements.
     */
    data: XOR<KeyManagementUpdateManyMutationInput, KeyManagementUncheckedUpdateManyInput>
    /**
     * Filter which KeyManagements to update
     */
    where?: KeyManagementWhereInput
    /**
     * Limit how many KeyManagements to update.
     */
    limit?: number
  }

  /**
   * KeyManagement updateManyAndReturn
   */
  export type KeyManagementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyManagement
     */
    select?: KeyManagementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KeyManagement
     */
    omit?: KeyManagementOmit<ExtArgs> | null
    /**
     * The data used to update KeyManagements.
     */
    data: XOR<KeyManagementUpdateManyMutationInput, KeyManagementUncheckedUpdateManyInput>
    /**
     * Filter which KeyManagements to update
     */
    where?: KeyManagementWhereInput
    /**
     * Limit how many KeyManagements to update.
     */
    limit?: number
  }

  /**
   * KeyManagement upsert
   */
  export type KeyManagementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyManagement
     */
    select?: KeyManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyManagement
     */
    omit?: KeyManagementOmit<ExtArgs> | null
    /**
     * The filter to search for the KeyManagement to update in case it exists.
     */
    where: KeyManagementWhereUniqueInput
    /**
     * In case the KeyManagement found by the `where` argument doesn't exist, create a new KeyManagement with this data.
     */
    create: XOR<KeyManagementCreateInput, KeyManagementUncheckedCreateInput>
    /**
     * In case the KeyManagement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeyManagementUpdateInput, KeyManagementUncheckedUpdateInput>
  }

  /**
   * KeyManagement delete
   */
  export type KeyManagementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyManagement
     */
    select?: KeyManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyManagement
     */
    omit?: KeyManagementOmit<ExtArgs> | null
    /**
     * Filter which KeyManagement to delete.
     */
    where: KeyManagementWhereUniqueInput
  }

  /**
   * KeyManagement deleteMany
   */
  export type KeyManagementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeyManagements to delete
     */
    where?: KeyManagementWhereInput
    /**
     * Limit how many KeyManagements to delete.
     */
    limit?: number
  }

  /**
   * KeyManagement without action
   */
  export type KeyManagementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyManagement
     */
    select?: KeyManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyManagement
     */
    omit?: KeyManagementOmit<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    table: string | null
    rowId: string | null
    action: string | null
    adminId: string | null
    doctorId: string | null
    clinicId: string | null
    ip: string | null
    userAgent: string | null
    occurredAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    table: string | null
    rowId: string | null
    action: string | null
    adminId: string | null
    doctorId: string | null
    clinicId: string | null
    ip: string | null
    userAgent: string | null
    occurredAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    table: number
    rowId: number
    action: number
    oldValues: number
    newValues: number
    adminId: number
    doctorId: number
    clinicId: number
    ip: number
    userAgent: number
    occurredAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    table?: true
    rowId?: true
    action?: true
    adminId?: true
    doctorId?: true
    clinicId?: true
    ip?: true
    userAgent?: true
    occurredAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    table?: true
    rowId?: true
    action?: true
    adminId?: true
    doctorId?: true
    clinicId?: true
    ip?: true
    userAgent?: true
    occurredAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    table?: true
    rowId?: true
    action?: true
    oldValues?: true
    newValues?: true
    adminId?: true
    doctorId?: true
    clinicId?: true
    ip?: true
    userAgent?: true
    occurredAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    table: string | null
    rowId: string | null
    action: string | null
    oldValues: JsonValue | null
    newValues: JsonValue | null
    adminId: string | null
    doctorId: string | null
    clinicId: string | null
    ip: string | null
    userAgent: string | null
    occurredAt: Date | null
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    table?: boolean
    rowId?: boolean
    action?: boolean
    oldValues?: boolean
    newValues?: boolean
    adminId?: boolean
    doctorId?: boolean
    clinicId?: boolean
    ip?: boolean
    userAgent?: boolean
    occurredAt?: boolean
    clinic?: boolean | AuditLog$clinicArgs<ExtArgs>
    admin?: boolean | AuditLog$adminArgs<ExtArgs>
    doctor?: boolean | AuditLog$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    table?: boolean
    rowId?: boolean
    action?: boolean
    oldValues?: boolean
    newValues?: boolean
    adminId?: boolean
    doctorId?: boolean
    clinicId?: boolean
    ip?: boolean
    userAgent?: boolean
    occurredAt?: boolean
    clinic?: boolean | AuditLog$clinicArgs<ExtArgs>
    admin?: boolean | AuditLog$adminArgs<ExtArgs>
    doctor?: boolean | AuditLog$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    table?: boolean
    rowId?: boolean
    action?: boolean
    oldValues?: boolean
    newValues?: boolean
    adminId?: boolean
    doctorId?: boolean
    clinicId?: boolean
    ip?: boolean
    userAgent?: boolean
    occurredAt?: boolean
    clinic?: boolean | AuditLog$clinicArgs<ExtArgs>
    admin?: boolean | AuditLog$adminArgs<ExtArgs>
    doctor?: boolean | AuditLog$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    table?: boolean
    rowId?: boolean
    action?: boolean
    oldValues?: boolean
    newValues?: boolean
    adminId?: boolean
    doctorId?: boolean
    clinicId?: boolean
    ip?: boolean
    userAgent?: boolean
    occurredAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "table" | "rowId" | "action" | "oldValues" | "newValues" | "adminId" | "doctorId" | "clinicId" | "ip" | "userAgent" | "occurredAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | AuditLog$clinicArgs<ExtArgs>
    admin?: boolean | AuditLog$adminArgs<ExtArgs>
    doctor?: boolean | AuditLog$doctorArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | AuditLog$clinicArgs<ExtArgs>
    admin?: boolean | AuditLog$adminArgs<ExtArgs>
    doctor?: boolean | AuditLog$doctorArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | AuditLog$clinicArgs<ExtArgs>
    admin?: boolean | AuditLog$adminArgs<ExtArgs>
    doctor?: boolean | AuditLog$doctorArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
      doctor: Prisma.$DoctorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      table: string | null
      rowId: string | null
      action: string | null
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      adminId: string | null
      doctorId: string | null
      clinicId: string | null
      ip: string | null
      userAgent: string | null
      occurredAt: Date | null
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends AuditLog$clinicArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin<T extends AuditLog$adminArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    doctor<T extends AuditLog$doctorArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$doctorArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly table: FieldRef<"AuditLog", 'String'>
    readonly rowId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly oldValues: FieldRef<"AuditLog", 'Json'>
    readonly newValues: FieldRef<"AuditLog", 'Json'>
    readonly adminId: FieldRef<"AuditLog", 'String'>
    readonly doctorId: FieldRef<"AuditLog", 'String'>
    readonly clinicId: FieldRef<"AuditLog", 'String'>
    readonly ip: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly occurredAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data?: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.clinic
   */
  export type AuditLog$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * AuditLog.admin
   */
  export type AuditLog$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * AuditLog.doctor
   */
  export type AuditLog$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model DataRequest
   */

  export type AggregateDataRequest = {
    _count: DataRequestCountAggregateOutputType | null
    _min: DataRequestMinAggregateOutputType | null
    _max: DataRequestMaxAggregateOutputType | null
  }

  export type DataRequestMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    type: $Enums.DataRequestType | null
    status: $Enums.DataRequestStatus | null
    requestReason: string | null
    requestedAt: Date | null
    completedAt: Date | null
    downloadUrl: string | null
    downloadExpiresAt: Date | null
  }

  export type DataRequestMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    type: $Enums.DataRequestType | null
    status: $Enums.DataRequestStatus | null
    requestReason: string | null
    requestedAt: Date | null
    completedAt: Date | null
    downloadUrl: string | null
    downloadExpiresAt: Date | null
  }

  export type DataRequestCountAggregateOutputType = {
    id: number
    clinicId: number
    patientId: number
    type: number
    status: number
    requestReason: number
    requestedAt: number
    completedAt: number
    downloadUrl: number
    downloadExpiresAt: number
    _all: number
  }


  export type DataRequestMinAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    type?: true
    status?: true
    requestReason?: true
    requestedAt?: true
    completedAt?: true
    downloadUrl?: true
    downloadExpiresAt?: true
  }

  export type DataRequestMaxAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    type?: true
    status?: true
    requestReason?: true
    requestedAt?: true
    completedAt?: true
    downloadUrl?: true
    downloadExpiresAt?: true
  }

  export type DataRequestCountAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    type?: true
    status?: true
    requestReason?: true
    requestedAt?: true
    completedAt?: true
    downloadUrl?: true
    downloadExpiresAt?: true
    _all?: true
  }

  export type DataRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRequest to aggregate.
     */
    where?: DataRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRequests to fetch.
     */
    orderBy?: DataRequestOrderByWithRelationInput | DataRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataRequests
    **/
    _count?: true | DataRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataRequestMaxAggregateInputType
  }

  export type GetDataRequestAggregateType<T extends DataRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateDataRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataRequest[P]>
      : GetScalarType<T[P], AggregateDataRequest[P]>
  }




  export type DataRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataRequestWhereInput
    orderBy?: DataRequestOrderByWithAggregationInput | DataRequestOrderByWithAggregationInput[]
    by: DataRequestScalarFieldEnum[] | DataRequestScalarFieldEnum
    having?: DataRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataRequestCountAggregateInputType | true
    _min?: DataRequestMinAggregateInputType
    _max?: DataRequestMaxAggregateInputType
  }

  export type DataRequestGroupByOutputType = {
    id: string
    clinicId: string | null
    patientId: string | null
    type: $Enums.DataRequestType | null
    status: $Enums.DataRequestStatus | null
    requestReason: string | null
    requestedAt: Date | null
    completedAt: Date | null
    downloadUrl: string | null
    downloadExpiresAt: Date | null
    _count: DataRequestCountAggregateOutputType | null
    _min: DataRequestMinAggregateOutputType | null
    _max: DataRequestMaxAggregateOutputType | null
  }

  type GetDataRequestGroupByPayload<T extends DataRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataRequestGroupByOutputType[P]>
            : GetScalarType<T[P], DataRequestGroupByOutputType[P]>
        }
      >
    >


  export type DataRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    type?: boolean
    status?: boolean
    requestReason?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    downloadUrl?: boolean
    downloadExpiresAt?: boolean
    clinic?: boolean | DataRequest$clinicArgs<ExtArgs>
    patient?: boolean | DataRequest$patientArgs<ExtArgs>
  }, ExtArgs["result"]["dataRequest"]>

  export type DataRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    type?: boolean
    status?: boolean
    requestReason?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    downloadUrl?: boolean
    downloadExpiresAt?: boolean
    clinic?: boolean | DataRequest$clinicArgs<ExtArgs>
    patient?: boolean | DataRequest$patientArgs<ExtArgs>
  }, ExtArgs["result"]["dataRequest"]>

  export type DataRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    type?: boolean
    status?: boolean
    requestReason?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    downloadUrl?: boolean
    downloadExpiresAt?: boolean
    clinic?: boolean | DataRequest$clinicArgs<ExtArgs>
    patient?: boolean | DataRequest$patientArgs<ExtArgs>
  }, ExtArgs["result"]["dataRequest"]>

  export type DataRequestSelectScalar = {
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    type?: boolean
    status?: boolean
    requestReason?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    downloadUrl?: boolean
    downloadExpiresAt?: boolean
  }

  export type DataRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "patientId" | "type" | "status" | "requestReason" | "requestedAt" | "completedAt" | "downloadUrl" | "downloadExpiresAt", ExtArgs["result"]["dataRequest"]>
  export type DataRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | DataRequest$clinicArgs<ExtArgs>
    patient?: boolean | DataRequest$patientArgs<ExtArgs>
  }
  export type DataRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | DataRequest$clinicArgs<ExtArgs>
    patient?: boolean | DataRequest$patientArgs<ExtArgs>
  }
  export type DataRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | DataRequest$clinicArgs<ExtArgs>
    patient?: boolean | DataRequest$patientArgs<ExtArgs>
  }

  export type $DataRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataRequest"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string | null
      patientId: string | null
      type: $Enums.DataRequestType | null
      status: $Enums.DataRequestStatus | null
      requestReason: string | null
      requestedAt: Date | null
      completedAt: Date | null
      downloadUrl: string | null
      downloadExpiresAt: Date | null
    }, ExtArgs["result"]["dataRequest"]>
    composites: {}
  }

  type DataRequestGetPayload<S extends boolean | null | undefined | DataRequestDefaultArgs> = $Result.GetResult<Prisma.$DataRequestPayload, S>

  type DataRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataRequestCountAggregateInputType | true
    }

  export interface DataRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataRequest'], meta: { name: 'DataRequest' } }
    /**
     * Find zero or one DataRequest that matches the filter.
     * @param {DataRequestFindUniqueArgs} args - Arguments to find a DataRequest
     * @example
     * // Get one DataRequest
     * const dataRequest = await prisma.dataRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataRequestFindUniqueArgs>(args: SelectSubset<T, DataRequestFindUniqueArgs<ExtArgs>>): Prisma__DataRequestClient<$Result.GetResult<Prisma.$DataRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataRequestFindUniqueOrThrowArgs} args - Arguments to find a DataRequest
     * @example
     * // Get one DataRequest
     * const dataRequest = await prisma.dataRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, DataRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataRequestClient<$Result.GetResult<Prisma.$DataRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRequestFindFirstArgs} args - Arguments to find a DataRequest
     * @example
     * // Get one DataRequest
     * const dataRequest = await prisma.dataRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataRequestFindFirstArgs>(args?: SelectSubset<T, DataRequestFindFirstArgs<ExtArgs>>): Prisma__DataRequestClient<$Result.GetResult<Prisma.$DataRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRequestFindFirstOrThrowArgs} args - Arguments to find a DataRequest
     * @example
     * // Get one DataRequest
     * const dataRequest = await prisma.dataRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, DataRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataRequestClient<$Result.GetResult<Prisma.$DataRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataRequests
     * const dataRequests = await prisma.dataRequest.findMany()
     * 
     * // Get first 10 DataRequests
     * const dataRequests = await prisma.dataRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataRequestWithIdOnly = await prisma.dataRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataRequestFindManyArgs>(args?: SelectSubset<T, DataRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataRequest.
     * @param {DataRequestCreateArgs} args - Arguments to create a DataRequest.
     * @example
     * // Create one DataRequest
     * const DataRequest = await prisma.dataRequest.create({
     *   data: {
     *     // ... data to create a DataRequest
     *   }
     * })
     * 
     */
    create<T extends DataRequestCreateArgs>(args: SelectSubset<T, DataRequestCreateArgs<ExtArgs>>): Prisma__DataRequestClient<$Result.GetResult<Prisma.$DataRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataRequests.
     * @param {DataRequestCreateManyArgs} args - Arguments to create many DataRequests.
     * @example
     * // Create many DataRequests
     * const dataRequest = await prisma.dataRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataRequestCreateManyArgs>(args?: SelectSubset<T, DataRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataRequests and returns the data saved in the database.
     * @param {DataRequestCreateManyAndReturnArgs} args - Arguments to create many DataRequests.
     * @example
     * // Create many DataRequests
     * const dataRequest = await prisma.dataRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataRequests and only return the `id`
     * const dataRequestWithIdOnly = await prisma.dataRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, DataRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DataRequest.
     * @param {DataRequestDeleteArgs} args - Arguments to delete one DataRequest.
     * @example
     * // Delete one DataRequest
     * const DataRequest = await prisma.dataRequest.delete({
     *   where: {
     *     // ... filter to delete one DataRequest
     *   }
     * })
     * 
     */
    delete<T extends DataRequestDeleteArgs>(args: SelectSubset<T, DataRequestDeleteArgs<ExtArgs>>): Prisma__DataRequestClient<$Result.GetResult<Prisma.$DataRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataRequest.
     * @param {DataRequestUpdateArgs} args - Arguments to update one DataRequest.
     * @example
     * // Update one DataRequest
     * const dataRequest = await prisma.dataRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataRequestUpdateArgs>(args: SelectSubset<T, DataRequestUpdateArgs<ExtArgs>>): Prisma__DataRequestClient<$Result.GetResult<Prisma.$DataRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataRequests.
     * @param {DataRequestDeleteManyArgs} args - Arguments to filter DataRequests to delete.
     * @example
     * // Delete a few DataRequests
     * const { count } = await prisma.dataRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataRequestDeleteManyArgs>(args?: SelectSubset<T, DataRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataRequests
     * const dataRequest = await prisma.dataRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataRequestUpdateManyArgs>(args: SelectSubset<T, DataRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataRequests and returns the data updated in the database.
     * @param {DataRequestUpdateManyAndReturnArgs} args - Arguments to update many DataRequests.
     * @example
     * // Update many DataRequests
     * const dataRequest = await prisma.dataRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DataRequests and only return the `id`
     * const dataRequestWithIdOnly = await prisma.dataRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DataRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, DataRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DataRequest.
     * @param {DataRequestUpsertArgs} args - Arguments to update or create a DataRequest.
     * @example
     * // Update or create a DataRequest
     * const dataRequest = await prisma.dataRequest.upsert({
     *   create: {
     *     // ... data to create a DataRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataRequest we want to update
     *   }
     * })
     */
    upsert<T extends DataRequestUpsertArgs>(args: SelectSubset<T, DataRequestUpsertArgs<ExtArgs>>): Prisma__DataRequestClient<$Result.GetResult<Prisma.$DataRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DataRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRequestCountArgs} args - Arguments to filter DataRequests to count.
     * @example
     * // Count the number of DataRequests
     * const count = await prisma.dataRequest.count({
     *   where: {
     *     // ... the filter for the DataRequests we want to count
     *   }
     * })
    **/
    count<T extends DataRequestCountArgs>(
      args?: Subset<T, DataRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataRequestAggregateArgs>(args: Subset<T, DataRequestAggregateArgs>): Prisma.PrismaPromise<GetDataRequestAggregateType<T>>

    /**
     * Group by DataRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataRequestGroupByArgs['orderBy'] }
        : { orderBy?: DataRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataRequest model
   */
  readonly fields: DataRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends DataRequest$clinicArgs<ExtArgs> = {}>(args?: Subset<T, DataRequest$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends DataRequest$patientArgs<ExtArgs> = {}>(args?: Subset<T, DataRequest$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataRequest model
   */
  interface DataRequestFieldRefs {
    readonly id: FieldRef<"DataRequest", 'String'>
    readonly clinicId: FieldRef<"DataRequest", 'String'>
    readonly patientId: FieldRef<"DataRequest", 'String'>
    readonly type: FieldRef<"DataRequest", 'DataRequestType'>
    readonly status: FieldRef<"DataRequest", 'DataRequestStatus'>
    readonly requestReason: FieldRef<"DataRequest", 'String'>
    readonly requestedAt: FieldRef<"DataRequest", 'DateTime'>
    readonly completedAt: FieldRef<"DataRequest", 'DateTime'>
    readonly downloadUrl: FieldRef<"DataRequest", 'String'>
    readonly downloadExpiresAt: FieldRef<"DataRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataRequest findUnique
   */
  export type DataRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRequest
     */
    select?: DataRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRequest
     */
    omit?: DataRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataRequest to fetch.
     */
    where: DataRequestWhereUniqueInput
  }

  /**
   * DataRequest findUniqueOrThrow
   */
  export type DataRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRequest
     */
    select?: DataRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRequest
     */
    omit?: DataRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataRequest to fetch.
     */
    where: DataRequestWhereUniqueInput
  }

  /**
   * DataRequest findFirst
   */
  export type DataRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRequest
     */
    select?: DataRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRequest
     */
    omit?: DataRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataRequest to fetch.
     */
    where?: DataRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRequests to fetch.
     */
    orderBy?: DataRequestOrderByWithRelationInput | DataRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRequests.
     */
    cursor?: DataRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRequests.
     */
    distinct?: DataRequestScalarFieldEnum | DataRequestScalarFieldEnum[]
  }

  /**
   * DataRequest findFirstOrThrow
   */
  export type DataRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRequest
     */
    select?: DataRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRequest
     */
    omit?: DataRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataRequest to fetch.
     */
    where?: DataRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRequests to fetch.
     */
    orderBy?: DataRequestOrderByWithRelationInput | DataRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRequests.
     */
    cursor?: DataRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRequests.
     */
    distinct?: DataRequestScalarFieldEnum | DataRequestScalarFieldEnum[]
  }

  /**
   * DataRequest findMany
   */
  export type DataRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRequest
     */
    select?: DataRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRequest
     */
    omit?: DataRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataRequests to fetch.
     */
    where?: DataRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRequests to fetch.
     */
    orderBy?: DataRequestOrderByWithRelationInput | DataRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataRequests.
     */
    cursor?: DataRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRequests.
     */
    skip?: number
    distinct?: DataRequestScalarFieldEnum | DataRequestScalarFieldEnum[]
  }

  /**
   * DataRequest create
   */
  export type DataRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRequest
     */
    select?: DataRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRequest
     */
    omit?: DataRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a DataRequest.
     */
    data?: XOR<DataRequestCreateInput, DataRequestUncheckedCreateInput>
  }

  /**
   * DataRequest createMany
   */
  export type DataRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataRequests.
     */
    data: DataRequestCreateManyInput | DataRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataRequest createManyAndReturn
   */
  export type DataRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRequest
     */
    select?: DataRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataRequest
     */
    omit?: DataRequestOmit<ExtArgs> | null
    /**
     * The data used to create many DataRequests.
     */
    data: DataRequestCreateManyInput | DataRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataRequest update
   */
  export type DataRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRequest
     */
    select?: DataRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRequest
     */
    omit?: DataRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a DataRequest.
     */
    data: XOR<DataRequestUpdateInput, DataRequestUncheckedUpdateInput>
    /**
     * Choose, which DataRequest to update.
     */
    where: DataRequestWhereUniqueInput
  }

  /**
   * DataRequest updateMany
   */
  export type DataRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataRequests.
     */
    data: XOR<DataRequestUpdateManyMutationInput, DataRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataRequests to update
     */
    where?: DataRequestWhereInput
    /**
     * Limit how many DataRequests to update.
     */
    limit?: number
  }

  /**
   * DataRequest updateManyAndReturn
   */
  export type DataRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRequest
     */
    select?: DataRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataRequest
     */
    omit?: DataRequestOmit<ExtArgs> | null
    /**
     * The data used to update DataRequests.
     */
    data: XOR<DataRequestUpdateManyMutationInput, DataRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataRequests to update
     */
    where?: DataRequestWhereInput
    /**
     * Limit how many DataRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataRequest upsert
   */
  export type DataRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRequest
     */
    select?: DataRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRequest
     */
    omit?: DataRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the DataRequest to update in case it exists.
     */
    where: DataRequestWhereUniqueInput
    /**
     * In case the DataRequest found by the `where` argument doesn't exist, create a new DataRequest with this data.
     */
    create: XOR<DataRequestCreateInput, DataRequestUncheckedCreateInput>
    /**
     * In case the DataRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataRequestUpdateInput, DataRequestUncheckedUpdateInput>
  }

  /**
   * DataRequest delete
   */
  export type DataRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRequest
     */
    select?: DataRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRequest
     */
    omit?: DataRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRequestInclude<ExtArgs> | null
    /**
     * Filter which DataRequest to delete.
     */
    where: DataRequestWhereUniqueInput
  }

  /**
   * DataRequest deleteMany
   */
  export type DataRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRequests to delete
     */
    where?: DataRequestWhereInput
    /**
     * Limit how many DataRequests to delete.
     */
    limit?: number
  }

  /**
   * DataRequest.clinic
   */
  export type DataRequest$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * DataRequest.patient
   */
  export type DataRequest$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * DataRequest without action
   */
  export type DataRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRequest
     */
    select?: DataRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRequest
     */
    omit?: DataRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRequestInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    doctorId: string | null
    startAt: Date | null
    endAt: Date | null
    status: $Enums.AppointmentStatus | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    doctorId: string | null
    startAt: Date | null
    endAt: Date | null
    status: $Enums.AppointmentStatus | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    clinicId: number
    patientId: number
    doctorId: number
    startAt: number
    endAt: number
    status: number
    note: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type AppointmentMinAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    startAt?: true
    endAt?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    startAt?: true
    endAt?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    startAt?: true
    endAt?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    clinicId: string | null
    patientId: string | null
    doctorId: string | null
    startAt: Date | null
    endAt: Date | null
    status: $Enums.AppointmentStatus | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Appointment$clinicArgs<ExtArgs>
    patient?: boolean | Appointment$patientArgs<ExtArgs>
    doctor?: boolean | Appointment$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Appointment$clinicArgs<ExtArgs>
    patient?: boolean | Appointment$patientArgs<ExtArgs>
    doctor?: boolean | Appointment$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Appointment$clinicArgs<ExtArgs>
    patient?: boolean | Appointment$patientArgs<ExtArgs>
    doctor?: boolean | Appointment$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "patientId" | "doctorId" | "startAt" | "endAt" | "status" | "note" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Appointment$clinicArgs<ExtArgs>
    patient?: boolean | Appointment$patientArgs<ExtArgs>
    doctor?: boolean | Appointment$doctorArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Appointment$clinicArgs<ExtArgs>
    patient?: boolean | Appointment$patientArgs<ExtArgs>
    doctor?: boolean | Appointment$doctorArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Appointment$clinicArgs<ExtArgs>
    patient?: boolean | Appointment$patientArgs<ExtArgs>
    doctor?: boolean | Appointment$doctorArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs> | null
      doctor: Prisma.$DoctorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string | null
      patientId: string | null
      doctorId: string | null
      startAt: Date | null
      endAt: Date | null
      status: $Enums.AppointmentStatus | null
      note: string | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends Appointment$clinicArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends Appointment$patientArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    doctor<T extends Appointment$doctorArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$doctorArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly clinicId: FieldRef<"Appointment", 'String'>
    readonly patientId: FieldRef<"Appointment", 'String'>
    readonly doctorId: FieldRef<"Appointment", 'String'>
    readonly startAt: FieldRef<"Appointment", 'DateTime'>
    readonly endAt: FieldRef<"Appointment", 'DateTime'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly note: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
    readonly deletedAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data?: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.clinic
   */
  export type Appointment$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * Appointment.patient
   */
  export type Appointment$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * Appointment.doctor
   */
  export type Appointment$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Call
   */

  export type AggregateCall = {
    _count: CallCountAggregateOutputType | null
    _avg: CallAvgAggregateOutputType | null
    _sum: CallSumAggregateOutputType | null
    _min: CallMinAggregateOutputType | null
    _max: CallMaxAggregateOutputType | null
  }

  export type CallAvgAggregateOutputType = {
    durationSeconds: number | null
    minutesUsed: number | null
  }

  export type CallSumAggregateOutputType = {
    durationSeconds: number | null
    minutesUsed: number | null
  }

  export type CallMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    doctorId: string | null
    startAt: Date | null
    endAt: Date | null
    durationSeconds: number | null
    status: $Enums.CallStatus | null
    recordingUrlCipher: string | null
    transcript: string | null
    aiSummary: string | null
    sentiment: $Enums.Sentiment | null
    escalated: boolean | null
    minutesUsed: number | null
    createdAt: Date | null
    updatedAt: Date | null
    aiModelId: string | null
    aiDecision: string | null
  }

  export type CallMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    doctorId: string | null
    startAt: Date | null
    endAt: Date | null
    durationSeconds: number | null
    status: $Enums.CallStatus | null
    recordingUrlCipher: string | null
    transcript: string | null
    aiSummary: string | null
    sentiment: $Enums.Sentiment | null
    escalated: boolean | null
    minutesUsed: number | null
    createdAt: Date | null
    updatedAt: Date | null
    aiModelId: string | null
    aiDecision: string | null
  }

  export type CallCountAggregateOutputType = {
    id: number
    clinicId: number
    patientId: number
    doctorId: number
    startAt: number
    endAt: number
    durationSeconds: number
    status: number
    recordingUrlCipher: number
    transcript: number
    aiSummary: number
    sentiment: number
    escalated: number
    minutesUsed: number
    createdAt: number
    updatedAt: number
    aiModelId: number
    aiDecision: number
    _all: number
  }


  export type CallAvgAggregateInputType = {
    durationSeconds?: true
    minutesUsed?: true
  }

  export type CallSumAggregateInputType = {
    durationSeconds?: true
    minutesUsed?: true
  }

  export type CallMinAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    startAt?: true
    endAt?: true
    durationSeconds?: true
    status?: true
    recordingUrlCipher?: true
    transcript?: true
    aiSummary?: true
    sentiment?: true
    escalated?: true
    minutesUsed?: true
    createdAt?: true
    updatedAt?: true
    aiModelId?: true
    aiDecision?: true
  }

  export type CallMaxAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    startAt?: true
    endAt?: true
    durationSeconds?: true
    status?: true
    recordingUrlCipher?: true
    transcript?: true
    aiSummary?: true
    sentiment?: true
    escalated?: true
    minutesUsed?: true
    createdAt?: true
    updatedAt?: true
    aiModelId?: true
    aiDecision?: true
  }

  export type CallCountAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    startAt?: true
    endAt?: true
    durationSeconds?: true
    status?: true
    recordingUrlCipher?: true
    transcript?: true
    aiSummary?: true
    sentiment?: true
    escalated?: true
    minutesUsed?: true
    createdAt?: true
    updatedAt?: true
    aiModelId?: true
    aiDecision?: true
    _all?: true
  }

  export type CallAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Call to aggregate.
     */
    where?: CallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calls to fetch.
     */
    orderBy?: CallOrderByWithRelationInput | CallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Calls
    **/
    _count?: true | CallCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CallAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CallSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallMaxAggregateInputType
  }

  export type GetCallAggregateType<T extends CallAggregateArgs> = {
        [P in keyof T & keyof AggregateCall]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCall[P]>
      : GetScalarType<T[P], AggregateCall[P]>
  }




  export type CallGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallWhereInput
    orderBy?: CallOrderByWithAggregationInput | CallOrderByWithAggregationInput[]
    by: CallScalarFieldEnum[] | CallScalarFieldEnum
    having?: CallScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallCountAggregateInputType | true
    _avg?: CallAvgAggregateInputType
    _sum?: CallSumAggregateInputType
    _min?: CallMinAggregateInputType
    _max?: CallMaxAggregateInputType
  }

  export type CallGroupByOutputType = {
    id: string
    clinicId: string | null
    patientId: string | null
    doctorId: string | null
    startAt: Date | null
    endAt: Date | null
    durationSeconds: number | null
    status: $Enums.CallStatus | null
    recordingUrlCipher: string | null
    transcript: string | null
    aiSummary: string | null
    sentiment: $Enums.Sentiment | null
    escalated: boolean | null
    minutesUsed: number | null
    createdAt: Date | null
    updatedAt: Date | null
    aiModelId: string | null
    aiDecision: string | null
    _count: CallCountAggregateOutputType | null
    _avg: CallAvgAggregateOutputType | null
    _sum: CallSumAggregateOutputType | null
    _min: CallMinAggregateOutputType | null
    _max: CallMaxAggregateOutputType | null
  }

  type GetCallGroupByPayload<T extends CallGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallGroupByOutputType[P]>
            : GetScalarType<T[P], CallGroupByOutputType[P]>
        }
      >
    >


  export type CallSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    startAt?: boolean
    endAt?: boolean
    durationSeconds?: boolean
    status?: boolean
    recordingUrlCipher?: boolean
    transcript?: boolean
    aiSummary?: boolean
    sentiment?: boolean
    escalated?: boolean
    minutesUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiModelId?: boolean
    aiDecision?: boolean
    clinic?: boolean | Call$clinicArgs<ExtArgs>
    patient?: boolean | Call$patientArgs<ExtArgs>
    doctor?: boolean | Call$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["call"]>

  export type CallSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    startAt?: boolean
    endAt?: boolean
    durationSeconds?: boolean
    status?: boolean
    recordingUrlCipher?: boolean
    transcript?: boolean
    aiSummary?: boolean
    sentiment?: boolean
    escalated?: boolean
    minutesUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiModelId?: boolean
    aiDecision?: boolean
    clinic?: boolean | Call$clinicArgs<ExtArgs>
    patient?: boolean | Call$patientArgs<ExtArgs>
    doctor?: boolean | Call$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["call"]>

  export type CallSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    startAt?: boolean
    endAt?: boolean
    durationSeconds?: boolean
    status?: boolean
    recordingUrlCipher?: boolean
    transcript?: boolean
    aiSummary?: boolean
    sentiment?: boolean
    escalated?: boolean
    minutesUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiModelId?: boolean
    aiDecision?: boolean
    clinic?: boolean | Call$clinicArgs<ExtArgs>
    patient?: boolean | Call$patientArgs<ExtArgs>
    doctor?: boolean | Call$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["call"]>

  export type CallSelectScalar = {
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    startAt?: boolean
    endAt?: boolean
    durationSeconds?: boolean
    status?: boolean
    recordingUrlCipher?: boolean
    transcript?: boolean
    aiSummary?: boolean
    sentiment?: boolean
    escalated?: boolean
    minutesUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiModelId?: boolean
    aiDecision?: boolean
  }

  export type CallOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "patientId" | "doctorId" | "startAt" | "endAt" | "durationSeconds" | "status" | "recordingUrlCipher" | "transcript" | "aiSummary" | "sentiment" | "escalated" | "minutesUsed" | "createdAt" | "updatedAt" | "aiModelId" | "aiDecision", ExtArgs["result"]["call"]>
  export type CallInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Call$clinicArgs<ExtArgs>
    patient?: boolean | Call$patientArgs<ExtArgs>
    doctor?: boolean | Call$doctorArgs<ExtArgs>
  }
  export type CallIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Call$clinicArgs<ExtArgs>
    patient?: boolean | Call$patientArgs<ExtArgs>
    doctor?: boolean | Call$doctorArgs<ExtArgs>
  }
  export type CallIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Call$clinicArgs<ExtArgs>
    patient?: boolean | Call$patientArgs<ExtArgs>
    doctor?: boolean | Call$doctorArgs<ExtArgs>
  }

  export type $CallPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Call"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs> | null
      doctor: Prisma.$DoctorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string | null
      patientId: string | null
      doctorId: string | null
      startAt: Date | null
      endAt: Date | null
      durationSeconds: number | null
      status: $Enums.CallStatus | null
      recordingUrlCipher: string | null
      transcript: string | null
      aiSummary: string | null
      sentiment: $Enums.Sentiment | null
      escalated: boolean | null
      minutesUsed: number | null
      createdAt: Date | null
      updatedAt: Date | null
      aiModelId: string | null
      aiDecision: string | null
    }, ExtArgs["result"]["call"]>
    composites: {}
  }

  type CallGetPayload<S extends boolean | null | undefined | CallDefaultArgs> = $Result.GetResult<Prisma.$CallPayload, S>

  type CallCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CallFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CallCountAggregateInputType | true
    }

  export interface CallDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Call'], meta: { name: 'Call' } }
    /**
     * Find zero or one Call that matches the filter.
     * @param {CallFindUniqueArgs} args - Arguments to find a Call
     * @example
     * // Get one Call
     * const call = await prisma.call.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallFindUniqueArgs>(args: SelectSubset<T, CallFindUniqueArgs<ExtArgs>>): Prisma__CallClient<$Result.GetResult<Prisma.$CallPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Call that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CallFindUniqueOrThrowArgs} args - Arguments to find a Call
     * @example
     * // Get one Call
     * const call = await prisma.call.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallFindUniqueOrThrowArgs>(args: SelectSubset<T, CallFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallClient<$Result.GetResult<Prisma.$CallPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Call that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallFindFirstArgs} args - Arguments to find a Call
     * @example
     * // Get one Call
     * const call = await prisma.call.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallFindFirstArgs>(args?: SelectSubset<T, CallFindFirstArgs<ExtArgs>>): Prisma__CallClient<$Result.GetResult<Prisma.$CallPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Call that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallFindFirstOrThrowArgs} args - Arguments to find a Call
     * @example
     * // Get one Call
     * const call = await prisma.call.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallFindFirstOrThrowArgs>(args?: SelectSubset<T, CallFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallClient<$Result.GetResult<Prisma.$CallPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Calls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calls
     * const calls = await prisma.call.findMany()
     * 
     * // Get first 10 Calls
     * const calls = await prisma.call.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callWithIdOnly = await prisma.call.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallFindManyArgs>(args?: SelectSubset<T, CallFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Call.
     * @param {CallCreateArgs} args - Arguments to create a Call.
     * @example
     * // Create one Call
     * const Call = await prisma.call.create({
     *   data: {
     *     // ... data to create a Call
     *   }
     * })
     * 
     */
    create<T extends CallCreateArgs>(args: SelectSubset<T, CallCreateArgs<ExtArgs>>): Prisma__CallClient<$Result.GetResult<Prisma.$CallPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Calls.
     * @param {CallCreateManyArgs} args - Arguments to create many Calls.
     * @example
     * // Create many Calls
     * const call = await prisma.call.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallCreateManyArgs>(args?: SelectSubset<T, CallCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Calls and returns the data saved in the database.
     * @param {CallCreateManyAndReturnArgs} args - Arguments to create many Calls.
     * @example
     * // Create many Calls
     * const call = await prisma.call.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Calls and only return the `id`
     * const callWithIdOnly = await prisma.call.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallCreateManyAndReturnArgs>(args?: SelectSubset<T, CallCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Call.
     * @param {CallDeleteArgs} args - Arguments to delete one Call.
     * @example
     * // Delete one Call
     * const Call = await prisma.call.delete({
     *   where: {
     *     // ... filter to delete one Call
     *   }
     * })
     * 
     */
    delete<T extends CallDeleteArgs>(args: SelectSubset<T, CallDeleteArgs<ExtArgs>>): Prisma__CallClient<$Result.GetResult<Prisma.$CallPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Call.
     * @param {CallUpdateArgs} args - Arguments to update one Call.
     * @example
     * // Update one Call
     * const call = await prisma.call.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallUpdateArgs>(args: SelectSubset<T, CallUpdateArgs<ExtArgs>>): Prisma__CallClient<$Result.GetResult<Prisma.$CallPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Calls.
     * @param {CallDeleteManyArgs} args - Arguments to filter Calls to delete.
     * @example
     * // Delete a few Calls
     * const { count } = await prisma.call.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallDeleteManyArgs>(args?: SelectSubset<T, CallDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calls
     * const call = await prisma.call.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallUpdateManyArgs>(args: SelectSubset<T, CallUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calls and returns the data updated in the database.
     * @param {CallUpdateManyAndReturnArgs} args - Arguments to update many Calls.
     * @example
     * // Update many Calls
     * const call = await prisma.call.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Calls and only return the `id`
     * const callWithIdOnly = await prisma.call.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CallUpdateManyAndReturnArgs>(args: SelectSubset<T, CallUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Call.
     * @param {CallUpsertArgs} args - Arguments to update or create a Call.
     * @example
     * // Update or create a Call
     * const call = await prisma.call.upsert({
     *   create: {
     *     // ... data to create a Call
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Call we want to update
     *   }
     * })
     */
    upsert<T extends CallUpsertArgs>(args: SelectSubset<T, CallUpsertArgs<ExtArgs>>): Prisma__CallClient<$Result.GetResult<Prisma.$CallPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallCountArgs} args - Arguments to filter Calls to count.
     * @example
     * // Count the number of Calls
     * const count = await prisma.call.count({
     *   where: {
     *     // ... the filter for the Calls we want to count
     *   }
     * })
    **/
    count<T extends CallCountArgs>(
      args?: Subset<T, CallCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Call.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallAggregateArgs>(args: Subset<T, CallAggregateArgs>): Prisma.PrismaPromise<GetCallAggregateType<T>>

    /**
     * Group by Call.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallGroupByArgs['orderBy'] }
        : { orderBy?: CallGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Call model
   */
  readonly fields: CallFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Call.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends Call$clinicArgs<ExtArgs> = {}>(args?: Subset<T, Call$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends Call$patientArgs<ExtArgs> = {}>(args?: Subset<T, Call$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    doctor<T extends Call$doctorArgs<ExtArgs> = {}>(args?: Subset<T, Call$doctorArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Call model
   */
  interface CallFieldRefs {
    readonly id: FieldRef<"Call", 'String'>
    readonly clinicId: FieldRef<"Call", 'String'>
    readonly patientId: FieldRef<"Call", 'String'>
    readonly doctorId: FieldRef<"Call", 'String'>
    readonly startAt: FieldRef<"Call", 'DateTime'>
    readonly endAt: FieldRef<"Call", 'DateTime'>
    readonly durationSeconds: FieldRef<"Call", 'Int'>
    readonly status: FieldRef<"Call", 'CallStatus'>
    readonly recordingUrlCipher: FieldRef<"Call", 'String'>
    readonly transcript: FieldRef<"Call", 'String'>
    readonly aiSummary: FieldRef<"Call", 'String'>
    readonly sentiment: FieldRef<"Call", 'Sentiment'>
    readonly escalated: FieldRef<"Call", 'Boolean'>
    readonly minutesUsed: FieldRef<"Call", 'Int'>
    readonly createdAt: FieldRef<"Call", 'DateTime'>
    readonly updatedAt: FieldRef<"Call", 'DateTime'>
    readonly aiModelId: FieldRef<"Call", 'String'>
    readonly aiDecision: FieldRef<"Call", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Call findUnique
   */
  export type CallFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallInclude<ExtArgs> | null
    /**
     * Filter, which Call to fetch.
     */
    where: CallWhereUniqueInput
  }

  /**
   * Call findUniqueOrThrow
   */
  export type CallFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallInclude<ExtArgs> | null
    /**
     * Filter, which Call to fetch.
     */
    where: CallWhereUniqueInput
  }

  /**
   * Call findFirst
   */
  export type CallFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallInclude<ExtArgs> | null
    /**
     * Filter, which Call to fetch.
     */
    where?: CallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calls to fetch.
     */
    orderBy?: CallOrderByWithRelationInput | CallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calls.
     */
    cursor?: CallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calls.
     */
    distinct?: CallScalarFieldEnum | CallScalarFieldEnum[]
  }

  /**
   * Call findFirstOrThrow
   */
  export type CallFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallInclude<ExtArgs> | null
    /**
     * Filter, which Call to fetch.
     */
    where?: CallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calls to fetch.
     */
    orderBy?: CallOrderByWithRelationInput | CallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calls.
     */
    cursor?: CallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calls.
     */
    distinct?: CallScalarFieldEnum | CallScalarFieldEnum[]
  }

  /**
   * Call findMany
   */
  export type CallFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallInclude<ExtArgs> | null
    /**
     * Filter, which Calls to fetch.
     */
    where?: CallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calls to fetch.
     */
    orderBy?: CallOrderByWithRelationInput | CallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Calls.
     */
    cursor?: CallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calls.
     */
    skip?: number
    distinct?: CallScalarFieldEnum | CallScalarFieldEnum[]
  }

  /**
   * Call create
   */
  export type CallCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallInclude<ExtArgs> | null
    /**
     * The data needed to create a Call.
     */
    data?: XOR<CallCreateInput, CallUncheckedCreateInput>
  }

  /**
   * Call createMany
   */
  export type CallCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Calls.
     */
    data: CallCreateManyInput | CallCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Call createManyAndReturn
   */
  export type CallCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * The data used to create many Calls.
     */
    data: CallCreateManyInput | CallCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Call update
   */
  export type CallUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallInclude<ExtArgs> | null
    /**
     * The data needed to update a Call.
     */
    data: XOR<CallUpdateInput, CallUncheckedUpdateInput>
    /**
     * Choose, which Call to update.
     */
    where: CallWhereUniqueInput
  }

  /**
   * Call updateMany
   */
  export type CallUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Calls.
     */
    data: XOR<CallUpdateManyMutationInput, CallUncheckedUpdateManyInput>
    /**
     * Filter which Calls to update
     */
    where?: CallWhereInput
    /**
     * Limit how many Calls to update.
     */
    limit?: number
  }

  /**
   * Call updateManyAndReturn
   */
  export type CallUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * The data used to update Calls.
     */
    data: XOR<CallUpdateManyMutationInput, CallUncheckedUpdateManyInput>
    /**
     * Filter which Calls to update
     */
    where?: CallWhereInput
    /**
     * Limit how many Calls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Call upsert
   */
  export type CallUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallInclude<ExtArgs> | null
    /**
     * The filter to search for the Call to update in case it exists.
     */
    where: CallWhereUniqueInput
    /**
     * In case the Call found by the `where` argument doesn't exist, create a new Call with this data.
     */
    create: XOR<CallCreateInput, CallUncheckedCreateInput>
    /**
     * In case the Call was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallUpdateInput, CallUncheckedUpdateInput>
  }

  /**
   * Call delete
   */
  export type CallDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallInclude<ExtArgs> | null
    /**
     * Filter which Call to delete.
     */
    where: CallWhereUniqueInput
  }

  /**
   * Call deleteMany
   */
  export type CallDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Calls to delete
     */
    where?: CallWhereInput
    /**
     * Limit how many Calls to delete.
     */
    limit?: number
  }

  /**
   * Call.clinic
   */
  export type Call$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * Call.patient
   */
  export type Call$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * Call.doctor
   */
  export type Call$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * Call without action
   */
  export type CallDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallInclude<ExtArgs> | null
  }


  /**
   * Model Diagnosis
   */

  export type AggregateDiagnosis = {
    _count: DiagnosisCountAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  export type DiagnosisMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    diagnosisCode: string | null
    diagnosisName: string | null
    description: string | null
    status: string | null
    diagnosedDate: Date | null
    resolvedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiagnosisMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    diagnosisCode: string | null
    diagnosisName: string | null
    description: string | null
    status: string | null
    diagnosedDate: Date | null
    resolvedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiagnosisCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    diagnosisCode: number
    diagnosisName: number
    description: number
    status: number
    diagnosedDate: number
    resolvedDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiagnosisMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    diagnosisCode?: true
    diagnosisName?: true
    description?: true
    status?: true
    diagnosedDate?: true
    resolvedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiagnosisMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    diagnosisCode?: true
    diagnosisName?: true
    description?: true
    status?: true
    diagnosedDate?: true
    resolvedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiagnosisCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    diagnosisCode?: true
    diagnosisName?: true
    description?: true
    status?: true
    diagnosedDate?: true
    resolvedDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiagnosisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diagnosis to aggregate.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diagnoses
    **/
    _count?: true | DiagnosisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosisMaxAggregateInputType
  }

  export type GetDiagnosisAggregateType<T extends DiagnosisAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnosis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnosis[P]>
      : GetScalarType<T[P], AggregateDiagnosis[P]>
  }




  export type DiagnosisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisWhereInput
    orderBy?: DiagnosisOrderByWithAggregationInput | DiagnosisOrderByWithAggregationInput[]
    by: DiagnosisScalarFieldEnum[] | DiagnosisScalarFieldEnum
    having?: DiagnosisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosisCountAggregateInputType | true
    _min?: DiagnosisMinAggregateInputType
    _max?: DiagnosisMaxAggregateInputType
  }

  export type DiagnosisGroupByOutputType = {
    id: string
    patientId: string | null
    doctorId: string | null
    diagnosisCode: string | null
    diagnosisName: string | null
    description: string | null
    status: string | null
    diagnosedDate: Date | null
    resolvedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: DiagnosisCountAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  type GetDiagnosisGroupByPayload<T extends DiagnosisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
        }
      >
    >


  export type DiagnosisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    diagnosisCode?: boolean
    diagnosisName?: boolean
    description?: boolean
    status?: boolean
    diagnosedDate?: boolean
    resolvedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | Diagnosis$patientArgs<ExtArgs>
    doctor?: boolean | Diagnosis$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosis"]>

  export type DiagnosisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    diagnosisCode?: boolean
    diagnosisName?: boolean
    description?: boolean
    status?: boolean
    diagnosedDate?: boolean
    resolvedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | Diagnosis$patientArgs<ExtArgs>
    doctor?: boolean | Diagnosis$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosis"]>

  export type DiagnosisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    diagnosisCode?: boolean
    diagnosisName?: boolean
    description?: boolean
    status?: boolean
    diagnosedDate?: boolean
    resolvedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | Diagnosis$patientArgs<ExtArgs>
    doctor?: boolean | Diagnosis$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosis"]>

  export type DiagnosisSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    diagnosisCode?: boolean
    diagnosisName?: boolean
    description?: boolean
    status?: boolean
    diagnosedDate?: boolean
    resolvedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DiagnosisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "doctorId" | "diagnosisCode" | "diagnosisName" | "description" | "status" | "diagnosedDate" | "resolvedDate" | "createdAt" | "updatedAt", ExtArgs["result"]["diagnosis"]>
  export type DiagnosisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | Diagnosis$patientArgs<ExtArgs>
    doctor?: boolean | Diagnosis$doctorArgs<ExtArgs>
  }
  export type DiagnosisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | Diagnosis$patientArgs<ExtArgs>
    doctor?: boolean | Diagnosis$doctorArgs<ExtArgs>
  }
  export type DiagnosisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | Diagnosis$patientArgs<ExtArgs>
    doctor?: boolean | Diagnosis$doctorArgs<ExtArgs>
  }

  export type $DiagnosisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Diagnosis"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs> | null
      doctor: Prisma.$DoctorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      doctorId: string | null
      diagnosisCode: string | null
      diagnosisName: string | null
      description: string | null
      status: string | null
      diagnosedDate: Date | null
      resolvedDate: Date | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["diagnosis"]>
    composites: {}
  }

  type DiagnosisGetPayload<S extends boolean | null | undefined | DiagnosisDefaultArgs> = $Result.GetResult<Prisma.$DiagnosisPayload, S>

  type DiagnosisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiagnosisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiagnosisCountAggregateInputType | true
    }

  export interface DiagnosisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diagnosis'], meta: { name: 'Diagnosis' } }
    /**
     * Find zero or one Diagnosis that matches the filter.
     * @param {DiagnosisFindUniqueArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiagnosisFindUniqueArgs>(args: SelectSubset<T, DiagnosisFindUniqueArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Diagnosis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiagnosisFindUniqueOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiagnosisFindUniqueOrThrowArgs>(args: SelectSubset<T, DiagnosisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diagnosis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiagnosisFindFirstArgs>(args?: SelectSubset<T, DiagnosisFindFirstArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diagnosis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiagnosisFindFirstOrThrowArgs>(args?: SelectSubset<T, DiagnosisFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Diagnoses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany()
     * 
     * // Get first 10 Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiagnosisFindManyArgs>(args?: SelectSubset<T, DiagnosisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Diagnosis.
     * @param {DiagnosisCreateArgs} args - Arguments to create a Diagnosis.
     * @example
     * // Create one Diagnosis
     * const Diagnosis = await prisma.diagnosis.create({
     *   data: {
     *     // ... data to create a Diagnosis
     *   }
     * })
     * 
     */
    create<T extends DiagnosisCreateArgs>(args: SelectSubset<T, DiagnosisCreateArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Diagnoses.
     * @param {DiagnosisCreateManyArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiagnosisCreateManyArgs>(args?: SelectSubset<T, DiagnosisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Diagnoses and returns the data saved in the database.
     * @param {DiagnosisCreateManyAndReturnArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Diagnoses and only return the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiagnosisCreateManyAndReturnArgs>(args?: SelectSubset<T, DiagnosisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Diagnosis.
     * @param {DiagnosisDeleteArgs} args - Arguments to delete one Diagnosis.
     * @example
     * // Delete one Diagnosis
     * const Diagnosis = await prisma.diagnosis.delete({
     *   where: {
     *     // ... filter to delete one Diagnosis
     *   }
     * })
     * 
     */
    delete<T extends DiagnosisDeleteArgs>(args: SelectSubset<T, DiagnosisDeleteArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Diagnosis.
     * @param {DiagnosisUpdateArgs} args - Arguments to update one Diagnosis.
     * @example
     * // Update one Diagnosis
     * const diagnosis = await prisma.diagnosis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiagnosisUpdateArgs>(args: SelectSubset<T, DiagnosisUpdateArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Diagnoses.
     * @param {DiagnosisDeleteManyArgs} args - Arguments to filter Diagnoses to delete.
     * @example
     * // Delete a few Diagnoses
     * const { count } = await prisma.diagnosis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiagnosisDeleteManyArgs>(args?: SelectSubset<T, DiagnosisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diagnoses
     * const diagnosis = await prisma.diagnosis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiagnosisUpdateManyArgs>(args: SelectSubset<T, DiagnosisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnoses and returns the data updated in the database.
     * @param {DiagnosisUpdateManyAndReturnArgs} args - Arguments to update many Diagnoses.
     * @example
     * // Update many Diagnoses
     * const diagnosis = await prisma.diagnosis.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Diagnoses and only return the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiagnosisUpdateManyAndReturnArgs>(args: SelectSubset<T, DiagnosisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Diagnosis.
     * @param {DiagnosisUpsertArgs} args - Arguments to update or create a Diagnosis.
     * @example
     * // Update or create a Diagnosis
     * const diagnosis = await prisma.diagnosis.upsert({
     *   create: {
     *     // ... data to create a Diagnosis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diagnosis we want to update
     *   }
     * })
     */
    upsert<T extends DiagnosisUpsertArgs>(args: SelectSubset<T, DiagnosisUpsertArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisCountArgs} args - Arguments to filter Diagnoses to count.
     * @example
     * // Count the number of Diagnoses
     * const count = await prisma.diagnosis.count({
     *   where: {
     *     // ... the filter for the Diagnoses we want to count
     *   }
     * })
    **/
    count<T extends DiagnosisCountArgs>(
      args?: Subset<T, DiagnosisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosisAggregateArgs>(args: Subset<T, DiagnosisAggregateArgs>): Prisma.PrismaPromise<GetDiagnosisAggregateType<T>>

    /**
     * Group by Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiagnosisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiagnosisGroupByArgs['orderBy'] }
        : { orderBy?: DiagnosisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiagnosisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Diagnosis model
   */
  readonly fields: DiagnosisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Diagnosis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiagnosisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends Diagnosis$patientArgs<ExtArgs> = {}>(args?: Subset<T, Diagnosis$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    doctor<T extends Diagnosis$doctorArgs<ExtArgs> = {}>(args?: Subset<T, Diagnosis$doctorArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Diagnosis model
   */
  interface DiagnosisFieldRefs {
    readonly id: FieldRef<"Diagnosis", 'String'>
    readonly patientId: FieldRef<"Diagnosis", 'String'>
    readonly doctorId: FieldRef<"Diagnosis", 'String'>
    readonly diagnosisCode: FieldRef<"Diagnosis", 'String'>
    readonly diagnosisName: FieldRef<"Diagnosis", 'String'>
    readonly description: FieldRef<"Diagnosis", 'String'>
    readonly status: FieldRef<"Diagnosis", 'String'>
    readonly diagnosedDate: FieldRef<"Diagnosis", 'DateTime'>
    readonly resolvedDate: FieldRef<"Diagnosis", 'DateTime'>
    readonly createdAt: FieldRef<"Diagnosis", 'DateTime'>
    readonly updatedAt: FieldRef<"Diagnosis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Diagnosis findUnique
   */
  export type DiagnosisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis findUniqueOrThrow
   */
  export type DiagnosisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis findFirst
   */
  export type DiagnosisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis findFirstOrThrow
   */
  export type DiagnosisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis findMany
   */
  export type DiagnosisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnoses to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis create
   */
  export type DiagnosisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to create a Diagnosis.
     */
    data?: XOR<DiagnosisCreateInput, DiagnosisUncheckedCreateInput>
  }

  /**
   * Diagnosis createMany
   */
  export type DiagnosisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diagnoses.
     */
    data: DiagnosisCreateManyInput | DiagnosisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diagnosis createManyAndReturn
   */
  export type DiagnosisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * The data used to create many Diagnoses.
     */
    data: DiagnosisCreateManyInput | DiagnosisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Diagnosis update
   */
  export type DiagnosisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to update a Diagnosis.
     */
    data: XOR<DiagnosisUpdateInput, DiagnosisUncheckedUpdateInput>
    /**
     * Choose, which Diagnosis to update.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis updateMany
   */
  export type DiagnosisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diagnoses.
     */
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyInput>
    /**
     * Filter which Diagnoses to update
     */
    where?: DiagnosisWhereInput
    /**
     * Limit how many Diagnoses to update.
     */
    limit?: number
  }

  /**
   * Diagnosis updateManyAndReturn
   */
  export type DiagnosisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * The data used to update Diagnoses.
     */
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyInput>
    /**
     * Filter which Diagnoses to update
     */
    where?: DiagnosisWhereInput
    /**
     * Limit how many Diagnoses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Diagnosis upsert
   */
  export type DiagnosisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The filter to search for the Diagnosis to update in case it exists.
     */
    where: DiagnosisWhereUniqueInput
    /**
     * In case the Diagnosis found by the `where` argument doesn't exist, create a new Diagnosis with this data.
     */
    create: XOR<DiagnosisCreateInput, DiagnosisUncheckedCreateInput>
    /**
     * In case the Diagnosis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiagnosisUpdateInput, DiagnosisUncheckedUpdateInput>
  }

  /**
   * Diagnosis delete
   */
  export type DiagnosisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter which Diagnosis to delete.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis deleteMany
   */
  export type DiagnosisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diagnoses to delete
     */
    where?: DiagnosisWhereInput
    /**
     * Limit how many Diagnoses to delete.
     */
    limit?: number
  }

  /**
   * Diagnosis.patient
   */
  export type Diagnosis$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * Diagnosis.doctor
   */
  export type Diagnosis$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * Diagnosis without action
   */
  export type DiagnosisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
  }


  /**
   * Model Lab
   */

  export type AggregateLab = {
    _count: LabCountAggregateOutputType | null
    _min: LabMinAggregateOutputType | null
    _max: LabMaxAggregateOutputType | null
  }

  export type LabMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    testDate: Date | null
    pdfKeyCipher: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LabMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    testDate: Date | null
    pdfKeyCipher: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LabCountAggregateOutputType = {
    id: number
    clinicId: number
    patientId: number
    testDate: number
    pdfKeyCipher: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type LabMinAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    testDate?: true
    pdfKeyCipher?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LabMaxAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    testDate?: true
    pdfKeyCipher?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LabCountAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    testDate?: true
    pdfKeyCipher?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type LabAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lab to aggregate.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Labs
    **/
    _count?: true | LabCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabMaxAggregateInputType
  }

  export type GetLabAggregateType<T extends LabAggregateArgs> = {
        [P in keyof T & keyof AggregateLab]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLab[P]>
      : GetScalarType<T[P], AggregateLab[P]>
  }




  export type LabGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabWhereInput
    orderBy?: LabOrderByWithAggregationInput | LabOrderByWithAggregationInput[]
    by: LabScalarFieldEnum[] | LabScalarFieldEnum
    having?: LabScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabCountAggregateInputType | true
    _min?: LabMinAggregateInputType
    _max?: LabMaxAggregateInputType
  }

  export type LabGroupByOutputType = {
    id: string
    clinicId: string | null
    patientId: string | null
    testDate: Date | null
    pdfKeyCipher: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: LabCountAggregateOutputType | null
    _min: LabMinAggregateOutputType | null
    _max: LabMaxAggregateOutputType | null
  }

  type GetLabGroupByPayload<T extends LabGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabGroupByOutputType[P]>
            : GetScalarType<T[P], LabGroupByOutputType[P]>
        }
      >
    >


  export type LabSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    testDate?: boolean
    pdfKeyCipher?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Lab$clinicArgs<ExtArgs>
    patient?: boolean | Lab$patientArgs<ExtArgs>
    results?: boolean | Lab$resultsArgs<ExtArgs>
    _count?: boolean | LabCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lab"]>

  export type LabSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    testDate?: boolean
    pdfKeyCipher?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Lab$clinicArgs<ExtArgs>
    patient?: boolean | Lab$patientArgs<ExtArgs>
  }, ExtArgs["result"]["lab"]>

  export type LabSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    testDate?: boolean
    pdfKeyCipher?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Lab$clinicArgs<ExtArgs>
    patient?: boolean | Lab$patientArgs<ExtArgs>
  }, ExtArgs["result"]["lab"]>

  export type LabSelectScalar = {
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    testDate?: boolean
    pdfKeyCipher?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type LabOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "patientId" | "testDate" | "pdfKeyCipher" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["lab"]>
  export type LabInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Lab$clinicArgs<ExtArgs>
    patient?: boolean | Lab$patientArgs<ExtArgs>
    results?: boolean | Lab$resultsArgs<ExtArgs>
    _count?: boolean | LabCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Lab$clinicArgs<ExtArgs>
    patient?: boolean | Lab$patientArgs<ExtArgs>
  }
  export type LabIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Lab$clinicArgs<ExtArgs>
    patient?: boolean | Lab$patientArgs<ExtArgs>
  }

  export type $LabPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lab"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs> | null
      results: Prisma.$LabResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string | null
      patientId: string | null
      testDate: Date | null
      pdfKeyCipher: string | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["lab"]>
    composites: {}
  }

  type LabGetPayload<S extends boolean | null | undefined | LabDefaultArgs> = $Result.GetResult<Prisma.$LabPayload, S>

  type LabCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabCountAggregateInputType | true
    }

  export interface LabDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lab'], meta: { name: 'Lab' } }
    /**
     * Find zero or one Lab that matches the filter.
     * @param {LabFindUniqueArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabFindUniqueArgs>(args: SelectSubset<T, LabFindUniqueArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lab that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabFindUniqueOrThrowArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabFindUniqueOrThrowArgs>(args: SelectSubset<T, LabFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabFindFirstArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabFindFirstArgs>(args?: SelectSubset<T, LabFindFirstArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabFindFirstOrThrowArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabFindFirstOrThrowArgs>(args?: SelectSubset<T, LabFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Labs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Labs
     * const labs = await prisma.lab.findMany()
     * 
     * // Get first 10 Labs
     * const labs = await prisma.lab.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labWithIdOnly = await prisma.lab.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabFindManyArgs>(args?: SelectSubset<T, LabFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lab.
     * @param {LabCreateArgs} args - Arguments to create a Lab.
     * @example
     * // Create one Lab
     * const Lab = await prisma.lab.create({
     *   data: {
     *     // ... data to create a Lab
     *   }
     * })
     * 
     */
    create<T extends LabCreateArgs>(args: SelectSubset<T, LabCreateArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Labs.
     * @param {LabCreateManyArgs} args - Arguments to create many Labs.
     * @example
     * // Create many Labs
     * const lab = await prisma.lab.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabCreateManyArgs>(args?: SelectSubset<T, LabCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Labs and returns the data saved in the database.
     * @param {LabCreateManyAndReturnArgs} args - Arguments to create many Labs.
     * @example
     * // Create many Labs
     * const lab = await prisma.lab.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Labs and only return the `id`
     * const labWithIdOnly = await prisma.lab.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabCreateManyAndReturnArgs>(args?: SelectSubset<T, LabCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lab.
     * @param {LabDeleteArgs} args - Arguments to delete one Lab.
     * @example
     * // Delete one Lab
     * const Lab = await prisma.lab.delete({
     *   where: {
     *     // ... filter to delete one Lab
     *   }
     * })
     * 
     */
    delete<T extends LabDeleteArgs>(args: SelectSubset<T, LabDeleteArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lab.
     * @param {LabUpdateArgs} args - Arguments to update one Lab.
     * @example
     * // Update one Lab
     * const lab = await prisma.lab.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabUpdateArgs>(args: SelectSubset<T, LabUpdateArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Labs.
     * @param {LabDeleteManyArgs} args - Arguments to filter Labs to delete.
     * @example
     * // Delete a few Labs
     * const { count } = await prisma.lab.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabDeleteManyArgs>(args?: SelectSubset<T, LabDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Labs
     * const lab = await prisma.lab.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabUpdateManyArgs>(args: SelectSubset<T, LabUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labs and returns the data updated in the database.
     * @param {LabUpdateManyAndReturnArgs} args - Arguments to update many Labs.
     * @example
     * // Update many Labs
     * const lab = await prisma.lab.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Labs and only return the `id`
     * const labWithIdOnly = await prisma.lab.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabUpdateManyAndReturnArgs>(args: SelectSubset<T, LabUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lab.
     * @param {LabUpsertArgs} args - Arguments to update or create a Lab.
     * @example
     * // Update or create a Lab
     * const lab = await prisma.lab.upsert({
     *   create: {
     *     // ... data to create a Lab
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lab we want to update
     *   }
     * })
     */
    upsert<T extends LabUpsertArgs>(args: SelectSubset<T, LabUpsertArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabCountArgs} args - Arguments to filter Labs to count.
     * @example
     * // Count the number of Labs
     * const count = await prisma.lab.count({
     *   where: {
     *     // ... the filter for the Labs we want to count
     *   }
     * })
    **/
    count<T extends LabCountArgs>(
      args?: Subset<T, LabCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabAggregateArgs>(args: Subset<T, LabAggregateArgs>): Prisma.PrismaPromise<GetLabAggregateType<T>>

    /**
     * Group by Lab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabGroupByArgs['orderBy'] }
        : { orderBy?: LabGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lab model
   */
  readonly fields: LabFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lab.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends Lab$clinicArgs<ExtArgs> = {}>(args?: Subset<T, Lab$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends Lab$patientArgs<ExtArgs> = {}>(args?: Subset<T, Lab$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    results<T extends Lab$resultsArgs<ExtArgs> = {}>(args?: Subset<T, Lab$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lab model
   */
  interface LabFieldRefs {
    readonly id: FieldRef<"Lab", 'String'>
    readonly clinicId: FieldRef<"Lab", 'String'>
    readonly patientId: FieldRef<"Lab", 'String'>
    readonly testDate: FieldRef<"Lab", 'DateTime'>
    readonly pdfKeyCipher: FieldRef<"Lab", 'String'>
    readonly createdAt: FieldRef<"Lab", 'DateTime'>
    readonly updatedAt: FieldRef<"Lab", 'DateTime'>
    readonly deletedAt: FieldRef<"Lab", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lab findUnique
   */
  export type LabFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab findUniqueOrThrow
   */
  export type LabFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab findFirst
   */
  export type LabFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labs.
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labs.
     */
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * Lab findFirstOrThrow
   */
  export type LabFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labs.
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labs.
     */
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * Lab findMany
   */
  export type LabFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Labs to fetch.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Labs.
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * Lab create
   */
  export type LabCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * The data needed to create a Lab.
     */
    data?: XOR<LabCreateInput, LabUncheckedCreateInput>
  }

  /**
   * Lab createMany
   */
  export type LabCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Labs.
     */
    data: LabCreateManyInput | LabCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lab createManyAndReturn
   */
  export type LabCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * The data used to create many Labs.
     */
    data: LabCreateManyInput | LabCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lab update
   */
  export type LabUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * The data needed to update a Lab.
     */
    data: XOR<LabUpdateInput, LabUncheckedUpdateInput>
    /**
     * Choose, which Lab to update.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab updateMany
   */
  export type LabUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Labs.
     */
    data: XOR<LabUpdateManyMutationInput, LabUncheckedUpdateManyInput>
    /**
     * Filter which Labs to update
     */
    where?: LabWhereInput
    /**
     * Limit how many Labs to update.
     */
    limit?: number
  }

  /**
   * Lab updateManyAndReturn
   */
  export type LabUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * The data used to update Labs.
     */
    data: XOR<LabUpdateManyMutationInput, LabUncheckedUpdateManyInput>
    /**
     * Filter which Labs to update
     */
    where?: LabWhereInput
    /**
     * Limit how many Labs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lab upsert
   */
  export type LabUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * The filter to search for the Lab to update in case it exists.
     */
    where: LabWhereUniqueInput
    /**
     * In case the Lab found by the `where` argument doesn't exist, create a new Lab with this data.
     */
    create: XOR<LabCreateInput, LabUncheckedCreateInput>
    /**
     * In case the Lab was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabUpdateInput, LabUncheckedUpdateInput>
  }

  /**
   * Lab delete
   */
  export type LabDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter which Lab to delete.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab deleteMany
   */
  export type LabDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Labs to delete
     */
    where?: LabWhereInput
    /**
     * Limit how many Labs to delete.
     */
    limit?: number
  }

  /**
   * Lab.clinic
   */
  export type Lab$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * Lab.patient
   */
  export type Lab$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * Lab.results
   */
  export type Lab$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    where?: LabResultWhereInput
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    cursor?: LabResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * Lab without action
   */
  export type LabDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
  }


  /**
   * Model LabResult
   */

  export type AggregateLabResult = {
    _count: LabResultCountAggregateOutputType | null
    _avg: LabResultAvgAggregateOutputType | null
    _sum: LabResultSumAggregateOutputType | null
    _min: LabResultMinAggregateOutputType | null
    _max: LabResultMaxAggregateOutputType | null
  }

  export type LabResultAvgAggregateOutputType = {
    normalMin: number | null
    normalMax: number | null
  }

  export type LabResultSumAggregateOutputType = {
    normalMin: number | null
    normalMax: number | null
  }

  export type LabResultMinAggregateOutputType = {
    id: string | null
    labId: string | null
    testName: string | null
    result: string | null
    unit: string | null
    normalMin: number | null
    normalMax: number | null
    flag: $Enums.Flag | null
  }

  export type LabResultMaxAggregateOutputType = {
    id: string | null
    labId: string | null
    testName: string | null
    result: string | null
    unit: string | null
    normalMin: number | null
    normalMax: number | null
    flag: $Enums.Flag | null
  }

  export type LabResultCountAggregateOutputType = {
    id: number
    labId: number
    testName: number
    result: number
    unit: number
    normalMin: number
    normalMax: number
    flag: number
    _all: number
  }


  export type LabResultAvgAggregateInputType = {
    normalMin?: true
    normalMax?: true
  }

  export type LabResultSumAggregateInputType = {
    normalMin?: true
    normalMax?: true
  }

  export type LabResultMinAggregateInputType = {
    id?: true
    labId?: true
    testName?: true
    result?: true
    unit?: true
    normalMin?: true
    normalMax?: true
    flag?: true
  }

  export type LabResultMaxAggregateInputType = {
    id?: true
    labId?: true
    testName?: true
    result?: true
    unit?: true
    normalMin?: true
    normalMax?: true
    flag?: true
  }

  export type LabResultCountAggregateInputType = {
    id?: true
    labId?: true
    testName?: true
    result?: true
    unit?: true
    normalMin?: true
    normalMax?: true
    flag?: true
    _all?: true
  }

  export type LabResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabResult to aggregate.
     */
    where?: LabResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabResults to fetch.
     */
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabResults
    **/
    _count?: true | LabResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabResultMaxAggregateInputType
  }

  export type GetLabResultAggregateType<T extends LabResultAggregateArgs> = {
        [P in keyof T & keyof AggregateLabResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabResult[P]>
      : GetScalarType<T[P], AggregateLabResult[P]>
  }




  export type LabResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabResultWhereInput
    orderBy?: LabResultOrderByWithAggregationInput | LabResultOrderByWithAggregationInput[]
    by: LabResultScalarFieldEnum[] | LabResultScalarFieldEnum
    having?: LabResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabResultCountAggregateInputType | true
    _avg?: LabResultAvgAggregateInputType
    _sum?: LabResultSumAggregateInputType
    _min?: LabResultMinAggregateInputType
    _max?: LabResultMaxAggregateInputType
  }

  export type LabResultGroupByOutputType = {
    id: string
    labId: string | null
    testName: string | null
    result: string | null
    unit: string | null
    normalMin: number | null
    normalMax: number | null
    flag: $Enums.Flag | null
    _count: LabResultCountAggregateOutputType | null
    _avg: LabResultAvgAggregateOutputType | null
    _sum: LabResultSumAggregateOutputType | null
    _min: LabResultMinAggregateOutputType | null
    _max: LabResultMaxAggregateOutputType | null
  }

  type GetLabResultGroupByPayload<T extends LabResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabResultGroupByOutputType[P]>
            : GetScalarType<T[P], LabResultGroupByOutputType[P]>
        }
      >
    >


  export type LabResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    labId?: boolean
    testName?: boolean
    result?: boolean
    unit?: boolean
    normalMin?: boolean
    normalMax?: boolean
    flag?: boolean
    lab?: boolean | LabResult$labArgs<ExtArgs>
  }, ExtArgs["result"]["labResult"]>

  export type LabResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    labId?: boolean
    testName?: boolean
    result?: boolean
    unit?: boolean
    normalMin?: boolean
    normalMax?: boolean
    flag?: boolean
    lab?: boolean | LabResult$labArgs<ExtArgs>
  }, ExtArgs["result"]["labResult"]>

  export type LabResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    labId?: boolean
    testName?: boolean
    result?: boolean
    unit?: boolean
    normalMin?: boolean
    normalMax?: boolean
    flag?: boolean
    lab?: boolean | LabResult$labArgs<ExtArgs>
  }, ExtArgs["result"]["labResult"]>

  export type LabResultSelectScalar = {
    id?: boolean
    labId?: boolean
    testName?: boolean
    result?: boolean
    unit?: boolean
    normalMin?: boolean
    normalMax?: boolean
    flag?: boolean
  }

  export type LabResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "labId" | "testName" | "result" | "unit" | "normalMin" | "normalMax" | "flag", ExtArgs["result"]["labResult"]>
  export type LabResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabResult$labArgs<ExtArgs>
  }
  export type LabResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabResult$labArgs<ExtArgs>
  }
  export type LabResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabResult$labArgs<ExtArgs>
  }

  export type $LabResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabResult"
    objects: {
      lab: Prisma.$LabPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      labId: string | null
      testName: string | null
      result: string | null
      unit: string | null
      normalMin: number | null
      normalMax: number | null
      flag: $Enums.Flag | null
    }, ExtArgs["result"]["labResult"]>
    composites: {}
  }

  type LabResultGetPayload<S extends boolean | null | undefined | LabResultDefaultArgs> = $Result.GetResult<Prisma.$LabResultPayload, S>

  type LabResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabResultCountAggregateInputType | true
    }

  export interface LabResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabResult'], meta: { name: 'LabResult' } }
    /**
     * Find zero or one LabResult that matches the filter.
     * @param {LabResultFindUniqueArgs} args - Arguments to find a LabResult
     * @example
     * // Get one LabResult
     * const labResult = await prisma.labResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabResultFindUniqueArgs>(args: SelectSubset<T, LabResultFindUniqueArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabResultFindUniqueOrThrowArgs} args - Arguments to find a LabResult
     * @example
     * // Get one LabResult
     * const labResult = await prisma.labResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabResultFindUniqueOrThrowArgs>(args: SelectSubset<T, LabResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultFindFirstArgs} args - Arguments to find a LabResult
     * @example
     * // Get one LabResult
     * const labResult = await prisma.labResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabResultFindFirstArgs>(args?: SelectSubset<T, LabResultFindFirstArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultFindFirstOrThrowArgs} args - Arguments to find a LabResult
     * @example
     * // Get one LabResult
     * const labResult = await prisma.labResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabResultFindFirstOrThrowArgs>(args?: SelectSubset<T, LabResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabResults
     * const labResults = await prisma.labResult.findMany()
     * 
     * // Get first 10 LabResults
     * const labResults = await prisma.labResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labResultWithIdOnly = await prisma.labResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabResultFindManyArgs>(args?: SelectSubset<T, LabResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabResult.
     * @param {LabResultCreateArgs} args - Arguments to create a LabResult.
     * @example
     * // Create one LabResult
     * const LabResult = await prisma.labResult.create({
     *   data: {
     *     // ... data to create a LabResult
     *   }
     * })
     * 
     */
    create<T extends LabResultCreateArgs>(args: SelectSubset<T, LabResultCreateArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabResults.
     * @param {LabResultCreateManyArgs} args - Arguments to create many LabResults.
     * @example
     * // Create many LabResults
     * const labResult = await prisma.labResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabResultCreateManyArgs>(args?: SelectSubset<T, LabResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabResults and returns the data saved in the database.
     * @param {LabResultCreateManyAndReturnArgs} args - Arguments to create many LabResults.
     * @example
     * // Create many LabResults
     * const labResult = await prisma.labResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabResults and only return the `id`
     * const labResultWithIdOnly = await prisma.labResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabResultCreateManyAndReturnArgs>(args?: SelectSubset<T, LabResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabResult.
     * @param {LabResultDeleteArgs} args - Arguments to delete one LabResult.
     * @example
     * // Delete one LabResult
     * const LabResult = await prisma.labResult.delete({
     *   where: {
     *     // ... filter to delete one LabResult
     *   }
     * })
     * 
     */
    delete<T extends LabResultDeleteArgs>(args: SelectSubset<T, LabResultDeleteArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabResult.
     * @param {LabResultUpdateArgs} args - Arguments to update one LabResult.
     * @example
     * // Update one LabResult
     * const labResult = await prisma.labResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabResultUpdateArgs>(args: SelectSubset<T, LabResultUpdateArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabResults.
     * @param {LabResultDeleteManyArgs} args - Arguments to filter LabResults to delete.
     * @example
     * // Delete a few LabResults
     * const { count } = await prisma.labResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabResultDeleteManyArgs>(args?: SelectSubset<T, LabResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabResults
     * const labResult = await prisma.labResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabResultUpdateManyArgs>(args: SelectSubset<T, LabResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabResults and returns the data updated in the database.
     * @param {LabResultUpdateManyAndReturnArgs} args - Arguments to update many LabResults.
     * @example
     * // Update many LabResults
     * const labResult = await prisma.labResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabResults and only return the `id`
     * const labResultWithIdOnly = await prisma.labResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabResultUpdateManyAndReturnArgs>(args: SelectSubset<T, LabResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabResult.
     * @param {LabResultUpsertArgs} args - Arguments to update or create a LabResult.
     * @example
     * // Update or create a LabResult
     * const labResult = await prisma.labResult.upsert({
     *   create: {
     *     // ... data to create a LabResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabResult we want to update
     *   }
     * })
     */
    upsert<T extends LabResultUpsertArgs>(args: SelectSubset<T, LabResultUpsertArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultCountArgs} args - Arguments to filter LabResults to count.
     * @example
     * // Count the number of LabResults
     * const count = await prisma.labResult.count({
     *   where: {
     *     // ... the filter for the LabResults we want to count
     *   }
     * })
    **/
    count<T extends LabResultCountArgs>(
      args?: Subset<T, LabResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabResultAggregateArgs>(args: Subset<T, LabResultAggregateArgs>): Prisma.PrismaPromise<GetLabResultAggregateType<T>>

    /**
     * Group by LabResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabResultGroupByArgs['orderBy'] }
        : { orderBy?: LabResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabResult model
   */
  readonly fields: LabResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lab<T extends LabResult$labArgs<ExtArgs> = {}>(args?: Subset<T, LabResult$labArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabResult model
   */
  interface LabResultFieldRefs {
    readonly id: FieldRef<"LabResult", 'String'>
    readonly labId: FieldRef<"LabResult", 'String'>
    readonly testName: FieldRef<"LabResult", 'String'>
    readonly result: FieldRef<"LabResult", 'String'>
    readonly unit: FieldRef<"LabResult", 'String'>
    readonly normalMin: FieldRef<"LabResult", 'Float'>
    readonly normalMax: FieldRef<"LabResult", 'Float'>
    readonly flag: FieldRef<"LabResult", 'Flag'>
  }
    

  // Custom InputTypes
  /**
   * LabResult findUnique
   */
  export type LabResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResult to fetch.
     */
    where: LabResultWhereUniqueInput
  }

  /**
   * LabResult findUniqueOrThrow
   */
  export type LabResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResult to fetch.
     */
    where: LabResultWhereUniqueInput
  }

  /**
   * LabResult findFirst
   */
  export type LabResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResult to fetch.
     */
    where?: LabResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabResults to fetch.
     */
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabResults.
     */
    cursor?: LabResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabResults.
     */
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * LabResult findFirstOrThrow
   */
  export type LabResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResult to fetch.
     */
    where?: LabResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabResults to fetch.
     */
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabResults.
     */
    cursor?: LabResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabResults.
     */
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * LabResult findMany
   */
  export type LabResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResults to fetch.
     */
    where?: LabResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabResults to fetch.
     */
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabResults.
     */
    cursor?: LabResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabResults.
     */
    skip?: number
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * LabResult create
   */
  export type LabResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * The data needed to create a LabResult.
     */
    data?: XOR<LabResultCreateInput, LabResultUncheckedCreateInput>
  }

  /**
   * LabResult createMany
   */
  export type LabResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabResults.
     */
    data: LabResultCreateManyInput | LabResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabResult createManyAndReturn
   */
  export type LabResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * The data used to create many LabResults.
     */
    data: LabResultCreateManyInput | LabResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabResult update
   */
  export type LabResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * The data needed to update a LabResult.
     */
    data: XOR<LabResultUpdateInput, LabResultUncheckedUpdateInput>
    /**
     * Choose, which LabResult to update.
     */
    where: LabResultWhereUniqueInput
  }

  /**
   * LabResult updateMany
   */
  export type LabResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabResults.
     */
    data: XOR<LabResultUpdateManyMutationInput, LabResultUncheckedUpdateManyInput>
    /**
     * Filter which LabResults to update
     */
    where?: LabResultWhereInput
    /**
     * Limit how many LabResults to update.
     */
    limit?: number
  }

  /**
   * LabResult updateManyAndReturn
   */
  export type LabResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * The data used to update LabResults.
     */
    data: XOR<LabResultUpdateManyMutationInput, LabResultUncheckedUpdateManyInput>
    /**
     * Filter which LabResults to update
     */
    where?: LabResultWhereInput
    /**
     * Limit how many LabResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabResult upsert
   */
  export type LabResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * The filter to search for the LabResult to update in case it exists.
     */
    where: LabResultWhereUniqueInput
    /**
     * In case the LabResult found by the `where` argument doesn't exist, create a new LabResult with this data.
     */
    create: XOR<LabResultCreateInput, LabResultUncheckedCreateInput>
    /**
     * In case the LabResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabResultUpdateInput, LabResultUncheckedUpdateInput>
  }

  /**
   * LabResult delete
   */
  export type LabResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter which LabResult to delete.
     */
    where: LabResultWhereUniqueInput
  }

  /**
   * LabResult deleteMany
   */
  export type LabResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabResults to delete
     */
    where?: LabResultWhereInput
    /**
     * Limit how many LabResults to delete.
     */
    limit?: number
  }

  /**
   * LabResult.lab
   */
  export type LabResult$labArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    where?: LabWhereInput
  }

  /**
   * LabResult without action
   */
  export type LabResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
  }


  /**
   * Model Prescription
   */

  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionAvgAggregateOutputType = {
    prescriptionNo: number | null
  }

  export type PrescriptionSumAggregateOutputType = {
    prescriptionNo: number | null
  }

  export type PrescriptionMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    doctorId: string | null
    prescriptionNo: number | null
    status: $Enums.PrescriptionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    doctorId: string | null
    prescriptionNo: number | null
    status: $Enums.PrescriptionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    clinicId: number
    patientId: number
    doctorId: number
    prescriptionNo: number
    status: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PrescriptionAvgAggregateInputType = {
    prescriptionNo?: true
  }

  export type PrescriptionSumAggregateInputType = {
    prescriptionNo?: true
  }

  export type PrescriptionMinAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    prescriptionNo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    prescriptionNo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    prescriptionNo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescription to aggregate.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type PrescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithAggregationInput | PrescriptionOrderByWithAggregationInput[]
    by: PrescriptionScalarFieldEnum[] | PrescriptionScalarFieldEnum
    having?: PrescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _avg?: PrescriptionAvgAggregateInputType
    _sum?: PrescriptionSumAggregateInputType
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }

  export type PrescriptionGroupByOutputType = {
    id: string
    clinicId: string | null
    patientId: string | null
    doctorId: string | null
    prescriptionNo: number | null
    status: $Enums.PrescriptionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    prescriptionNo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Prescription$clinicArgs<ExtArgs>
    patient?: boolean | Prescription$patientArgs<ExtArgs>
    doctor?: boolean | Prescription$doctorArgs<ExtArgs>
    medicines?: boolean | Prescription$medicinesArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    prescriptionNo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Prescription$clinicArgs<ExtArgs>
    patient?: boolean | Prescription$patientArgs<ExtArgs>
    doctor?: boolean | Prescription$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    prescriptionNo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Prescription$clinicArgs<ExtArgs>
    patient?: boolean | Prescription$patientArgs<ExtArgs>
    doctor?: boolean | Prescription$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectScalar = {
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    prescriptionNo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PrescriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "patientId" | "doctorId" | "prescriptionNo" | "status" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["prescription"]>
  export type PrescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Prescription$clinicArgs<ExtArgs>
    patient?: boolean | Prescription$patientArgs<ExtArgs>
    doctor?: boolean | Prescription$doctorArgs<ExtArgs>
    medicines?: boolean | Prescription$medicinesArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Prescription$clinicArgs<ExtArgs>
    patient?: boolean | Prescription$patientArgs<ExtArgs>
    doctor?: boolean | Prescription$doctorArgs<ExtArgs>
  }
  export type PrescriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Prescription$clinicArgs<ExtArgs>
    patient?: boolean | Prescription$patientArgs<ExtArgs>
    doctor?: boolean | Prescription$doctorArgs<ExtArgs>
  }

  export type $PrescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prescription"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs> | null
      doctor: Prisma.$DoctorPayload<ExtArgs> | null
      medicines: Prisma.$PrescriptionMedicinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string | null
      patientId: string | null
      doctorId: string | null
      prescriptionNo: number | null
      status: $Enums.PrescriptionStatus | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["prescription"]>
    composites: {}
  }

  type PrescriptionGetPayload<S extends boolean | null | undefined | PrescriptionDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionPayload, S>

  type PrescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface PrescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prescription'], meta: { name: 'Prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionFindUniqueArgs>(args: SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prescription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionFindFirstArgs>(args?: SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionFindManyArgs>(args?: SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prescription.
     * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
     */
    create<T extends PrescriptionCreateArgs>(args: SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prescriptions.
     * @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionCreateManyArgs>(args?: SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prescriptions and returns the data saved in the database.
     * @param {PrescriptionCreateManyAndReturnArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prescription.
     * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionDeleteArgs>(args: SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prescription.
     * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionUpdateArgs>(args: SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prescriptions.
     * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionDeleteManyArgs>(args?: SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionUpdateManyArgs>(args: SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions and returns the data updated in the database.
     * @param {PrescriptionUpdateManyAndReturnArgs} args - Arguments to update many Prescriptions.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prescription.
     * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionUpsertArgs>(args: SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionCountArgs>(
      args?: Subset<T, PrescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prescription model
   */
  readonly fields: PrescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends Prescription$clinicArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends Prescription$patientArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    doctor<T extends Prescription$doctorArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$doctorArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    medicines<T extends Prescription$medicinesArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$medicinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prescription model
   */
  interface PrescriptionFieldRefs {
    readonly id: FieldRef<"Prescription", 'String'>
    readonly clinicId: FieldRef<"Prescription", 'String'>
    readonly patientId: FieldRef<"Prescription", 'String'>
    readonly doctorId: FieldRef<"Prescription", 'String'>
    readonly prescriptionNo: FieldRef<"Prescription", 'Int'>
    readonly status: FieldRef<"Prescription", 'PrescriptionStatus'>
    readonly createdAt: FieldRef<"Prescription", 'DateTime'>
    readonly updatedAt: FieldRef<"Prescription", 'DateTime'>
    readonly deletedAt: FieldRef<"Prescription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prescription findUnique
   */
  export type PrescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findUniqueOrThrow
   */
  export type PrescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findFirst
   */
  export type PrescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findFirstOrThrow
   */
  export type PrescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findMany
   */
  export type PrescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescriptions to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription create
   */
  export type PrescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prescription.
     */
    data?: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
  }

  /**
   * Prescription createMany
   */
  export type PrescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prescription createManyAndReturn
   */
  export type PrescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription update
   */
  export type PrescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prescription.
     */
    data: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
    /**
     * Choose, which Prescription to update.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription updateMany
   */
  export type PrescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
  }

  /**
   * Prescription updateManyAndReturn
   */
  export type PrescriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription upsert
   */
  export type PrescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prescription to update in case it exists.
     */
    where: PrescriptionWhereUniqueInput
    /**
     * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
     */
    create: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
    /**
     * In case the Prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
  }

  /**
   * Prescription delete
   */
  export type PrescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter which Prescription to delete.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription deleteMany
   */
  export type PrescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescriptions to delete
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to delete.
     */
    limit?: number
  }

  /**
   * Prescription.clinic
   */
  export type Prescription$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * Prescription.patient
   */
  export type Prescription$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * Prescription.doctor
   */
  export type Prescription$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * Prescription.medicines
   */
  export type Prescription$medicinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    where?: PrescriptionMedicineWhereInput
    orderBy?: PrescriptionMedicineOrderByWithRelationInput | PrescriptionMedicineOrderByWithRelationInput[]
    cursor?: PrescriptionMedicineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionMedicineScalarFieldEnum | PrescriptionMedicineScalarFieldEnum[]
  }

  /**
   * Prescription without action
   */
  export type PrescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
  }


  /**
   * Model PrescriptionMedicine
   */

  export type AggregatePrescriptionMedicine = {
    _count: PrescriptionMedicineCountAggregateOutputType | null
    _avg: PrescriptionMedicineAvgAggregateOutputType | null
    _sum: PrescriptionMedicineSumAggregateOutputType | null
    _min: PrescriptionMedicineMinAggregateOutputType | null
    _max: PrescriptionMedicineMaxAggregateOutputType | null
  }

  export type PrescriptionMedicineAvgAggregateOutputType = {
    refill: number | null
  }

  export type PrescriptionMedicineSumAggregateOutputType = {
    refill: number | null
  }

  export type PrescriptionMedicineMinAggregateOutputType = {
    id: string | null
    prescriptionId: string | null
    medicine: string | null
    strength: string | null
    dose: string | null
    frequency: string | null
    route: string | null
    duration: string | null
    refill: number | null
  }

  export type PrescriptionMedicineMaxAggregateOutputType = {
    id: string | null
    prescriptionId: string | null
    medicine: string | null
    strength: string | null
    dose: string | null
    frequency: string | null
    route: string | null
    duration: string | null
    refill: number | null
  }

  export type PrescriptionMedicineCountAggregateOutputType = {
    id: number
    prescriptionId: number
    medicine: number
    strength: number
    dose: number
    frequency: number
    route: number
    duration: number
    refill: number
    _all: number
  }


  export type PrescriptionMedicineAvgAggregateInputType = {
    refill?: true
  }

  export type PrescriptionMedicineSumAggregateInputType = {
    refill?: true
  }

  export type PrescriptionMedicineMinAggregateInputType = {
    id?: true
    prescriptionId?: true
    medicine?: true
    strength?: true
    dose?: true
    frequency?: true
    route?: true
    duration?: true
    refill?: true
  }

  export type PrescriptionMedicineMaxAggregateInputType = {
    id?: true
    prescriptionId?: true
    medicine?: true
    strength?: true
    dose?: true
    frequency?: true
    route?: true
    duration?: true
    refill?: true
  }

  export type PrescriptionMedicineCountAggregateInputType = {
    id?: true
    prescriptionId?: true
    medicine?: true
    strength?: true
    dose?: true
    frequency?: true
    route?: true
    duration?: true
    refill?: true
    _all?: true
  }

  export type PrescriptionMedicineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionMedicine to aggregate.
     */
    where?: PrescriptionMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionMedicines to fetch.
     */
    orderBy?: PrescriptionMedicineOrderByWithRelationInput | PrescriptionMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionMedicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrescriptionMedicines
    **/
    _count?: true | PrescriptionMedicineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionMedicineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionMedicineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMedicineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMedicineMaxAggregateInputType
  }

  export type GetPrescriptionMedicineAggregateType<T extends PrescriptionMedicineAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescriptionMedicine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescriptionMedicine[P]>
      : GetScalarType<T[P], AggregatePrescriptionMedicine[P]>
  }




  export type PrescriptionMedicineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionMedicineWhereInput
    orderBy?: PrescriptionMedicineOrderByWithAggregationInput | PrescriptionMedicineOrderByWithAggregationInput[]
    by: PrescriptionMedicineScalarFieldEnum[] | PrescriptionMedicineScalarFieldEnum
    having?: PrescriptionMedicineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionMedicineCountAggregateInputType | true
    _avg?: PrescriptionMedicineAvgAggregateInputType
    _sum?: PrescriptionMedicineSumAggregateInputType
    _min?: PrescriptionMedicineMinAggregateInputType
    _max?: PrescriptionMedicineMaxAggregateInputType
  }

  export type PrescriptionMedicineGroupByOutputType = {
    id: string
    prescriptionId: string | null
    medicine: string | null
    strength: string | null
    dose: string | null
    frequency: string | null
    route: string | null
    duration: string | null
    refill: number | null
    _count: PrescriptionMedicineCountAggregateOutputType | null
    _avg: PrescriptionMedicineAvgAggregateOutputType | null
    _sum: PrescriptionMedicineSumAggregateOutputType | null
    _min: PrescriptionMedicineMinAggregateOutputType | null
    _max: PrescriptionMedicineMaxAggregateOutputType | null
  }

  type GetPrescriptionMedicineGroupByPayload<T extends PrescriptionMedicineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionMedicineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionMedicineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionMedicineGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionMedicineGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionMedicineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    medicine?: boolean
    strength?: boolean
    dose?: boolean
    frequency?: boolean
    route?: boolean
    duration?: boolean
    refill?: boolean
    prescription?: boolean | PrescriptionMedicine$prescriptionArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionMedicine"]>

  export type PrescriptionMedicineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    medicine?: boolean
    strength?: boolean
    dose?: boolean
    frequency?: boolean
    route?: boolean
    duration?: boolean
    refill?: boolean
    prescription?: boolean | PrescriptionMedicine$prescriptionArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionMedicine"]>

  export type PrescriptionMedicineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    medicine?: boolean
    strength?: boolean
    dose?: boolean
    frequency?: boolean
    route?: boolean
    duration?: boolean
    refill?: boolean
    prescription?: boolean | PrescriptionMedicine$prescriptionArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionMedicine"]>

  export type PrescriptionMedicineSelectScalar = {
    id?: boolean
    prescriptionId?: boolean
    medicine?: boolean
    strength?: boolean
    dose?: boolean
    frequency?: boolean
    route?: boolean
    duration?: boolean
    refill?: boolean
  }

  export type PrescriptionMedicineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prescriptionId" | "medicine" | "strength" | "dose" | "frequency" | "route" | "duration" | "refill", ExtArgs["result"]["prescriptionMedicine"]>
  export type PrescriptionMedicineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionMedicine$prescriptionArgs<ExtArgs>
  }
  export type PrescriptionMedicineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionMedicine$prescriptionArgs<ExtArgs>
  }
  export type PrescriptionMedicineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionMedicine$prescriptionArgs<ExtArgs>
  }

  export type $PrescriptionMedicinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrescriptionMedicine"
    objects: {
      prescription: Prisma.$PrescriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prescriptionId: string | null
      medicine: string | null
      strength: string | null
      dose: string | null
      frequency: string | null
      route: string | null
      duration: string | null
      refill: number | null
    }, ExtArgs["result"]["prescriptionMedicine"]>
    composites: {}
  }

  type PrescriptionMedicineGetPayload<S extends boolean | null | undefined | PrescriptionMedicineDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionMedicinePayload, S>

  type PrescriptionMedicineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionMedicineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionMedicineCountAggregateInputType | true
    }

  export interface PrescriptionMedicineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrescriptionMedicine'], meta: { name: 'PrescriptionMedicine' } }
    /**
     * Find zero or one PrescriptionMedicine that matches the filter.
     * @param {PrescriptionMedicineFindUniqueArgs} args - Arguments to find a PrescriptionMedicine
     * @example
     * // Get one PrescriptionMedicine
     * const prescriptionMedicine = await prisma.prescriptionMedicine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionMedicineFindUniqueArgs>(args: SelectSubset<T, PrescriptionMedicineFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrescriptionMedicine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionMedicineFindUniqueOrThrowArgs} args - Arguments to find a PrescriptionMedicine
     * @example
     * // Get one PrescriptionMedicine
     * const prescriptionMedicine = await prisma.prescriptionMedicine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionMedicineFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionMedicineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrescriptionMedicine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionMedicineFindFirstArgs} args - Arguments to find a PrescriptionMedicine
     * @example
     * // Get one PrescriptionMedicine
     * const prescriptionMedicine = await prisma.prescriptionMedicine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionMedicineFindFirstArgs>(args?: SelectSubset<T, PrescriptionMedicineFindFirstArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrescriptionMedicine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionMedicineFindFirstOrThrowArgs} args - Arguments to find a PrescriptionMedicine
     * @example
     * // Get one PrescriptionMedicine
     * const prescriptionMedicine = await prisma.prescriptionMedicine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionMedicineFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionMedicineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrescriptionMedicines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionMedicineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrescriptionMedicines
     * const prescriptionMedicines = await prisma.prescriptionMedicine.findMany()
     * 
     * // Get first 10 PrescriptionMedicines
     * const prescriptionMedicines = await prisma.prescriptionMedicine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionMedicineWithIdOnly = await prisma.prescriptionMedicine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionMedicineFindManyArgs>(args?: SelectSubset<T, PrescriptionMedicineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrescriptionMedicine.
     * @param {PrescriptionMedicineCreateArgs} args - Arguments to create a PrescriptionMedicine.
     * @example
     * // Create one PrescriptionMedicine
     * const PrescriptionMedicine = await prisma.prescriptionMedicine.create({
     *   data: {
     *     // ... data to create a PrescriptionMedicine
     *   }
     * })
     * 
     */
    create<T extends PrescriptionMedicineCreateArgs>(args: SelectSubset<T, PrescriptionMedicineCreateArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrescriptionMedicines.
     * @param {PrescriptionMedicineCreateManyArgs} args - Arguments to create many PrescriptionMedicines.
     * @example
     * // Create many PrescriptionMedicines
     * const prescriptionMedicine = await prisma.prescriptionMedicine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionMedicineCreateManyArgs>(args?: SelectSubset<T, PrescriptionMedicineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrescriptionMedicines and returns the data saved in the database.
     * @param {PrescriptionMedicineCreateManyAndReturnArgs} args - Arguments to create many PrescriptionMedicines.
     * @example
     * // Create many PrescriptionMedicines
     * const prescriptionMedicine = await prisma.prescriptionMedicine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrescriptionMedicines and only return the `id`
     * const prescriptionMedicineWithIdOnly = await prisma.prescriptionMedicine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionMedicineCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionMedicineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrescriptionMedicine.
     * @param {PrescriptionMedicineDeleteArgs} args - Arguments to delete one PrescriptionMedicine.
     * @example
     * // Delete one PrescriptionMedicine
     * const PrescriptionMedicine = await prisma.prescriptionMedicine.delete({
     *   where: {
     *     // ... filter to delete one PrescriptionMedicine
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionMedicineDeleteArgs>(args: SelectSubset<T, PrescriptionMedicineDeleteArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrescriptionMedicine.
     * @param {PrescriptionMedicineUpdateArgs} args - Arguments to update one PrescriptionMedicine.
     * @example
     * // Update one PrescriptionMedicine
     * const prescriptionMedicine = await prisma.prescriptionMedicine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionMedicineUpdateArgs>(args: SelectSubset<T, PrescriptionMedicineUpdateArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrescriptionMedicines.
     * @param {PrescriptionMedicineDeleteManyArgs} args - Arguments to filter PrescriptionMedicines to delete.
     * @example
     * // Delete a few PrescriptionMedicines
     * const { count } = await prisma.prescriptionMedicine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionMedicineDeleteManyArgs>(args?: SelectSubset<T, PrescriptionMedicineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionMedicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionMedicineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrescriptionMedicines
     * const prescriptionMedicine = await prisma.prescriptionMedicine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionMedicineUpdateManyArgs>(args: SelectSubset<T, PrescriptionMedicineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionMedicines and returns the data updated in the database.
     * @param {PrescriptionMedicineUpdateManyAndReturnArgs} args - Arguments to update many PrescriptionMedicines.
     * @example
     * // Update many PrescriptionMedicines
     * const prescriptionMedicine = await prisma.prescriptionMedicine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrescriptionMedicines and only return the `id`
     * const prescriptionMedicineWithIdOnly = await prisma.prescriptionMedicine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionMedicineUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionMedicineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrescriptionMedicine.
     * @param {PrescriptionMedicineUpsertArgs} args - Arguments to update or create a PrescriptionMedicine.
     * @example
     * // Update or create a PrescriptionMedicine
     * const prescriptionMedicine = await prisma.prescriptionMedicine.upsert({
     *   create: {
     *     // ... data to create a PrescriptionMedicine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrescriptionMedicine we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionMedicineUpsertArgs>(args: SelectSubset<T, PrescriptionMedicineUpsertArgs<ExtArgs>>): Prisma__PrescriptionMedicineClient<$Result.GetResult<Prisma.$PrescriptionMedicinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrescriptionMedicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionMedicineCountArgs} args - Arguments to filter PrescriptionMedicines to count.
     * @example
     * // Count the number of PrescriptionMedicines
     * const count = await prisma.prescriptionMedicine.count({
     *   where: {
     *     // ... the filter for the PrescriptionMedicines we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionMedicineCountArgs>(
      args?: Subset<T, PrescriptionMedicineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionMedicineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrescriptionMedicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionMedicineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionMedicineAggregateArgs>(args: Subset<T, PrescriptionMedicineAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionMedicineAggregateType<T>>

    /**
     * Group by PrescriptionMedicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionMedicineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionMedicineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionMedicineGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionMedicineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionMedicineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionMedicineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrescriptionMedicine model
   */
  readonly fields: PrescriptionMedicineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrescriptionMedicine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionMedicineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prescription<T extends PrescriptionMedicine$prescriptionArgs<ExtArgs> = {}>(args?: Subset<T, PrescriptionMedicine$prescriptionArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrescriptionMedicine model
   */
  interface PrescriptionMedicineFieldRefs {
    readonly id: FieldRef<"PrescriptionMedicine", 'String'>
    readonly prescriptionId: FieldRef<"PrescriptionMedicine", 'String'>
    readonly medicine: FieldRef<"PrescriptionMedicine", 'String'>
    readonly strength: FieldRef<"PrescriptionMedicine", 'String'>
    readonly dose: FieldRef<"PrescriptionMedicine", 'String'>
    readonly frequency: FieldRef<"PrescriptionMedicine", 'String'>
    readonly route: FieldRef<"PrescriptionMedicine", 'String'>
    readonly duration: FieldRef<"PrescriptionMedicine", 'String'>
    readonly refill: FieldRef<"PrescriptionMedicine", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PrescriptionMedicine findUnique
   */
  export type PrescriptionMedicineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionMedicine to fetch.
     */
    where: PrescriptionMedicineWhereUniqueInput
  }

  /**
   * PrescriptionMedicine findUniqueOrThrow
   */
  export type PrescriptionMedicineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionMedicine to fetch.
     */
    where: PrescriptionMedicineWhereUniqueInput
  }

  /**
   * PrescriptionMedicine findFirst
   */
  export type PrescriptionMedicineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionMedicine to fetch.
     */
    where?: PrescriptionMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionMedicines to fetch.
     */
    orderBy?: PrescriptionMedicineOrderByWithRelationInput | PrescriptionMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionMedicines.
     */
    cursor?: PrescriptionMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionMedicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionMedicines.
     */
    distinct?: PrescriptionMedicineScalarFieldEnum | PrescriptionMedicineScalarFieldEnum[]
  }

  /**
   * PrescriptionMedicine findFirstOrThrow
   */
  export type PrescriptionMedicineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionMedicine to fetch.
     */
    where?: PrescriptionMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionMedicines to fetch.
     */
    orderBy?: PrescriptionMedicineOrderByWithRelationInput | PrescriptionMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionMedicines.
     */
    cursor?: PrescriptionMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionMedicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionMedicines.
     */
    distinct?: PrescriptionMedicineScalarFieldEnum | PrescriptionMedicineScalarFieldEnum[]
  }

  /**
   * PrescriptionMedicine findMany
   */
  export type PrescriptionMedicineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionMedicines to fetch.
     */
    where?: PrescriptionMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionMedicines to fetch.
     */
    orderBy?: PrescriptionMedicineOrderByWithRelationInput | PrescriptionMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrescriptionMedicines.
     */
    cursor?: PrescriptionMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionMedicines.
     */
    skip?: number
    distinct?: PrescriptionMedicineScalarFieldEnum | PrescriptionMedicineScalarFieldEnum[]
  }

  /**
   * PrescriptionMedicine create
   */
  export type PrescriptionMedicineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * The data needed to create a PrescriptionMedicine.
     */
    data?: XOR<PrescriptionMedicineCreateInput, PrescriptionMedicineUncheckedCreateInput>
  }

  /**
   * PrescriptionMedicine createMany
   */
  export type PrescriptionMedicineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrescriptionMedicines.
     */
    data: PrescriptionMedicineCreateManyInput | PrescriptionMedicineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrescriptionMedicine createManyAndReturn
   */
  export type PrescriptionMedicineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * The data used to create many PrescriptionMedicines.
     */
    data: PrescriptionMedicineCreateManyInput | PrescriptionMedicineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionMedicine update
   */
  export type PrescriptionMedicineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * The data needed to update a PrescriptionMedicine.
     */
    data: XOR<PrescriptionMedicineUpdateInput, PrescriptionMedicineUncheckedUpdateInput>
    /**
     * Choose, which PrescriptionMedicine to update.
     */
    where: PrescriptionMedicineWhereUniqueInput
  }

  /**
   * PrescriptionMedicine updateMany
   */
  export type PrescriptionMedicineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrescriptionMedicines.
     */
    data: XOR<PrescriptionMedicineUpdateManyMutationInput, PrescriptionMedicineUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionMedicines to update
     */
    where?: PrescriptionMedicineWhereInput
    /**
     * Limit how many PrescriptionMedicines to update.
     */
    limit?: number
  }

  /**
   * PrescriptionMedicine updateManyAndReturn
   */
  export type PrescriptionMedicineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * The data used to update PrescriptionMedicines.
     */
    data: XOR<PrescriptionMedicineUpdateManyMutationInput, PrescriptionMedicineUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionMedicines to update
     */
    where?: PrescriptionMedicineWhereInput
    /**
     * Limit how many PrescriptionMedicines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionMedicine upsert
   */
  export type PrescriptionMedicineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * The filter to search for the PrescriptionMedicine to update in case it exists.
     */
    where: PrescriptionMedicineWhereUniqueInput
    /**
     * In case the PrescriptionMedicine found by the `where` argument doesn't exist, create a new PrescriptionMedicine with this data.
     */
    create: XOR<PrescriptionMedicineCreateInput, PrescriptionMedicineUncheckedCreateInput>
    /**
     * In case the PrescriptionMedicine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionMedicineUpdateInput, PrescriptionMedicineUncheckedUpdateInput>
  }

  /**
   * PrescriptionMedicine delete
   */
  export type PrescriptionMedicineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
    /**
     * Filter which PrescriptionMedicine to delete.
     */
    where: PrescriptionMedicineWhereUniqueInput
  }

  /**
   * PrescriptionMedicine deleteMany
   */
  export type PrescriptionMedicineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionMedicines to delete
     */
    where?: PrescriptionMedicineWhereInput
    /**
     * Limit how many PrescriptionMedicines to delete.
     */
    limit?: number
  }

  /**
   * PrescriptionMedicine.prescription
   */
  export type PrescriptionMedicine$prescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
  }

  /**
   * PrescriptionMedicine without action
   */
  export type PrescriptionMedicineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionMedicine
     */
    select?: PrescriptionMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionMedicine
     */
    omit?: PrescriptionMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionMedicineInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    firstNameCipher: string | null
    lastNameCipher: string | null
    phoneCipher: string | null
    emailCipher: string | null
    insuranceIdCipher: string | null
    addressCipher: string | null
    emergencyContactCipher: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    bloodGroup: string | null
    conditionName: string | null
    diagnosedDate: Date | null
    severity: string | null
    status: string | null
    retentionExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    firstNameBlind: string | null
    lastNameBlind: string | null
    insuranceIdBlind: string | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    firstNameCipher: string | null
    lastNameCipher: string | null
    phoneCipher: string | null
    emailCipher: string | null
    insuranceIdCipher: string | null
    addressCipher: string | null
    emergencyContactCipher: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    bloodGroup: string | null
    conditionName: string | null
    diagnosedDate: Date | null
    severity: string | null
    status: string | null
    retentionExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    firstNameBlind: string | null
    lastNameBlind: string | null
    insuranceIdBlind: string | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    clinicId: number
    firstNameCipher: number
    lastNameCipher: number
    phoneCipher: number
    emailCipher: number
    insuranceIdCipher: number
    addressCipher: number
    emergencyContactCipher: number
    dateOfBirth: number
    gender: number
    bloodGroup: number
    conditionName: number
    diagnosedDate: number
    severity: number
    status: number
    retentionExpiresAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    firstNameBlind: number
    lastNameBlind: number
    insuranceIdBlind: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    clinicId?: true
    firstNameCipher?: true
    lastNameCipher?: true
    phoneCipher?: true
    emailCipher?: true
    insuranceIdCipher?: true
    addressCipher?: true
    emergencyContactCipher?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    conditionName?: true
    diagnosedDate?: true
    severity?: true
    status?: true
    retentionExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    firstNameBlind?: true
    lastNameBlind?: true
    insuranceIdBlind?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    clinicId?: true
    firstNameCipher?: true
    lastNameCipher?: true
    phoneCipher?: true
    emailCipher?: true
    insuranceIdCipher?: true
    addressCipher?: true
    emergencyContactCipher?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    conditionName?: true
    diagnosedDate?: true
    severity?: true
    status?: true
    retentionExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    firstNameBlind?: true
    lastNameBlind?: true
    insuranceIdBlind?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    clinicId?: true
    firstNameCipher?: true
    lastNameCipher?: true
    phoneCipher?: true
    emailCipher?: true
    insuranceIdCipher?: true
    addressCipher?: true
    emergencyContactCipher?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    conditionName?: true
    diagnosedDate?: true
    severity?: true
    status?: true
    retentionExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    firstNameBlind?: true
    lastNameBlind?: true
    insuranceIdBlind?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    clinicId: string | null
    firstNameCipher: string | null
    lastNameCipher: string | null
    phoneCipher: string | null
    emailCipher: string | null
    insuranceIdCipher: string | null
    addressCipher: string | null
    emergencyContactCipher: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    bloodGroup: string | null
    conditionName: string | null
    diagnosedDate: Date | null
    severity: string | null
    status: string | null
    retentionExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    firstNameBlind: string | null
    lastNameBlind: string | null
    insuranceIdBlind: string | null
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    firstNameCipher?: boolean
    lastNameCipher?: boolean
    phoneCipher?: boolean
    emailCipher?: boolean
    insuranceIdCipher?: boolean
    addressCipher?: boolean
    emergencyContactCipher?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    conditionName?: boolean
    diagnosedDate?: boolean
    severity?: boolean
    status?: boolean
    retentionExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    firstNameBlind?: boolean
    lastNameBlind?: boolean
    insuranceIdBlind?: boolean
    clinic?: boolean | Patient$clinicArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    calls?: boolean | Patient$callsArgs<ExtArgs>
    labs?: boolean | Patient$labsArgs<ExtArgs>
    prescriptions?: boolean | Patient$prescriptionsArgs<ExtArgs>
    tasks?: boolean | Patient$tasksArgs<ExtArgs>
    dataRequests?: boolean | Patient$dataRequestsArgs<ExtArgs>
    emergencyContacts?: boolean | Patient$emergencyContactsArgs<ExtArgs>
    diagnoses?: boolean | Patient$diagnosesArgs<ExtArgs>
    consents?: boolean | Patient$consentsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    firstNameCipher?: boolean
    lastNameCipher?: boolean
    phoneCipher?: boolean
    emailCipher?: boolean
    insuranceIdCipher?: boolean
    addressCipher?: boolean
    emergencyContactCipher?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    conditionName?: boolean
    diagnosedDate?: boolean
    severity?: boolean
    status?: boolean
    retentionExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    firstNameBlind?: boolean
    lastNameBlind?: boolean
    insuranceIdBlind?: boolean
    clinic?: boolean | Patient$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    firstNameCipher?: boolean
    lastNameCipher?: boolean
    phoneCipher?: boolean
    emailCipher?: boolean
    insuranceIdCipher?: boolean
    addressCipher?: boolean
    emergencyContactCipher?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    conditionName?: boolean
    diagnosedDate?: boolean
    severity?: boolean
    status?: boolean
    retentionExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    firstNameBlind?: boolean
    lastNameBlind?: boolean
    insuranceIdBlind?: boolean
    clinic?: boolean | Patient$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    clinicId?: boolean
    firstNameCipher?: boolean
    lastNameCipher?: boolean
    phoneCipher?: boolean
    emailCipher?: boolean
    insuranceIdCipher?: boolean
    addressCipher?: boolean
    emergencyContactCipher?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    conditionName?: boolean
    diagnosedDate?: boolean
    severity?: boolean
    status?: boolean
    retentionExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    firstNameBlind?: boolean
    lastNameBlind?: boolean
    insuranceIdBlind?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "firstNameCipher" | "lastNameCipher" | "phoneCipher" | "emailCipher" | "insuranceIdCipher" | "addressCipher" | "emergencyContactCipher" | "dateOfBirth" | "gender" | "bloodGroup" | "conditionName" | "diagnosedDate" | "severity" | "status" | "retentionExpiresAt" | "createdAt" | "updatedAt" | "deletedAt" | "firstNameBlind" | "lastNameBlind" | "insuranceIdBlind", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Patient$clinicArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    calls?: boolean | Patient$callsArgs<ExtArgs>
    labs?: boolean | Patient$labsArgs<ExtArgs>
    prescriptions?: boolean | Patient$prescriptionsArgs<ExtArgs>
    tasks?: boolean | Patient$tasksArgs<ExtArgs>
    dataRequests?: boolean | Patient$dataRequestsArgs<ExtArgs>
    emergencyContacts?: boolean | Patient$emergencyContactsArgs<ExtArgs>
    diagnoses?: boolean | Patient$diagnosesArgs<ExtArgs>
    consents?: boolean | Patient$consentsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Patient$clinicArgs<ExtArgs>
  }
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Patient$clinicArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      calls: Prisma.$CallPayload<ExtArgs>[]
      labs: Prisma.$LabPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      dataRequests: Prisma.$DataRequestPayload<ExtArgs>[]
      emergencyContacts: Prisma.$EmergencyContactPayload<ExtArgs>[]
      diagnoses: Prisma.$DiagnosisPayload<ExtArgs>[]
      consents: Prisma.$PatientConsentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string | null
      firstNameCipher: string | null
      lastNameCipher: string | null
      phoneCipher: string | null
      emailCipher: string | null
      insuranceIdCipher: string | null
      addressCipher: string | null
      emergencyContactCipher: string | null
      dateOfBirth: Date | null
      gender: $Enums.Gender | null
      bloodGroup: string | null
      conditionName: string | null
      diagnosedDate: Date | null
      severity: string | null
      status: string | null
      retentionExpiresAt: Date | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
      firstNameBlind: string | null
      lastNameBlind: string | null
      insuranceIdBlind: string | null
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends Patient$clinicArgs<ExtArgs> = {}>(args?: Subset<T, Patient$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    appointments<T extends Patient$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calls<T extends Patient$callsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$callsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labs<T extends Patient$labsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$labsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends Patient$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Patient$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Patient$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dataRequests<T extends Patient$dataRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$dataRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emergencyContacts<T extends Patient$emergencyContactsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$emergencyContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    diagnoses<T extends Patient$diagnosesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$diagnosesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    consents<T extends Patient$consentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$consentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly clinicId: FieldRef<"Patient", 'String'>
    readonly firstNameCipher: FieldRef<"Patient", 'String'>
    readonly lastNameCipher: FieldRef<"Patient", 'String'>
    readonly phoneCipher: FieldRef<"Patient", 'String'>
    readonly emailCipher: FieldRef<"Patient", 'String'>
    readonly insuranceIdCipher: FieldRef<"Patient", 'String'>
    readonly addressCipher: FieldRef<"Patient", 'String'>
    readonly emergencyContactCipher: FieldRef<"Patient", 'String'>
    readonly dateOfBirth: FieldRef<"Patient", 'DateTime'>
    readonly gender: FieldRef<"Patient", 'Gender'>
    readonly bloodGroup: FieldRef<"Patient", 'String'>
    readonly conditionName: FieldRef<"Patient", 'String'>
    readonly diagnosedDate: FieldRef<"Patient", 'DateTime'>
    readonly severity: FieldRef<"Patient", 'String'>
    readonly status: FieldRef<"Patient", 'String'>
    readonly retentionExpiresAt: FieldRef<"Patient", 'DateTime'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
    readonly deletedAt: FieldRef<"Patient", 'DateTime'>
    readonly firstNameBlind: FieldRef<"Patient", 'String'>
    readonly lastNameBlind: FieldRef<"Patient", 'String'>
    readonly insuranceIdBlind: FieldRef<"Patient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data?: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.clinic
   */
  export type Patient$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * Patient.appointments
   */
  export type Patient$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Patient.calls
   */
  export type Patient$callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallInclude<ExtArgs> | null
    where?: CallWhereInput
    orderBy?: CallOrderByWithRelationInput | CallOrderByWithRelationInput[]
    cursor?: CallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallScalarFieldEnum | CallScalarFieldEnum[]
  }

  /**
   * Patient.labs
   */
  export type Patient$labsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    where?: LabWhereInput
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    cursor?: LabWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * Patient.prescriptions
   */
  export type Patient$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Patient.tasks
   */
  export type Patient$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Patient.dataRequests
   */
  export type Patient$dataRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRequest
     */
    select?: DataRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRequest
     */
    omit?: DataRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRequestInclude<ExtArgs> | null
    where?: DataRequestWhereInput
    orderBy?: DataRequestOrderByWithRelationInput | DataRequestOrderByWithRelationInput[]
    cursor?: DataRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataRequestScalarFieldEnum | DataRequestScalarFieldEnum[]
  }

  /**
   * Patient.emergencyContacts
   */
  export type Patient$emergencyContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    where?: EmergencyContactWhereInput
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    cursor?: EmergencyContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * Patient.diagnoses
   */
  export type Patient$diagnosesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    where?: DiagnosisWhereInput
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    cursor?: DiagnosisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Patient.consents
   */
  export type Patient$consentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientConsent
     */
    select?: PatientConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientConsent
     */
    omit?: PatientConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientConsentInclude<ExtArgs> | null
    where?: PatientConsentWhereInput
    orderBy?: PatientConsentOrderByWithRelationInput | PatientConsentOrderByWithRelationInput[]
    cursor?: PatientConsentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientConsentScalarFieldEnum | PatientConsentScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model EmergencyContact
   */

  export type AggregateEmergencyContact = {
    _count: EmergencyContactCountAggregateOutputType | null
    _min: EmergencyContactMinAggregateOutputType | null
    _max: EmergencyContactMaxAggregateOutputType | null
  }

  export type EmergencyContactMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    nameCipher: string | null
    relationship: string | null
    phoneCipher: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmergencyContactMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    nameCipher: string | null
    relationship: string | null
    phoneCipher: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmergencyContactCountAggregateOutputType = {
    id: number
    patientId: number
    nameCipher: number
    relationship: number
    phoneCipher: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmergencyContactMinAggregateInputType = {
    id?: true
    patientId?: true
    nameCipher?: true
    relationship?: true
    phoneCipher?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmergencyContactMaxAggregateInputType = {
    id?: true
    patientId?: true
    nameCipher?: true
    relationship?: true
    phoneCipher?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmergencyContactCountAggregateInputType = {
    id?: true
    patientId?: true
    nameCipher?: true
    relationship?: true
    phoneCipher?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmergencyContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyContact to aggregate.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmergencyContacts
    **/
    _count?: true | EmergencyContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmergencyContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmergencyContactMaxAggregateInputType
  }

  export type GetEmergencyContactAggregateType<T extends EmergencyContactAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergencyContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergencyContact[P]>
      : GetScalarType<T[P], AggregateEmergencyContact[P]>
  }




  export type EmergencyContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyContactWhereInput
    orderBy?: EmergencyContactOrderByWithAggregationInput | EmergencyContactOrderByWithAggregationInput[]
    by: EmergencyContactScalarFieldEnum[] | EmergencyContactScalarFieldEnum
    having?: EmergencyContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmergencyContactCountAggregateInputType | true
    _min?: EmergencyContactMinAggregateInputType
    _max?: EmergencyContactMaxAggregateInputType
  }

  export type EmergencyContactGroupByOutputType = {
    id: string
    patientId: string | null
    nameCipher: string | null
    relationship: string | null
    phoneCipher: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: EmergencyContactCountAggregateOutputType | null
    _min: EmergencyContactMinAggregateOutputType | null
    _max: EmergencyContactMaxAggregateOutputType | null
  }

  type GetEmergencyContactGroupByPayload<T extends EmergencyContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmergencyContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmergencyContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmergencyContactGroupByOutputType[P]>
            : GetScalarType<T[P], EmergencyContactGroupByOutputType[P]>
        }
      >
    >


  export type EmergencyContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    nameCipher?: boolean
    relationship?: boolean
    phoneCipher?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | EmergencyContact$patientArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyContact"]>

  export type EmergencyContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    nameCipher?: boolean
    relationship?: boolean
    phoneCipher?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | EmergencyContact$patientArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyContact"]>

  export type EmergencyContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    nameCipher?: boolean
    relationship?: boolean
    phoneCipher?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | EmergencyContact$patientArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyContact"]>

  export type EmergencyContactSelectScalar = {
    id?: boolean
    patientId?: boolean
    nameCipher?: boolean
    relationship?: boolean
    phoneCipher?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmergencyContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "nameCipher" | "relationship" | "phoneCipher" | "createdAt" | "updatedAt", ExtArgs["result"]["emergencyContact"]>
  export type EmergencyContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | EmergencyContact$patientArgs<ExtArgs>
  }
  export type EmergencyContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | EmergencyContact$patientArgs<ExtArgs>
  }
  export type EmergencyContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | EmergencyContact$patientArgs<ExtArgs>
  }

  export type $EmergencyContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmergencyContact"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      nameCipher: string | null
      relationship: string | null
      phoneCipher: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["emergencyContact"]>
    composites: {}
  }

  type EmergencyContactGetPayload<S extends boolean | null | undefined | EmergencyContactDefaultArgs> = $Result.GetResult<Prisma.$EmergencyContactPayload, S>

  type EmergencyContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmergencyContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmergencyContactCountAggregateInputType | true
    }

  export interface EmergencyContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmergencyContact'], meta: { name: 'EmergencyContact' } }
    /**
     * Find zero or one EmergencyContact that matches the filter.
     * @param {EmergencyContactFindUniqueArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmergencyContactFindUniqueArgs>(args: SelectSubset<T, EmergencyContactFindUniqueArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmergencyContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmergencyContactFindUniqueOrThrowArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmergencyContactFindUniqueOrThrowArgs>(args: SelectSubset<T, EmergencyContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindFirstArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmergencyContactFindFirstArgs>(args?: SelectSubset<T, EmergencyContactFindFirstArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindFirstOrThrowArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmergencyContactFindFirstOrThrowArgs>(args?: SelectSubset<T, EmergencyContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmergencyContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmergencyContacts
     * const emergencyContacts = await prisma.emergencyContact.findMany()
     * 
     * // Get first 10 EmergencyContacts
     * const emergencyContacts = await prisma.emergencyContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergencyContactWithIdOnly = await prisma.emergencyContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmergencyContactFindManyArgs>(args?: SelectSubset<T, EmergencyContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmergencyContact.
     * @param {EmergencyContactCreateArgs} args - Arguments to create a EmergencyContact.
     * @example
     * // Create one EmergencyContact
     * const EmergencyContact = await prisma.emergencyContact.create({
     *   data: {
     *     // ... data to create a EmergencyContact
     *   }
     * })
     * 
     */
    create<T extends EmergencyContactCreateArgs>(args: SelectSubset<T, EmergencyContactCreateArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmergencyContacts.
     * @param {EmergencyContactCreateManyArgs} args - Arguments to create many EmergencyContacts.
     * @example
     * // Create many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmergencyContactCreateManyArgs>(args?: SelectSubset<T, EmergencyContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmergencyContacts and returns the data saved in the database.
     * @param {EmergencyContactCreateManyAndReturnArgs} args - Arguments to create many EmergencyContacts.
     * @example
     * // Create many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmergencyContacts and only return the `id`
     * const emergencyContactWithIdOnly = await prisma.emergencyContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmergencyContactCreateManyAndReturnArgs>(args?: SelectSubset<T, EmergencyContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmergencyContact.
     * @param {EmergencyContactDeleteArgs} args - Arguments to delete one EmergencyContact.
     * @example
     * // Delete one EmergencyContact
     * const EmergencyContact = await prisma.emergencyContact.delete({
     *   where: {
     *     // ... filter to delete one EmergencyContact
     *   }
     * })
     * 
     */
    delete<T extends EmergencyContactDeleteArgs>(args: SelectSubset<T, EmergencyContactDeleteArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmergencyContact.
     * @param {EmergencyContactUpdateArgs} args - Arguments to update one EmergencyContact.
     * @example
     * // Update one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmergencyContactUpdateArgs>(args: SelectSubset<T, EmergencyContactUpdateArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmergencyContacts.
     * @param {EmergencyContactDeleteManyArgs} args - Arguments to filter EmergencyContacts to delete.
     * @example
     * // Delete a few EmergencyContacts
     * const { count } = await prisma.emergencyContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmergencyContactDeleteManyArgs>(args?: SelectSubset<T, EmergencyContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmergencyContactUpdateManyArgs>(args: SelectSubset<T, EmergencyContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyContacts and returns the data updated in the database.
     * @param {EmergencyContactUpdateManyAndReturnArgs} args - Arguments to update many EmergencyContacts.
     * @example
     * // Update many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmergencyContacts and only return the `id`
     * const emergencyContactWithIdOnly = await prisma.emergencyContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmergencyContactUpdateManyAndReturnArgs>(args: SelectSubset<T, EmergencyContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmergencyContact.
     * @param {EmergencyContactUpsertArgs} args - Arguments to update or create a EmergencyContact.
     * @example
     * // Update or create a EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.upsert({
     *   create: {
     *     // ... data to create a EmergencyContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmergencyContact we want to update
     *   }
     * })
     */
    upsert<T extends EmergencyContactUpsertArgs>(args: SelectSubset<T, EmergencyContactUpsertArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactCountArgs} args - Arguments to filter EmergencyContacts to count.
     * @example
     * // Count the number of EmergencyContacts
     * const count = await prisma.emergencyContact.count({
     *   where: {
     *     // ... the filter for the EmergencyContacts we want to count
     *   }
     * })
    **/
    count<T extends EmergencyContactCountArgs>(
      args?: Subset<T, EmergencyContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmergencyContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmergencyContactAggregateArgs>(args: Subset<T, EmergencyContactAggregateArgs>): Prisma.PrismaPromise<GetEmergencyContactAggregateType<T>>

    /**
     * Group by EmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmergencyContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmergencyContactGroupByArgs['orderBy'] }
        : { orderBy?: EmergencyContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmergencyContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergencyContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmergencyContact model
   */
  readonly fields: EmergencyContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmergencyContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmergencyContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends EmergencyContact$patientArgs<ExtArgs> = {}>(args?: Subset<T, EmergencyContact$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmergencyContact model
   */
  interface EmergencyContactFieldRefs {
    readonly id: FieldRef<"EmergencyContact", 'String'>
    readonly patientId: FieldRef<"EmergencyContact", 'String'>
    readonly nameCipher: FieldRef<"EmergencyContact", 'String'>
    readonly relationship: FieldRef<"EmergencyContact", 'String'>
    readonly phoneCipher: FieldRef<"EmergencyContact", 'String'>
    readonly createdAt: FieldRef<"EmergencyContact", 'DateTime'>
    readonly updatedAt: FieldRef<"EmergencyContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmergencyContact findUnique
   */
  export type EmergencyContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact findUniqueOrThrow
   */
  export type EmergencyContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact findFirst
   */
  export type EmergencyContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyContacts.
     */
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact findFirstOrThrow
   */
  export type EmergencyContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyContacts.
     */
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact findMany
   */
  export type EmergencyContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContacts to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact create
   */
  export type EmergencyContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to create a EmergencyContact.
     */
    data?: XOR<EmergencyContactCreateInput, EmergencyContactUncheckedCreateInput>
  }

  /**
   * EmergencyContact createMany
   */
  export type EmergencyContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmergencyContacts.
     */
    data: EmergencyContactCreateManyInput | EmergencyContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmergencyContact createManyAndReturn
   */
  export type EmergencyContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * The data used to create many EmergencyContacts.
     */
    data: EmergencyContactCreateManyInput | EmergencyContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmergencyContact update
   */
  export type EmergencyContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to update a EmergencyContact.
     */
    data: XOR<EmergencyContactUpdateInput, EmergencyContactUncheckedUpdateInput>
    /**
     * Choose, which EmergencyContact to update.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact updateMany
   */
  export type EmergencyContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmergencyContacts.
     */
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyContacts to update
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to update.
     */
    limit?: number
  }

  /**
   * EmergencyContact updateManyAndReturn
   */
  export type EmergencyContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * The data used to update EmergencyContacts.
     */
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyContacts to update
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmergencyContact upsert
   */
  export type EmergencyContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The filter to search for the EmergencyContact to update in case it exists.
     */
    where: EmergencyContactWhereUniqueInput
    /**
     * In case the EmergencyContact found by the `where` argument doesn't exist, create a new EmergencyContact with this data.
     */
    create: XOR<EmergencyContactCreateInput, EmergencyContactUncheckedCreateInput>
    /**
     * In case the EmergencyContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmergencyContactUpdateInput, EmergencyContactUncheckedUpdateInput>
  }

  /**
   * EmergencyContact delete
   */
  export type EmergencyContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter which EmergencyContact to delete.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact deleteMany
   */
  export type EmergencyContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyContacts to delete
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to delete.
     */
    limit?: number
  }

  /**
   * EmergencyContact.patient
   */
  export type EmergencyContact$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * EmergencyContact without action
   */
  export type EmergencyContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
  }


  /**
   * Model StaffPersonalInfo
   */

  export type AggregateStaffPersonalInfo = {
    _count: StaffPersonalInfoCountAggregateOutputType | null
    _min: StaffPersonalInfoMinAggregateOutputType | null
    _max: StaffPersonalInfoMaxAggregateOutputType | null
  }

  export type StaffPersonalInfoMinAggregateOutputType = {
    id: string | null
    doctorId: string | null
    dateOfBirth: Date | null
    phoneCipher: string | null
    addressCipher: string | null
    stateProvince: string | null
    postalCode: string | null
    country: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    emergencyContactRelationship: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffPersonalInfoMaxAggregateOutputType = {
    id: string | null
    doctorId: string | null
    dateOfBirth: Date | null
    phoneCipher: string | null
    addressCipher: string | null
    stateProvince: string | null
    postalCode: string | null
    country: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    emergencyContactRelationship: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffPersonalInfoCountAggregateOutputType = {
    id: number
    doctorId: number
    dateOfBirth: number
    phoneCipher: number
    addressCipher: number
    stateProvince: number
    postalCode: number
    country: number
    emergencyContactName: number
    emergencyContactPhone: number
    emergencyContactRelationship: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffPersonalInfoMinAggregateInputType = {
    id?: true
    doctorId?: true
    dateOfBirth?: true
    phoneCipher?: true
    addressCipher?: true
    stateProvince?: true
    postalCode?: true
    country?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    emergencyContactRelationship?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffPersonalInfoMaxAggregateInputType = {
    id?: true
    doctorId?: true
    dateOfBirth?: true
    phoneCipher?: true
    addressCipher?: true
    stateProvince?: true
    postalCode?: true
    country?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    emergencyContactRelationship?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffPersonalInfoCountAggregateInputType = {
    id?: true
    doctorId?: true
    dateOfBirth?: true
    phoneCipher?: true
    addressCipher?: true
    stateProvince?: true
    postalCode?: true
    country?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    emergencyContactRelationship?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffPersonalInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffPersonalInfo to aggregate.
     */
    where?: StaffPersonalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffPersonalInfos to fetch.
     */
    orderBy?: StaffPersonalInfoOrderByWithRelationInput | StaffPersonalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffPersonalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffPersonalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffPersonalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffPersonalInfos
    **/
    _count?: true | StaffPersonalInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffPersonalInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffPersonalInfoMaxAggregateInputType
  }

  export type GetStaffPersonalInfoAggregateType<T extends StaffPersonalInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffPersonalInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffPersonalInfo[P]>
      : GetScalarType<T[P], AggregateStaffPersonalInfo[P]>
  }




  export type StaffPersonalInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffPersonalInfoWhereInput
    orderBy?: StaffPersonalInfoOrderByWithAggregationInput | StaffPersonalInfoOrderByWithAggregationInput[]
    by: StaffPersonalInfoScalarFieldEnum[] | StaffPersonalInfoScalarFieldEnum
    having?: StaffPersonalInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffPersonalInfoCountAggregateInputType | true
    _min?: StaffPersonalInfoMinAggregateInputType
    _max?: StaffPersonalInfoMaxAggregateInputType
  }

  export type StaffPersonalInfoGroupByOutputType = {
    id: string
    doctorId: string | null
    dateOfBirth: Date | null
    phoneCipher: string | null
    addressCipher: string | null
    stateProvince: string | null
    postalCode: string | null
    country: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    emergencyContactRelationship: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: StaffPersonalInfoCountAggregateOutputType | null
    _min: StaffPersonalInfoMinAggregateOutputType | null
    _max: StaffPersonalInfoMaxAggregateOutputType | null
  }

  type GetStaffPersonalInfoGroupByPayload<T extends StaffPersonalInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffPersonalInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffPersonalInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffPersonalInfoGroupByOutputType[P]>
            : GetScalarType<T[P], StaffPersonalInfoGroupByOutputType[P]>
        }
      >
    >


  export type StaffPersonalInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    dateOfBirth?: boolean
    phoneCipher?: boolean
    addressCipher?: boolean
    stateProvince?: boolean
    postalCode?: boolean
    country?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    emergencyContactRelationship?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | StaffPersonalInfo$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["staffPersonalInfo"]>

  export type StaffPersonalInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    dateOfBirth?: boolean
    phoneCipher?: boolean
    addressCipher?: boolean
    stateProvince?: boolean
    postalCode?: boolean
    country?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    emergencyContactRelationship?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | StaffPersonalInfo$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["staffPersonalInfo"]>

  export type StaffPersonalInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    dateOfBirth?: boolean
    phoneCipher?: boolean
    addressCipher?: boolean
    stateProvince?: boolean
    postalCode?: boolean
    country?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    emergencyContactRelationship?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | StaffPersonalInfo$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["staffPersonalInfo"]>

  export type StaffPersonalInfoSelectScalar = {
    id?: boolean
    doctorId?: boolean
    dateOfBirth?: boolean
    phoneCipher?: boolean
    addressCipher?: boolean
    stateProvince?: boolean
    postalCode?: boolean
    country?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    emergencyContactRelationship?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffPersonalInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "doctorId" | "dateOfBirth" | "phoneCipher" | "addressCipher" | "stateProvince" | "postalCode" | "country" | "emergencyContactName" | "emergencyContactPhone" | "emergencyContactRelationship" | "createdAt" | "updatedAt", ExtArgs["result"]["staffPersonalInfo"]>
  export type StaffPersonalInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | StaffPersonalInfo$doctorArgs<ExtArgs>
  }
  export type StaffPersonalInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | StaffPersonalInfo$doctorArgs<ExtArgs>
  }
  export type StaffPersonalInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | StaffPersonalInfo$doctorArgs<ExtArgs>
  }

  export type $StaffPersonalInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffPersonalInfo"
    objects: {
      doctor: Prisma.$DoctorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      doctorId: string | null
      dateOfBirth: Date | null
      phoneCipher: string | null
      addressCipher: string | null
      stateProvince: string | null
      postalCode: string | null
      country: string | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      emergencyContactRelationship: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["staffPersonalInfo"]>
    composites: {}
  }

  type StaffPersonalInfoGetPayload<S extends boolean | null | undefined | StaffPersonalInfoDefaultArgs> = $Result.GetResult<Prisma.$StaffPersonalInfoPayload, S>

  type StaffPersonalInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffPersonalInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffPersonalInfoCountAggregateInputType | true
    }

  export interface StaffPersonalInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffPersonalInfo'], meta: { name: 'StaffPersonalInfo' } }
    /**
     * Find zero or one StaffPersonalInfo that matches the filter.
     * @param {StaffPersonalInfoFindUniqueArgs} args - Arguments to find a StaffPersonalInfo
     * @example
     * // Get one StaffPersonalInfo
     * const staffPersonalInfo = await prisma.staffPersonalInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffPersonalInfoFindUniqueArgs>(args: SelectSubset<T, StaffPersonalInfoFindUniqueArgs<ExtArgs>>): Prisma__StaffPersonalInfoClient<$Result.GetResult<Prisma.$StaffPersonalInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StaffPersonalInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffPersonalInfoFindUniqueOrThrowArgs} args - Arguments to find a StaffPersonalInfo
     * @example
     * // Get one StaffPersonalInfo
     * const staffPersonalInfo = await prisma.staffPersonalInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffPersonalInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffPersonalInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffPersonalInfoClient<$Result.GetResult<Prisma.$StaffPersonalInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffPersonalInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffPersonalInfoFindFirstArgs} args - Arguments to find a StaffPersonalInfo
     * @example
     * // Get one StaffPersonalInfo
     * const staffPersonalInfo = await prisma.staffPersonalInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffPersonalInfoFindFirstArgs>(args?: SelectSubset<T, StaffPersonalInfoFindFirstArgs<ExtArgs>>): Prisma__StaffPersonalInfoClient<$Result.GetResult<Prisma.$StaffPersonalInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffPersonalInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffPersonalInfoFindFirstOrThrowArgs} args - Arguments to find a StaffPersonalInfo
     * @example
     * // Get one StaffPersonalInfo
     * const staffPersonalInfo = await prisma.staffPersonalInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffPersonalInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffPersonalInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffPersonalInfoClient<$Result.GetResult<Prisma.$StaffPersonalInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StaffPersonalInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffPersonalInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffPersonalInfos
     * const staffPersonalInfos = await prisma.staffPersonalInfo.findMany()
     * 
     * // Get first 10 StaffPersonalInfos
     * const staffPersonalInfos = await prisma.staffPersonalInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffPersonalInfoWithIdOnly = await prisma.staffPersonalInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffPersonalInfoFindManyArgs>(args?: SelectSubset<T, StaffPersonalInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPersonalInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StaffPersonalInfo.
     * @param {StaffPersonalInfoCreateArgs} args - Arguments to create a StaffPersonalInfo.
     * @example
     * // Create one StaffPersonalInfo
     * const StaffPersonalInfo = await prisma.staffPersonalInfo.create({
     *   data: {
     *     // ... data to create a StaffPersonalInfo
     *   }
     * })
     * 
     */
    create<T extends StaffPersonalInfoCreateArgs>(args: SelectSubset<T, StaffPersonalInfoCreateArgs<ExtArgs>>): Prisma__StaffPersonalInfoClient<$Result.GetResult<Prisma.$StaffPersonalInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StaffPersonalInfos.
     * @param {StaffPersonalInfoCreateManyArgs} args - Arguments to create many StaffPersonalInfos.
     * @example
     * // Create many StaffPersonalInfos
     * const staffPersonalInfo = await prisma.staffPersonalInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffPersonalInfoCreateManyArgs>(args?: SelectSubset<T, StaffPersonalInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StaffPersonalInfos and returns the data saved in the database.
     * @param {StaffPersonalInfoCreateManyAndReturnArgs} args - Arguments to create many StaffPersonalInfos.
     * @example
     * // Create many StaffPersonalInfos
     * const staffPersonalInfo = await prisma.staffPersonalInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StaffPersonalInfos and only return the `id`
     * const staffPersonalInfoWithIdOnly = await prisma.staffPersonalInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffPersonalInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffPersonalInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPersonalInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StaffPersonalInfo.
     * @param {StaffPersonalInfoDeleteArgs} args - Arguments to delete one StaffPersonalInfo.
     * @example
     * // Delete one StaffPersonalInfo
     * const StaffPersonalInfo = await prisma.staffPersonalInfo.delete({
     *   where: {
     *     // ... filter to delete one StaffPersonalInfo
     *   }
     * })
     * 
     */
    delete<T extends StaffPersonalInfoDeleteArgs>(args: SelectSubset<T, StaffPersonalInfoDeleteArgs<ExtArgs>>): Prisma__StaffPersonalInfoClient<$Result.GetResult<Prisma.$StaffPersonalInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StaffPersonalInfo.
     * @param {StaffPersonalInfoUpdateArgs} args - Arguments to update one StaffPersonalInfo.
     * @example
     * // Update one StaffPersonalInfo
     * const staffPersonalInfo = await prisma.staffPersonalInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffPersonalInfoUpdateArgs>(args: SelectSubset<T, StaffPersonalInfoUpdateArgs<ExtArgs>>): Prisma__StaffPersonalInfoClient<$Result.GetResult<Prisma.$StaffPersonalInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StaffPersonalInfos.
     * @param {StaffPersonalInfoDeleteManyArgs} args - Arguments to filter StaffPersonalInfos to delete.
     * @example
     * // Delete a few StaffPersonalInfos
     * const { count } = await prisma.staffPersonalInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffPersonalInfoDeleteManyArgs>(args?: SelectSubset<T, StaffPersonalInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffPersonalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffPersonalInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffPersonalInfos
     * const staffPersonalInfo = await prisma.staffPersonalInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffPersonalInfoUpdateManyArgs>(args: SelectSubset<T, StaffPersonalInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffPersonalInfos and returns the data updated in the database.
     * @param {StaffPersonalInfoUpdateManyAndReturnArgs} args - Arguments to update many StaffPersonalInfos.
     * @example
     * // Update many StaffPersonalInfos
     * const staffPersonalInfo = await prisma.staffPersonalInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StaffPersonalInfos and only return the `id`
     * const staffPersonalInfoWithIdOnly = await prisma.staffPersonalInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffPersonalInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffPersonalInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPersonalInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StaffPersonalInfo.
     * @param {StaffPersonalInfoUpsertArgs} args - Arguments to update or create a StaffPersonalInfo.
     * @example
     * // Update or create a StaffPersonalInfo
     * const staffPersonalInfo = await prisma.staffPersonalInfo.upsert({
     *   create: {
     *     // ... data to create a StaffPersonalInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffPersonalInfo we want to update
     *   }
     * })
     */
    upsert<T extends StaffPersonalInfoUpsertArgs>(args: SelectSubset<T, StaffPersonalInfoUpsertArgs<ExtArgs>>): Prisma__StaffPersonalInfoClient<$Result.GetResult<Prisma.$StaffPersonalInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StaffPersonalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffPersonalInfoCountArgs} args - Arguments to filter StaffPersonalInfos to count.
     * @example
     * // Count the number of StaffPersonalInfos
     * const count = await prisma.staffPersonalInfo.count({
     *   where: {
     *     // ... the filter for the StaffPersonalInfos we want to count
     *   }
     * })
    **/
    count<T extends StaffPersonalInfoCountArgs>(
      args?: Subset<T, StaffPersonalInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffPersonalInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffPersonalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffPersonalInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffPersonalInfoAggregateArgs>(args: Subset<T, StaffPersonalInfoAggregateArgs>): Prisma.PrismaPromise<GetStaffPersonalInfoAggregateType<T>>

    /**
     * Group by StaffPersonalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffPersonalInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffPersonalInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffPersonalInfoGroupByArgs['orderBy'] }
        : { orderBy?: StaffPersonalInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffPersonalInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffPersonalInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffPersonalInfo model
   */
  readonly fields: StaffPersonalInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffPersonalInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffPersonalInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends StaffPersonalInfo$doctorArgs<ExtArgs> = {}>(args?: Subset<T, StaffPersonalInfo$doctorArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaffPersonalInfo model
   */
  interface StaffPersonalInfoFieldRefs {
    readonly id: FieldRef<"StaffPersonalInfo", 'String'>
    readonly doctorId: FieldRef<"StaffPersonalInfo", 'String'>
    readonly dateOfBirth: FieldRef<"StaffPersonalInfo", 'DateTime'>
    readonly phoneCipher: FieldRef<"StaffPersonalInfo", 'String'>
    readonly addressCipher: FieldRef<"StaffPersonalInfo", 'String'>
    readonly stateProvince: FieldRef<"StaffPersonalInfo", 'String'>
    readonly postalCode: FieldRef<"StaffPersonalInfo", 'String'>
    readonly country: FieldRef<"StaffPersonalInfo", 'String'>
    readonly emergencyContactName: FieldRef<"StaffPersonalInfo", 'String'>
    readonly emergencyContactPhone: FieldRef<"StaffPersonalInfo", 'String'>
    readonly emergencyContactRelationship: FieldRef<"StaffPersonalInfo", 'String'>
    readonly createdAt: FieldRef<"StaffPersonalInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"StaffPersonalInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StaffPersonalInfo findUnique
   */
  export type StaffPersonalInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPersonalInfo
     */
    select?: StaffPersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffPersonalInfo
     */
    omit?: StaffPersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffPersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which StaffPersonalInfo to fetch.
     */
    where: StaffPersonalInfoWhereUniqueInput
  }

  /**
   * StaffPersonalInfo findUniqueOrThrow
   */
  export type StaffPersonalInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPersonalInfo
     */
    select?: StaffPersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffPersonalInfo
     */
    omit?: StaffPersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffPersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which StaffPersonalInfo to fetch.
     */
    where: StaffPersonalInfoWhereUniqueInput
  }

  /**
   * StaffPersonalInfo findFirst
   */
  export type StaffPersonalInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPersonalInfo
     */
    select?: StaffPersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffPersonalInfo
     */
    omit?: StaffPersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffPersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which StaffPersonalInfo to fetch.
     */
    where?: StaffPersonalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffPersonalInfos to fetch.
     */
    orderBy?: StaffPersonalInfoOrderByWithRelationInput | StaffPersonalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffPersonalInfos.
     */
    cursor?: StaffPersonalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffPersonalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffPersonalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffPersonalInfos.
     */
    distinct?: StaffPersonalInfoScalarFieldEnum | StaffPersonalInfoScalarFieldEnum[]
  }

  /**
   * StaffPersonalInfo findFirstOrThrow
   */
  export type StaffPersonalInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPersonalInfo
     */
    select?: StaffPersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffPersonalInfo
     */
    omit?: StaffPersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffPersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which StaffPersonalInfo to fetch.
     */
    where?: StaffPersonalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffPersonalInfos to fetch.
     */
    orderBy?: StaffPersonalInfoOrderByWithRelationInput | StaffPersonalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffPersonalInfos.
     */
    cursor?: StaffPersonalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffPersonalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffPersonalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffPersonalInfos.
     */
    distinct?: StaffPersonalInfoScalarFieldEnum | StaffPersonalInfoScalarFieldEnum[]
  }

  /**
   * StaffPersonalInfo findMany
   */
  export type StaffPersonalInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPersonalInfo
     */
    select?: StaffPersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffPersonalInfo
     */
    omit?: StaffPersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffPersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which StaffPersonalInfos to fetch.
     */
    where?: StaffPersonalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffPersonalInfos to fetch.
     */
    orderBy?: StaffPersonalInfoOrderByWithRelationInput | StaffPersonalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffPersonalInfos.
     */
    cursor?: StaffPersonalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffPersonalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffPersonalInfos.
     */
    skip?: number
    distinct?: StaffPersonalInfoScalarFieldEnum | StaffPersonalInfoScalarFieldEnum[]
  }

  /**
   * StaffPersonalInfo create
   */
  export type StaffPersonalInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPersonalInfo
     */
    select?: StaffPersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffPersonalInfo
     */
    omit?: StaffPersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffPersonalInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffPersonalInfo.
     */
    data?: XOR<StaffPersonalInfoCreateInput, StaffPersonalInfoUncheckedCreateInput>
  }

  /**
   * StaffPersonalInfo createMany
   */
  export type StaffPersonalInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffPersonalInfos.
     */
    data: StaffPersonalInfoCreateManyInput | StaffPersonalInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StaffPersonalInfo createManyAndReturn
   */
  export type StaffPersonalInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPersonalInfo
     */
    select?: StaffPersonalInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffPersonalInfo
     */
    omit?: StaffPersonalInfoOmit<ExtArgs> | null
    /**
     * The data used to create many StaffPersonalInfos.
     */
    data: StaffPersonalInfoCreateManyInput | StaffPersonalInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffPersonalInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffPersonalInfo update
   */
  export type StaffPersonalInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPersonalInfo
     */
    select?: StaffPersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffPersonalInfo
     */
    omit?: StaffPersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffPersonalInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffPersonalInfo.
     */
    data: XOR<StaffPersonalInfoUpdateInput, StaffPersonalInfoUncheckedUpdateInput>
    /**
     * Choose, which StaffPersonalInfo to update.
     */
    where: StaffPersonalInfoWhereUniqueInput
  }

  /**
   * StaffPersonalInfo updateMany
   */
  export type StaffPersonalInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffPersonalInfos.
     */
    data: XOR<StaffPersonalInfoUpdateManyMutationInput, StaffPersonalInfoUncheckedUpdateManyInput>
    /**
     * Filter which StaffPersonalInfos to update
     */
    where?: StaffPersonalInfoWhereInput
    /**
     * Limit how many StaffPersonalInfos to update.
     */
    limit?: number
  }

  /**
   * StaffPersonalInfo updateManyAndReturn
   */
  export type StaffPersonalInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPersonalInfo
     */
    select?: StaffPersonalInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffPersonalInfo
     */
    omit?: StaffPersonalInfoOmit<ExtArgs> | null
    /**
     * The data used to update StaffPersonalInfos.
     */
    data: XOR<StaffPersonalInfoUpdateManyMutationInput, StaffPersonalInfoUncheckedUpdateManyInput>
    /**
     * Filter which StaffPersonalInfos to update
     */
    where?: StaffPersonalInfoWhereInput
    /**
     * Limit how many StaffPersonalInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffPersonalInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffPersonalInfo upsert
   */
  export type StaffPersonalInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPersonalInfo
     */
    select?: StaffPersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffPersonalInfo
     */
    omit?: StaffPersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffPersonalInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffPersonalInfo to update in case it exists.
     */
    where: StaffPersonalInfoWhereUniqueInput
    /**
     * In case the StaffPersonalInfo found by the `where` argument doesn't exist, create a new StaffPersonalInfo with this data.
     */
    create: XOR<StaffPersonalInfoCreateInput, StaffPersonalInfoUncheckedCreateInput>
    /**
     * In case the StaffPersonalInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffPersonalInfoUpdateInput, StaffPersonalInfoUncheckedUpdateInput>
  }

  /**
   * StaffPersonalInfo delete
   */
  export type StaffPersonalInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPersonalInfo
     */
    select?: StaffPersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffPersonalInfo
     */
    omit?: StaffPersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffPersonalInfoInclude<ExtArgs> | null
    /**
     * Filter which StaffPersonalInfo to delete.
     */
    where: StaffPersonalInfoWhereUniqueInput
  }

  /**
   * StaffPersonalInfo deleteMany
   */
  export type StaffPersonalInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffPersonalInfos to delete
     */
    where?: StaffPersonalInfoWhereInput
    /**
     * Limit how many StaffPersonalInfos to delete.
     */
    limit?: number
  }

  /**
   * StaffPersonalInfo.doctor
   */
  export type StaffPersonalInfo$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * StaffPersonalInfo without action
   */
  export type StaffPersonalInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPersonalInfo
     */
    select?: StaffPersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffPersonalInfo
     */
    omit?: StaffPersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffPersonalInfoInclude<ExtArgs> | null
  }


  /**
   * Model StaffEmploymentInfo
   */

  export type AggregateStaffEmploymentInfo = {
    _count: StaffEmploymentInfoCountAggregateOutputType | null
    _avg: StaffEmploymentInfoAvgAggregateOutputType | null
    _sum: StaffEmploymentInfoSumAggregateOutputType | null
    _min: StaffEmploymentInfoMinAggregateOutputType | null
    _max: StaffEmploymentInfoMaxAggregateOutputType | null
  }

  export type StaffEmploymentInfoAvgAggregateOutputType = {
    weeklyHours: number | null
  }

  export type StaffEmploymentInfoSumAggregateOutputType = {
    weeklyHours: number | null
  }

  export type StaffEmploymentInfoMinAggregateOutputType = {
    id: string | null
    doctorId: string | null
    employeeId: string | null
    department: $Enums.Department | null
    position: string | null
    reportingToId: string | null
    joinDate: Date | null
    employmentType: $Enums.EmploymentType | null
    workSchedule: string | null
    weeklyHours: number | null
    salaryCipher: string | null
    employmentStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffEmploymentInfoMaxAggregateOutputType = {
    id: string | null
    doctorId: string | null
    employeeId: string | null
    department: $Enums.Department | null
    position: string | null
    reportingToId: string | null
    joinDate: Date | null
    employmentType: $Enums.EmploymentType | null
    workSchedule: string | null
    weeklyHours: number | null
    salaryCipher: string | null
    employmentStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffEmploymentInfoCountAggregateOutputType = {
    id: number
    doctorId: number
    employeeId: number
    department: number
    position: number
    reportingToId: number
    joinDate: number
    employmentType: number
    workSchedule: number
    weeklyHours: number
    salaryCipher: number
    employmentStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffEmploymentInfoAvgAggregateInputType = {
    weeklyHours?: true
  }

  export type StaffEmploymentInfoSumAggregateInputType = {
    weeklyHours?: true
  }

  export type StaffEmploymentInfoMinAggregateInputType = {
    id?: true
    doctorId?: true
    employeeId?: true
    department?: true
    position?: true
    reportingToId?: true
    joinDate?: true
    employmentType?: true
    workSchedule?: true
    weeklyHours?: true
    salaryCipher?: true
    employmentStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffEmploymentInfoMaxAggregateInputType = {
    id?: true
    doctorId?: true
    employeeId?: true
    department?: true
    position?: true
    reportingToId?: true
    joinDate?: true
    employmentType?: true
    workSchedule?: true
    weeklyHours?: true
    salaryCipher?: true
    employmentStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffEmploymentInfoCountAggregateInputType = {
    id?: true
    doctorId?: true
    employeeId?: true
    department?: true
    position?: true
    reportingToId?: true
    joinDate?: true
    employmentType?: true
    workSchedule?: true
    weeklyHours?: true
    salaryCipher?: true
    employmentStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffEmploymentInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffEmploymentInfo to aggregate.
     */
    where?: StaffEmploymentInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffEmploymentInfos to fetch.
     */
    orderBy?: StaffEmploymentInfoOrderByWithRelationInput | StaffEmploymentInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffEmploymentInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffEmploymentInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffEmploymentInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffEmploymentInfos
    **/
    _count?: true | StaffEmploymentInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaffEmploymentInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaffEmploymentInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffEmploymentInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffEmploymentInfoMaxAggregateInputType
  }

  export type GetStaffEmploymentInfoAggregateType<T extends StaffEmploymentInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffEmploymentInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffEmploymentInfo[P]>
      : GetScalarType<T[P], AggregateStaffEmploymentInfo[P]>
  }




  export type StaffEmploymentInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffEmploymentInfoWhereInput
    orderBy?: StaffEmploymentInfoOrderByWithAggregationInput | StaffEmploymentInfoOrderByWithAggregationInput[]
    by: StaffEmploymentInfoScalarFieldEnum[] | StaffEmploymentInfoScalarFieldEnum
    having?: StaffEmploymentInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffEmploymentInfoCountAggregateInputType | true
    _avg?: StaffEmploymentInfoAvgAggregateInputType
    _sum?: StaffEmploymentInfoSumAggregateInputType
    _min?: StaffEmploymentInfoMinAggregateInputType
    _max?: StaffEmploymentInfoMaxAggregateInputType
  }

  export type StaffEmploymentInfoGroupByOutputType = {
    id: string
    doctorId: string | null
    employeeId: string | null
    department: $Enums.Department | null
    position: string | null
    reportingToId: string | null
    joinDate: Date | null
    employmentType: $Enums.EmploymentType | null
    workSchedule: string | null
    weeklyHours: number | null
    salaryCipher: string | null
    employmentStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: StaffEmploymentInfoCountAggregateOutputType | null
    _avg: StaffEmploymentInfoAvgAggregateOutputType | null
    _sum: StaffEmploymentInfoSumAggregateOutputType | null
    _min: StaffEmploymentInfoMinAggregateOutputType | null
    _max: StaffEmploymentInfoMaxAggregateOutputType | null
  }

  type GetStaffEmploymentInfoGroupByPayload<T extends StaffEmploymentInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffEmploymentInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffEmploymentInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffEmploymentInfoGroupByOutputType[P]>
            : GetScalarType<T[P], StaffEmploymentInfoGroupByOutputType[P]>
        }
      >
    >


  export type StaffEmploymentInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    employeeId?: boolean
    department?: boolean
    position?: boolean
    reportingToId?: boolean
    joinDate?: boolean
    employmentType?: boolean
    workSchedule?: boolean
    weeklyHours?: boolean
    salaryCipher?: boolean
    employmentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | StaffEmploymentInfo$doctorArgs<ExtArgs>
    reportingTo?: boolean | StaffEmploymentInfo$reportingToArgs<ExtArgs>
  }, ExtArgs["result"]["staffEmploymentInfo"]>

  export type StaffEmploymentInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    employeeId?: boolean
    department?: boolean
    position?: boolean
    reportingToId?: boolean
    joinDate?: boolean
    employmentType?: boolean
    workSchedule?: boolean
    weeklyHours?: boolean
    salaryCipher?: boolean
    employmentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | StaffEmploymentInfo$doctorArgs<ExtArgs>
    reportingTo?: boolean | StaffEmploymentInfo$reportingToArgs<ExtArgs>
  }, ExtArgs["result"]["staffEmploymentInfo"]>

  export type StaffEmploymentInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    employeeId?: boolean
    department?: boolean
    position?: boolean
    reportingToId?: boolean
    joinDate?: boolean
    employmentType?: boolean
    workSchedule?: boolean
    weeklyHours?: boolean
    salaryCipher?: boolean
    employmentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | StaffEmploymentInfo$doctorArgs<ExtArgs>
    reportingTo?: boolean | StaffEmploymentInfo$reportingToArgs<ExtArgs>
  }, ExtArgs["result"]["staffEmploymentInfo"]>

  export type StaffEmploymentInfoSelectScalar = {
    id?: boolean
    doctorId?: boolean
    employeeId?: boolean
    department?: boolean
    position?: boolean
    reportingToId?: boolean
    joinDate?: boolean
    employmentType?: boolean
    workSchedule?: boolean
    weeklyHours?: boolean
    salaryCipher?: boolean
    employmentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffEmploymentInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "doctorId" | "employeeId" | "department" | "position" | "reportingToId" | "joinDate" | "employmentType" | "workSchedule" | "weeklyHours" | "salaryCipher" | "employmentStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["staffEmploymentInfo"]>
  export type StaffEmploymentInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | StaffEmploymentInfo$doctorArgs<ExtArgs>
    reportingTo?: boolean | StaffEmploymentInfo$reportingToArgs<ExtArgs>
  }
  export type StaffEmploymentInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | StaffEmploymentInfo$doctorArgs<ExtArgs>
    reportingTo?: boolean | StaffEmploymentInfo$reportingToArgs<ExtArgs>
  }
  export type StaffEmploymentInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | StaffEmploymentInfo$doctorArgs<ExtArgs>
    reportingTo?: boolean | StaffEmploymentInfo$reportingToArgs<ExtArgs>
  }

  export type $StaffEmploymentInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffEmploymentInfo"
    objects: {
      doctor: Prisma.$DoctorPayload<ExtArgs> | null
      reportingTo: Prisma.$DoctorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      doctorId: string | null
      employeeId: string | null
      department: $Enums.Department | null
      position: string | null
      reportingToId: string | null
      joinDate: Date | null
      employmentType: $Enums.EmploymentType | null
      workSchedule: string | null
      weeklyHours: number | null
      salaryCipher: string | null
      employmentStatus: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["staffEmploymentInfo"]>
    composites: {}
  }

  type StaffEmploymentInfoGetPayload<S extends boolean | null | undefined | StaffEmploymentInfoDefaultArgs> = $Result.GetResult<Prisma.$StaffEmploymentInfoPayload, S>

  type StaffEmploymentInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffEmploymentInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffEmploymentInfoCountAggregateInputType | true
    }

  export interface StaffEmploymentInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffEmploymentInfo'], meta: { name: 'StaffEmploymentInfo' } }
    /**
     * Find zero or one StaffEmploymentInfo that matches the filter.
     * @param {StaffEmploymentInfoFindUniqueArgs} args - Arguments to find a StaffEmploymentInfo
     * @example
     * // Get one StaffEmploymentInfo
     * const staffEmploymentInfo = await prisma.staffEmploymentInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffEmploymentInfoFindUniqueArgs>(args: SelectSubset<T, StaffEmploymentInfoFindUniqueArgs<ExtArgs>>): Prisma__StaffEmploymentInfoClient<$Result.GetResult<Prisma.$StaffEmploymentInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StaffEmploymentInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffEmploymentInfoFindUniqueOrThrowArgs} args - Arguments to find a StaffEmploymentInfo
     * @example
     * // Get one StaffEmploymentInfo
     * const staffEmploymentInfo = await prisma.staffEmploymentInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffEmploymentInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffEmploymentInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffEmploymentInfoClient<$Result.GetResult<Prisma.$StaffEmploymentInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffEmploymentInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffEmploymentInfoFindFirstArgs} args - Arguments to find a StaffEmploymentInfo
     * @example
     * // Get one StaffEmploymentInfo
     * const staffEmploymentInfo = await prisma.staffEmploymentInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffEmploymentInfoFindFirstArgs>(args?: SelectSubset<T, StaffEmploymentInfoFindFirstArgs<ExtArgs>>): Prisma__StaffEmploymentInfoClient<$Result.GetResult<Prisma.$StaffEmploymentInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffEmploymentInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffEmploymentInfoFindFirstOrThrowArgs} args - Arguments to find a StaffEmploymentInfo
     * @example
     * // Get one StaffEmploymentInfo
     * const staffEmploymentInfo = await prisma.staffEmploymentInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffEmploymentInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffEmploymentInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffEmploymentInfoClient<$Result.GetResult<Prisma.$StaffEmploymentInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StaffEmploymentInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffEmploymentInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffEmploymentInfos
     * const staffEmploymentInfos = await prisma.staffEmploymentInfo.findMany()
     * 
     * // Get first 10 StaffEmploymentInfos
     * const staffEmploymentInfos = await prisma.staffEmploymentInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffEmploymentInfoWithIdOnly = await prisma.staffEmploymentInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffEmploymentInfoFindManyArgs>(args?: SelectSubset<T, StaffEmploymentInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffEmploymentInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StaffEmploymentInfo.
     * @param {StaffEmploymentInfoCreateArgs} args - Arguments to create a StaffEmploymentInfo.
     * @example
     * // Create one StaffEmploymentInfo
     * const StaffEmploymentInfo = await prisma.staffEmploymentInfo.create({
     *   data: {
     *     // ... data to create a StaffEmploymentInfo
     *   }
     * })
     * 
     */
    create<T extends StaffEmploymentInfoCreateArgs>(args: SelectSubset<T, StaffEmploymentInfoCreateArgs<ExtArgs>>): Prisma__StaffEmploymentInfoClient<$Result.GetResult<Prisma.$StaffEmploymentInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StaffEmploymentInfos.
     * @param {StaffEmploymentInfoCreateManyArgs} args - Arguments to create many StaffEmploymentInfos.
     * @example
     * // Create many StaffEmploymentInfos
     * const staffEmploymentInfo = await prisma.staffEmploymentInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffEmploymentInfoCreateManyArgs>(args?: SelectSubset<T, StaffEmploymentInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StaffEmploymentInfos and returns the data saved in the database.
     * @param {StaffEmploymentInfoCreateManyAndReturnArgs} args - Arguments to create many StaffEmploymentInfos.
     * @example
     * // Create many StaffEmploymentInfos
     * const staffEmploymentInfo = await prisma.staffEmploymentInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StaffEmploymentInfos and only return the `id`
     * const staffEmploymentInfoWithIdOnly = await prisma.staffEmploymentInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffEmploymentInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffEmploymentInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffEmploymentInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StaffEmploymentInfo.
     * @param {StaffEmploymentInfoDeleteArgs} args - Arguments to delete one StaffEmploymentInfo.
     * @example
     * // Delete one StaffEmploymentInfo
     * const StaffEmploymentInfo = await prisma.staffEmploymentInfo.delete({
     *   where: {
     *     // ... filter to delete one StaffEmploymentInfo
     *   }
     * })
     * 
     */
    delete<T extends StaffEmploymentInfoDeleteArgs>(args: SelectSubset<T, StaffEmploymentInfoDeleteArgs<ExtArgs>>): Prisma__StaffEmploymentInfoClient<$Result.GetResult<Prisma.$StaffEmploymentInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StaffEmploymentInfo.
     * @param {StaffEmploymentInfoUpdateArgs} args - Arguments to update one StaffEmploymentInfo.
     * @example
     * // Update one StaffEmploymentInfo
     * const staffEmploymentInfo = await prisma.staffEmploymentInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffEmploymentInfoUpdateArgs>(args: SelectSubset<T, StaffEmploymentInfoUpdateArgs<ExtArgs>>): Prisma__StaffEmploymentInfoClient<$Result.GetResult<Prisma.$StaffEmploymentInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StaffEmploymentInfos.
     * @param {StaffEmploymentInfoDeleteManyArgs} args - Arguments to filter StaffEmploymentInfos to delete.
     * @example
     * // Delete a few StaffEmploymentInfos
     * const { count } = await prisma.staffEmploymentInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffEmploymentInfoDeleteManyArgs>(args?: SelectSubset<T, StaffEmploymentInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffEmploymentInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffEmploymentInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffEmploymentInfos
     * const staffEmploymentInfo = await prisma.staffEmploymentInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffEmploymentInfoUpdateManyArgs>(args: SelectSubset<T, StaffEmploymentInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffEmploymentInfos and returns the data updated in the database.
     * @param {StaffEmploymentInfoUpdateManyAndReturnArgs} args - Arguments to update many StaffEmploymentInfos.
     * @example
     * // Update many StaffEmploymentInfos
     * const staffEmploymentInfo = await prisma.staffEmploymentInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StaffEmploymentInfos and only return the `id`
     * const staffEmploymentInfoWithIdOnly = await prisma.staffEmploymentInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffEmploymentInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffEmploymentInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffEmploymentInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StaffEmploymentInfo.
     * @param {StaffEmploymentInfoUpsertArgs} args - Arguments to update or create a StaffEmploymentInfo.
     * @example
     * // Update or create a StaffEmploymentInfo
     * const staffEmploymentInfo = await prisma.staffEmploymentInfo.upsert({
     *   create: {
     *     // ... data to create a StaffEmploymentInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffEmploymentInfo we want to update
     *   }
     * })
     */
    upsert<T extends StaffEmploymentInfoUpsertArgs>(args: SelectSubset<T, StaffEmploymentInfoUpsertArgs<ExtArgs>>): Prisma__StaffEmploymentInfoClient<$Result.GetResult<Prisma.$StaffEmploymentInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StaffEmploymentInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffEmploymentInfoCountArgs} args - Arguments to filter StaffEmploymentInfos to count.
     * @example
     * // Count the number of StaffEmploymentInfos
     * const count = await prisma.staffEmploymentInfo.count({
     *   where: {
     *     // ... the filter for the StaffEmploymentInfos we want to count
     *   }
     * })
    **/
    count<T extends StaffEmploymentInfoCountArgs>(
      args?: Subset<T, StaffEmploymentInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffEmploymentInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffEmploymentInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffEmploymentInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffEmploymentInfoAggregateArgs>(args: Subset<T, StaffEmploymentInfoAggregateArgs>): Prisma.PrismaPromise<GetStaffEmploymentInfoAggregateType<T>>

    /**
     * Group by StaffEmploymentInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffEmploymentInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffEmploymentInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffEmploymentInfoGroupByArgs['orderBy'] }
        : { orderBy?: StaffEmploymentInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffEmploymentInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffEmploymentInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffEmploymentInfo model
   */
  readonly fields: StaffEmploymentInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffEmploymentInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffEmploymentInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends StaffEmploymentInfo$doctorArgs<ExtArgs> = {}>(args?: Subset<T, StaffEmploymentInfo$doctorArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reportingTo<T extends StaffEmploymentInfo$reportingToArgs<ExtArgs> = {}>(args?: Subset<T, StaffEmploymentInfo$reportingToArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaffEmploymentInfo model
   */
  interface StaffEmploymentInfoFieldRefs {
    readonly id: FieldRef<"StaffEmploymentInfo", 'String'>
    readonly doctorId: FieldRef<"StaffEmploymentInfo", 'String'>
    readonly employeeId: FieldRef<"StaffEmploymentInfo", 'String'>
    readonly department: FieldRef<"StaffEmploymentInfo", 'Department'>
    readonly position: FieldRef<"StaffEmploymentInfo", 'String'>
    readonly reportingToId: FieldRef<"StaffEmploymentInfo", 'String'>
    readonly joinDate: FieldRef<"StaffEmploymentInfo", 'DateTime'>
    readonly employmentType: FieldRef<"StaffEmploymentInfo", 'EmploymentType'>
    readonly workSchedule: FieldRef<"StaffEmploymentInfo", 'String'>
    readonly weeklyHours: FieldRef<"StaffEmploymentInfo", 'Int'>
    readonly salaryCipher: FieldRef<"StaffEmploymentInfo", 'String'>
    readonly employmentStatus: FieldRef<"StaffEmploymentInfo", 'String'>
    readonly createdAt: FieldRef<"StaffEmploymentInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"StaffEmploymentInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StaffEmploymentInfo findUnique
   */
  export type StaffEmploymentInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffEmploymentInfo
     */
    select?: StaffEmploymentInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffEmploymentInfo
     */
    omit?: StaffEmploymentInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffEmploymentInfoInclude<ExtArgs> | null
    /**
     * Filter, which StaffEmploymentInfo to fetch.
     */
    where: StaffEmploymentInfoWhereUniqueInput
  }

  /**
   * StaffEmploymentInfo findUniqueOrThrow
   */
  export type StaffEmploymentInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffEmploymentInfo
     */
    select?: StaffEmploymentInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffEmploymentInfo
     */
    omit?: StaffEmploymentInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffEmploymentInfoInclude<ExtArgs> | null
    /**
     * Filter, which StaffEmploymentInfo to fetch.
     */
    where: StaffEmploymentInfoWhereUniqueInput
  }

  /**
   * StaffEmploymentInfo findFirst
   */
  export type StaffEmploymentInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffEmploymentInfo
     */
    select?: StaffEmploymentInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffEmploymentInfo
     */
    omit?: StaffEmploymentInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffEmploymentInfoInclude<ExtArgs> | null
    /**
     * Filter, which StaffEmploymentInfo to fetch.
     */
    where?: StaffEmploymentInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffEmploymentInfos to fetch.
     */
    orderBy?: StaffEmploymentInfoOrderByWithRelationInput | StaffEmploymentInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffEmploymentInfos.
     */
    cursor?: StaffEmploymentInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffEmploymentInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffEmploymentInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffEmploymentInfos.
     */
    distinct?: StaffEmploymentInfoScalarFieldEnum | StaffEmploymentInfoScalarFieldEnum[]
  }

  /**
   * StaffEmploymentInfo findFirstOrThrow
   */
  export type StaffEmploymentInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffEmploymentInfo
     */
    select?: StaffEmploymentInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffEmploymentInfo
     */
    omit?: StaffEmploymentInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffEmploymentInfoInclude<ExtArgs> | null
    /**
     * Filter, which StaffEmploymentInfo to fetch.
     */
    where?: StaffEmploymentInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffEmploymentInfos to fetch.
     */
    orderBy?: StaffEmploymentInfoOrderByWithRelationInput | StaffEmploymentInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffEmploymentInfos.
     */
    cursor?: StaffEmploymentInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffEmploymentInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffEmploymentInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffEmploymentInfos.
     */
    distinct?: StaffEmploymentInfoScalarFieldEnum | StaffEmploymentInfoScalarFieldEnum[]
  }

  /**
   * StaffEmploymentInfo findMany
   */
  export type StaffEmploymentInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffEmploymentInfo
     */
    select?: StaffEmploymentInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffEmploymentInfo
     */
    omit?: StaffEmploymentInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffEmploymentInfoInclude<ExtArgs> | null
    /**
     * Filter, which StaffEmploymentInfos to fetch.
     */
    where?: StaffEmploymentInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffEmploymentInfos to fetch.
     */
    orderBy?: StaffEmploymentInfoOrderByWithRelationInput | StaffEmploymentInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffEmploymentInfos.
     */
    cursor?: StaffEmploymentInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffEmploymentInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffEmploymentInfos.
     */
    skip?: number
    distinct?: StaffEmploymentInfoScalarFieldEnum | StaffEmploymentInfoScalarFieldEnum[]
  }

  /**
   * StaffEmploymentInfo create
   */
  export type StaffEmploymentInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffEmploymentInfo
     */
    select?: StaffEmploymentInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffEmploymentInfo
     */
    omit?: StaffEmploymentInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffEmploymentInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffEmploymentInfo.
     */
    data?: XOR<StaffEmploymentInfoCreateInput, StaffEmploymentInfoUncheckedCreateInput>
  }

  /**
   * StaffEmploymentInfo createMany
   */
  export type StaffEmploymentInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffEmploymentInfos.
     */
    data: StaffEmploymentInfoCreateManyInput | StaffEmploymentInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StaffEmploymentInfo createManyAndReturn
   */
  export type StaffEmploymentInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffEmploymentInfo
     */
    select?: StaffEmploymentInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffEmploymentInfo
     */
    omit?: StaffEmploymentInfoOmit<ExtArgs> | null
    /**
     * The data used to create many StaffEmploymentInfos.
     */
    data: StaffEmploymentInfoCreateManyInput | StaffEmploymentInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffEmploymentInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffEmploymentInfo update
   */
  export type StaffEmploymentInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffEmploymentInfo
     */
    select?: StaffEmploymentInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffEmploymentInfo
     */
    omit?: StaffEmploymentInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffEmploymentInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffEmploymentInfo.
     */
    data: XOR<StaffEmploymentInfoUpdateInput, StaffEmploymentInfoUncheckedUpdateInput>
    /**
     * Choose, which StaffEmploymentInfo to update.
     */
    where: StaffEmploymentInfoWhereUniqueInput
  }

  /**
   * StaffEmploymentInfo updateMany
   */
  export type StaffEmploymentInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffEmploymentInfos.
     */
    data: XOR<StaffEmploymentInfoUpdateManyMutationInput, StaffEmploymentInfoUncheckedUpdateManyInput>
    /**
     * Filter which StaffEmploymentInfos to update
     */
    where?: StaffEmploymentInfoWhereInput
    /**
     * Limit how many StaffEmploymentInfos to update.
     */
    limit?: number
  }

  /**
   * StaffEmploymentInfo updateManyAndReturn
   */
  export type StaffEmploymentInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffEmploymentInfo
     */
    select?: StaffEmploymentInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffEmploymentInfo
     */
    omit?: StaffEmploymentInfoOmit<ExtArgs> | null
    /**
     * The data used to update StaffEmploymentInfos.
     */
    data: XOR<StaffEmploymentInfoUpdateManyMutationInput, StaffEmploymentInfoUncheckedUpdateManyInput>
    /**
     * Filter which StaffEmploymentInfos to update
     */
    where?: StaffEmploymentInfoWhereInput
    /**
     * Limit how many StaffEmploymentInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffEmploymentInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffEmploymentInfo upsert
   */
  export type StaffEmploymentInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffEmploymentInfo
     */
    select?: StaffEmploymentInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffEmploymentInfo
     */
    omit?: StaffEmploymentInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffEmploymentInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffEmploymentInfo to update in case it exists.
     */
    where: StaffEmploymentInfoWhereUniqueInput
    /**
     * In case the StaffEmploymentInfo found by the `where` argument doesn't exist, create a new StaffEmploymentInfo with this data.
     */
    create: XOR<StaffEmploymentInfoCreateInput, StaffEmploymentInfoUncheckedCreateInput>
    /**
     * In case the StaffEmploymentInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffEmploymentInfoUpdateInput, StaffEmploymentInfoUncheckedUpdateInput>
  }

  /**
   * StaffEmploymentInfo delete
   */
  export type StaffEmploymentInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffEmploymentInfo
     */
    select?: StaffEmploymentInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffEmploymentInfo
     */
    omit?: StaffEmploymentInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffEmploymentInfoInclude<ExtArgs> | null
    /**
     * Filter which StaffEmploymentInfo to delete.
     */
    where: StaffEmploymentInfoWhereUniqueInput
  }

  /**
   * StaffEmploymentInfo deleteMany
   */
  export type StaffEmploymentInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffEmploymentInfos to delete
     */
    where?: StaffEmploymentInfoWhereInput
    /**
     * Limit how many StaffEmploymentInfos to delete.
     */
    limit?: number
  }

  /**
   * StaffEmploymentInfo.doctor
   */
  export type StaffEmploymentInfo$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * StaffEmploymentInfo.reportingTo
   */
  export type StaffEmploymentInfo$reportingToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * StaffEmploymentInfo without action
   */
  export type StaffEmploymentInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffEmploymentInfo
     */
    select?: StaffEmploymentInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffEmploymentInfo
     */
    omit?: StaffEmploymentInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffEmploymentInfoInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    assigneeDoctorId: string | null
    assigneeAdminId: string | null
    patientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    assigneeDoctorId: string | null
    assigneeAdminId: string | null
    patientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    clinicId: number
    title: number
    description: number
    status: number
    priority: number
    dueDate: number
    assigneeDoctorId: number
    assigneeAdminId: number
    patientId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    clinicId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    assigneeDoctorId?: true
    assigneeAdminId?: true
    patientId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    clinicId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    assigneeDoctorId?: true
    assigneeAdminId?: true
    patientId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    clinicId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    assigneeDoctorId?: true
    assigneeAdminId?: true
    patientId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    clinicId: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    assigneeDoctorId: string | null
    assigneeAdminId: string | null
    patientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    assigneeDoctorId?: boolean
    assigneeAdminId?: boolean
    patientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Task$clinicArgs<ExtArgs>
    assignedDoctor?: boolean | Task$assignedDoctorArgs<ExtArgs>
    assignedAdmin?: boolean | Task$assignedAdminArgs<ExtArgs>
    patient?: boolean | Task$patientArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    assigneeDoctorId?: boolean
    assigneeAdminId?: boolean
    patientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Task$clinicArgs<ExtArgs>
    assignedDoctor?: boolean | Task$assignedDoctorArgs<ExtArgs>
    assignedAdmin?: boolean | Task$assignedAdminArgs<ExtArgs>
    patient?: boolean | Task$patientArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    assigneeDoctorId?: boolean
    assigneeAdminId?: boolean
    patientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Task$clinicArgs<ExtArgs>
    assignedDoctor?: boolean | Task$assignedDoctorArgs<ExtArgs>
    assignedAdmin?: boolean | Task$assignedAdminArgs<ExtArgs>
    patient?: boolean | Task$patientArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    clinicId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    assigneeDoctorId?: boolean
    assigneeAdminId?: boolean
    patientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "title" | "description" | "status" | "priority" | "dueDate" | "assigneeDoctorId" | "assigneeAdminId" | "patientId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Task$clinicArgs<ExtArgs>
    assignedDoctor?: boolean | Task$assignedDoctorArgs<ExtArgs>
    assignedAdmin?: boolean | Task$assignedAdminArgs<ExtArgs>
    patient?: boolean | Task$patientArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Task$clinicArgs<ExtArgs>
    assignedDoctor?: boolean | Task$assignedDoctorArgs<ExtArgs>
    assignedAdmin?: boolean | Task$assignedAdminArgs<ExtArgs>
    patient?: boolean | Task$patientArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Task$clinicArgs<ExtArgs>
    assignedDoctor?: boolean | Task$assignedDoctorArgs<ExtArgs>
    assignedAdmin?: boolean | Task$assignedAdminArgs<ExtArgs>
    patient?: boolean | Task$patientArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      assignedDoctor: Prisma.$DoctorPayload<ExtArgs> | null
      assignedAdmin: Prisma.$AdminPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string | null
      title: string | null
      description: string | null
      status: $Enums.TaskStatus | null
      priority: $Enums.Priority | null
      dueDate: Date | null
      assigneeDoctorId: string | null
      assigneeAdminId: string | null
      patientId: string | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends Task$clinicArgs<ExtArgs> = {}>(args?: Subset<T, Task$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedDoctor<T extends Task$assignedDoctorArgs<ExtArgs> = {}>(args?: Subset<T, Task$assignedDoctorArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedAdmin<T extends Task$assignedAdminArgs<ExtArgs> = {}>(args?: Subset<T, Task$assignedAdminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends Task$patientArgs<ExtArgs> = {}>(args?: Subset<T, Task$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly clinicId: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly priority: FieldRef<"Task", 'Priority'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly assigneeDoctorId: FieldRef<"Task", 'String'>
    readonly assigneeAdminId: FieldRef<"Task", 'String'>
    readonly patientId: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly deletedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data?: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.clinic
   */
  export type Task$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * Task.assignedDoctor
   */
  export type Task$assignedDoctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * Task.assignedAdmin
   */
  export type Task$assignedAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * Task.patient
   */
  export type Task$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model SystemMetric
   */

  export type AggregateSystemMetric = {
    _count: SystemMetricCountAggregateOutputType | null
    _avg: SystemMetricAvgAggregateOutputType | null
    _sum: SystemMetricSumAggregateOutputType | null
    _min: SystemMetricMinAggregateOutputType | null
    _max: SystemMetricMaxAggregateOutputType | null
  }

  export type SystemMetricAvgAggregateOutputType = {
    value: number | null
  }

  export type SystemMetricSumAggregateOutputType = {
    value: number | null
  }

  export type SystemMetricMinAggregateOutputType = {
    id: string | null
    serviceName: $Enums.ServiceName | null
    metricType: $Enums.MetricType | null
    value: number | null
    unit: string | null
    recordedAt: Date | null
    createdAt: Date | null
  }

  export type SystemMetricMaxAggregateOutputType = {
    id: string | null
    serviceName: $Enums.ServiceName | null
    metricType: $Enums.MetricType | null
    value: number | null
    unit: string | null
    recordedAt: Date | null
    createdAt: Date | null
  }

  export type SystemMetricCountAggregateOutputType = {
    id: number
    serviceName: number
    metricType: number
    value: number
    unit: number
    recordedAt: number
    createdAt: number
    _all: number
  }


  export type SystemMetricAvgAggregateInputType = {
    value?: true
  }

  export type SystemMetricSumAggregateInputType = {
    value?: true
  }

  export type SystemMetricMinAggregateInputType = {
    id?: true
    serviceName?: true
    metricType?: true
    value?: true
    unit?: true
    recordedAt?: true
    createdAt?: true
  }

  export type SystemMetricMaxAggregateInputType = {
    id?: true
    serviceName?: true
    metricType?: true
    value?: true
    unit?: true
    recordedAt?: true
    createdAt?: true
  }

  export type SystemMetricCountAggregateInputType = {
    id?: true
    serviceName?: true
    metricType?: true
    value?: true
    unit?: true
    recordedAt?: true
    createdAt?: true
    _all?: true
  }

  export type SystemMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemMetric to aggregate.
     */
    where?: SystemMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricOrderByWithRelationInput | SystemMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemMetrics
    **/
    _count?: true | SystemMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemMetricMaxAggregateInputType
  }

  export type GetSystemMetricAggregateType<T extends SystemMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemMetric[P]>
      : GetScalarType<T[P], AggregateSystemMetric[P]>
  }




  export type SystemMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemMetricWhereInput
    orderBy?: SystemMetricOrderByWithAggregationInput | SystemMetricOrderByWithAggregationInput[]
    by: SystemMetricScalarFieldEnum[] | SystemMetricScalarFieldEnum
    having?: SystemMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemMetricCountAggregateInputType | true
    _avg?: SystemMetricAvgAggregateInputType
    _sum?: SystemMetricSumAggregateInputType
    _min?: SystemMetricMinAggregateInputType
    _max?: SystemMetricMaxAggregateInputType
  }

  export type SystemMetricGroupByOutputType = {
    id: string
    serviceName: $Enums.ServiceName | null
    metricType: $Enums.MetricType | null
    value: number | null
    unit: string | null
    recordedAt: Date | null
    createdAt: Date | null
    _count: SystemMetricCountAggregateOutputType | null
    _avg: SystemMetricAvgAggregateOutputType | null
    _sum: SystemMetricSumAggregateOutputType | null
    _min: SystemMetricMinAggregateOutputType | null
    _max: SystemMetricMaxAggregateOutputType | null
  }

  type GetSystemMetricGroupByPayload<T extends SystemMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemMetricGroupByOutputType[P]>
            : GetScalarType<T[P], SystemMetricGroupByOutputType[P]>
        }
      >
    >


  export type SystemMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceName?: boolean
    metricType?: boolean
    value?: boolean
    unit?: boolean
    recordedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemMetric"]>

  export type SystemMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceName?: boolean
    metricType?: boolean
    value?: boolean
    unit?: boolean
    recordedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemMetric"]>

  export type SystemMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceName?: boolean
    metricType?: boolean
    value?: boolean
    unit?: boolean
    recordedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemMetric"]>

  export type SystemMetricSelectScalar = {
    id?: boolean
    serviceName?: boolean
    metricType?: boolean
    value?: boolean
    unit?: boolean
    recordedAt?: boolean
    createdAt?: boolean
  }

  export type SystemMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceName" | "metricType" | "value" | "unit" | "recordedAt" | "createdAt", ExtArgs["result"]["systemMetric"]>

  export type $SystemMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceName: $Enums.ServiceName | null
      metricType: $Enums.MetricType | null
      value: number | null
      unit: string | null
      recordedAt: Date | null
      createdAt: Date | null
    }, ExtArgs["result"]["systemMetric"]>
    composites: {}
  }

  type SystemMetricGetPayload<S extends boolean | null | undefined | SystemMetricDefaultArgs> = $Result.GetResult<Prisma.$SystemMetricPayload, S>

  type SystemMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemMetricCountAggregateInputType | true
    }

  export interface SystemMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemMetric'], meta: { name: 'SystemMetric' } }
    /**
     * Find zero or one SystemMetric that matches the filter.
     * @param {SystemMetricFindUniqueArgs} args - Arguments to find a SystemMetric
     * @example
     * // Get one SystemMetric
     * const systemMetric = await prisma.systemMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemMetricFindUniqueArgs>(args: SelectSubset<T, SystemMetricFindUniqueArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemMetricFindUniqueOrThrowArgs} args - Arguments to find a SystemMetric
     * @example
     * // Get one SystemMetric
     * const systemMetric = await prisma.systemMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricFindFirstArgs} args - Arguments to find a SystemMetric
     * @example
     * // Get one SystemMetric
     * const systemMetric = await prisma.systemMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemMetricFindFirstArgs>(args?: SelectSubset<T, SystemMetricFindFirstArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricFindFirstOrThrowArgs} args - Arguments to find a SystemMetric
     * @example
     * // Get one SystemMetric
     * const systemMetric = await prisma.systemMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemMetrics
     * const systemMetrics = await prisma.systemMetric.findMany()
     * 
     * // Get first 10 SystemMetrics
     * const systemMetrics = await prisma.systemMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemMetricWithIdOnly = await prisma.systemMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemMetricFindManyArgs>(args?: SelectSubset<T, SystemMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemMetric.
     * @param {SystemMetricCreateArgs} args - Arguments to create a SystemMetric.
     * @example
     * // Create one SystemMetric
     * const SystemMetric = await prisma.systemMetric.create({
     *   data: {
     *     // ... data to create a SystemMetric
     *   }
     * })
     * 
     */
    create<T extends SystemMetricCreateArgs>(args: SelectSubset<T, SystemMetricCreateArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemMetrics.
     * @param {SystemMetricCreateManyArgs} args - Arguments to create many SystemMetrics.
     * @example
     * // Create many SystemMetrics
     * const systemMetric = await prisma.systemMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemMetricCreateManyArgs>(args?: SelectSubset<T, SystemMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemMetrics and returns the data saved in the database.
     * @param {SystemMetricCreateManyAndReturnArgs} args - Arguments to create many SystemMetrics.
     * @example
     * // Create many SystemMetrics
     * const systemMetric = await prisma.systemMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemMetrics and only return the `id`
     * const systemMetricWithIdOnly = await prisma.systemMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemMetric.
     * @param {SystemMetricDeleteArgs} args - Arguments to delete one SystemMetric.
     * @example
     * // Delete one SystemMetric
     * const SystemMetric = await prisma.systemMetric.delete({
     *   where: {
     *     // ... filter to delete one SystemMetric
     *   }
     * })
     * 
     */
    delete<T extends SystemMetricDeleteArgs>(args: SelectSubset<T, SystemMetricDeleteArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemMetric.
     * @param {SystemMetricUpdateArgs} args - Arguments to update one SystemMetric.
     * @example
     * // Update one SystemMetric
     * const systemMetric = await prisma.systemMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemMetricUpdateArgs>(args: SelectSubset<T, SystemMetricUpdateArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemMetrics.
     * @param {SystemMetricDeleteManyArgs} args - Arguments to filter SystemMetrics to delete.
     * @example
     * // Delete a few SystemMetrics
     * const { count } = await prisma.systemMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemMetricDeleteManyArgs>(args?: SelectSubset<T, SystemMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemMetrics
     * const systemMetric = await prisma.systemMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemMetricUpdateManyArgs>(args: SelectSubset<T, SystemMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemMetrics and returns the data updated in the database.
     * @param {SystemMetricUpdateManyAndReturnArgs} args - Arguments to update many SystemMetrics.
     * @example
     * // Update many SystemMetrics
     * const systemMetric = await prisma.systemMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemMetrics and only return the `id`
     * const systemMetricWithIdOnly = await prisma.systemMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemMetric.
     * @param {SystemMetricUpsertArgs} args - Arguments to update or create a SystemMetric.
     * @example
     * // Update or create a SystemMetric
     * const systemMetric = await prisma.systemMetric.upsert({
     *   create: {
     *     // ... data to create a SystemMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemMetric we want to update
     *   }
     * })
     */
    upsert<T extends SystemMetricUpsertArgs>(args: SelectSubset<T, SystemMetricUpsertArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricCountArgs} args - Arguments to filter SystemMetrics to count.
     * @example
     * // Count the number of SystemMetrics
     * const count = await prisma.systemMetric.count({
     *   where: {
     *     // ... the filter for the SystemMetrics we want to count
     *   }
     * })
    **/
    count<T extends SystemMetricCountArgs>(
      args?: Subset<T, SystemMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemMetricAggregateArgs>(args: Subset<T, SystemMetricAggregateArgs>): Prisma.PrismaPromise<GetSystemMetricAggregateType<T>>

    /**
     * Group by SystemMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemMetricGroupByArgs['orderBy'] }
        : { orderBy?: SystemMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemMetric model
   */
  readonly fields: SystemMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemMetric model
   */
  interface SystemMetricFieldRefs {
    readonly id: FieldRef<"SystemMetric", 'String'>
    readonly serviceName: FieldRef<"SystemMetric", 'ServiceName'>
    readonly metricType: FieldRef<"SystemMetric", 'MetricType'>
    readonly value: FieldRef<"SystemMetric", 'Float'>
    readonly unit: FieldRef<"SystemMetric", 'String'>
    readonly recordedAt: FieldRef<"SystemMetric", 'DateTime'>
    readonly createdAt: FieldRef<"SystemMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemMetric findUnique
   */
  export type SystemMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * Filter, which SystemMetric to fetch.
     */
    where: SystemMetricWhereUniqueInput
  }

  /**
   * SystemMetric findUniqueOrThrow
   */
  export type SystemMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * Filter, which SystemMetric to fetch.
     */
    where: SystemMetricWhereUniqueInput
  }

  /**
   * SystemMetric findFirst
   */
  export type SystemMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * Filter, which SystemMetric to fetch.
     */
    where?: SystemMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricOrderByWithRelationInput | SystemMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemMetrics.
     */
    cursor?: SystemMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemMetrics.
     */
    distinct?: SystemMetricScalarFieldEnum | SystemMetricScalarFieldEnum[]
  }

  /**
   * SystemMetric findFirstOrThrow
   */
  export type SystemMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * Filter, which SystemMetric to fetch.
     */
    where?: SystemMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricOrderByWithRelationInput | SystemMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemMetrics.
     */
    cursor?: SystemMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemMetrics.
     */
    distinct?: SystemMetricScalarFieldEnum | SystemMetricScalarFieldEnum[]
  }

  /**
   * SystemMetric findMany
   */
  export type SystemMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * Filter, which SystemMetrics to fetch.
     */
    where?: SystemMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricOrderByWithRelationInput | SystemMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemMetrics.
     */
    cursor?: SystemMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    distinct?: SystemMetricScalarFieldEnum | SystemMetricScalarFieldEnum[]
  }

  /**
   * SystemMetric create
   */
  export type SystemMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemMetric.
     */
    data?: XOR<SystemMetricCreateInput, SystemMetricUncheckedCreateInput>
  }

  /**
   * SystemMetric createMany
   */
  export type SystemMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemMetrics.
     */
    data: SystemMetricCreateManyInput | SystemMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemMetric createManyAndReturn
   */
  export type SystemMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * The data used to create many SystemMetrics.
     */
    data: SystemMetricCreateManyInput | SystemMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemMetric update
   */
  export type SystemMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemMetric.
     */
    data: XOR<SystemMetricUpdateInput, SystemMetricUncheckedUpdateInput>
    /**
     * Choose, which SystemMetric to update.
     */
    where: SystemMetricWhereUniqueInput
  }

  /**
   * SystemMetric updateMany
   */
  export type SystemMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemMetrics.
     */
    data: XOR<SystemMetricUpdateManyMutationInput, SystemMetricUncheckedUpdateManyInput>
    /**
     * Filter which SystemMetrics to update
     */
    where?: SystemMetricWhereInput
    /**
     * Limit how many SystemMetrics to update.
     */
    limit?: number
  }

  /**
   * SystemMetric updateManyAndReturn
   */
  export type SystemMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * The data used to update SystemMetrics.
     */
    data: XOR<SystemMetricUpdateManyMutationInput, SystemMetricUncheckedUpdateManyInput>
    /**
     * Filter which SystemMetrics to update
     */
    where?: SystemMetricWhereInput
    /**
     * Limit how many SystemMetrics to update.
     */
    limit?: number
  }

  /**
   * SystemMetric upsert
   */
  export type SystemMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemMetric to update in case it exists.
     */
    where: SystemMetricWhereUniqueInput
    /**
     * In case the SystemMetric found by the `where` argument doesn't exist, create a new SystemMetric with this data.
     */
    create: XOR<SystemMetricCreateInput, SystemMetricUncheckedCreateInput>
    /**
     * In case the SystemMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemMetricUpdateInput, SystemMetricUncheckedUpdateInput>
  }

  /**
   * SystemMetric delete
   */
  export type SystemMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * Filter which SystemMetric to delete.
     */
    where: SystemMetricWhereUniqueInput
  }

  /**
   * SystemMetric deleteMany
   */
  export type SystemMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemMetrics to delete
     */
    where?: SystemMetricWhereInput
    /**
     * Limit how many SystemMetrics to delete.
     */
    limit?: number
  }

  /**
   * SystemMetric without action
   */
  export type SystemMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    otp: string | null
    emailVerifiedAt: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    otp: string | null
    emailVerifiedAt: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    clinicId: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    otp: number
    emailVerifiedAt: number
    twoFactorSecret: number
    twoFactorEnabled: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    clinicId?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    otp?: true
    emailVerifiedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    clinicId?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    otp?: true
    emailVerifiedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    clinicId?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    otp?: true
    emailVerifiedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    clinicId: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    otp: string | null
    emailVerifiedAt: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    otp?: boolean
    emailVerifiedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Admin$clinicArgs<ExtArgs>
    sessions?: boolean | Admin$sessionsArgs<ExtArgs>
    auditLogs?: boolean | Admin$auditLogsArgs<ExtArgs>
    assignedTasks?: boolean | Admin$assignedTasksArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    otp?: boolean
    emailVerifiedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Admin$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    otp?: boolean
    emailVerifiedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Admin$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    clinicId?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    otp?: boolean
    emailVerifiedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "email" | "passwordHash" | "firstName" | "lastName" | "otp" | "emailVerifiedAt" | "twoFactorSecret" | "twoFactorEnabled" | "lastLoginAt" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Admin$clinicArgs<ExtArgs>
    sessions?: boolean | Admin$sessionsArgs<ExtArgs>
    auditLogs?: boolean | Admin$auditLogsArgs<ExtArgs>
    assignedTasks?: boolean | Admin$assignedTasksArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Admin$clinicArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Admin$clinicArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      assignedTasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string | null
      email: string | null
      passwordHash: string | null
      firstName: string | null
      lastName: string | null
      otp: string | null
      emailVerifiedAt: Date | null
      twoFactorSecret: string | null
      twoFactorEnabled: boolean | null
      lastLoginAt: Date | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends Admin$clinicArgs<ExtArgs> = {}>(args?: Subset<T, Admin$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sessions<T extends Admin$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Admin$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTasks<T extends Admin$assignedTasksArgs<ExtArgs> = {}>(args?: Subset<T, Admin$assignedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly clinicId: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly passwordHash: FieldRef<"Admin", 'String'>
    readonly firstName: FieldRef<"Admin", 'String'>
    readonly lastName: FieldRef<"Admin", 'String'>
    readonly otp: FieldRef<"Admin", 'String'>
    readonly emailVerifiedAt: FieldRef<"Admin", 'DateTime'>
    readonly twoFactorSecret: FieldRef<"Admin", 'String'>
    readonly twoFactorEnabled: FieldRef<"Admin", 'Boolean'>
    readonly lastLoginAt: FieldRef<"Admin", 'DateTime'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
    readonly deletedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data?: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.clinic
   */
  export type Admin$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * Admin.sessions
   */
  export type Admin$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Admin.auditLogs
   */
  export type Admin$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Admin.assignedTasks
   */
  export type Admin$assignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Doctor
   */

  export type AggregateDoctor = {
    _count: DoctorCountAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  export type DoctorMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    otp: string | null
    licenceNo: string | null
    emailVerifiedAt: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DoctorMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    otp: string | null
    licenceNo: string | null
    emailVerifiedAt: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DoctorCountAggregateOutputType = {
    id: number
    clinicId: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    otp: number
    licenceNo: number
    specialities: number
    emailVerifiedAt: number
    twoFactorSecret: number
    twoFactorEnabled: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type DoctorMinAggregateInputType = {
    id?: true
    clinicId?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    otp?: true
    licenceNo?: true
    emailVerifiedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DoctorMaxAggregateInputType = {
    id?: true
    clinicId?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    otp?: true
    licenceNo?: true
    emailVerifiedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DoctorCountAggregateInputType = {
    id?: true
    clinicId?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    otp?: true
    licenceNo?: true
    specialities?: true
    emailVerifiedAt?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type DoctorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctor to aggregate.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Doctors
    **/
    _count?: true | DoctorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorMaxAggregateInputType
  }

  export type GetDoctorAggregateType<T extends DoctorAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctor[P]>
      : GetScalarType<T[P], AggregateDoctor[P]>
  }




  export type DoctorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorWhereInput
    orderBy?: DoctorOrderByWithAggregationInput | DoctorOrderByWithAggregationInput[]
    by: DoctorScalarFieldEnum[] | DoctorScalarFieldEnum
    having?: DoctorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorCountAggregateInputType | true
    _min?: DoctorMinAggregateInputType
    _max?: DoctorMaxAggregateInputType
  }

  export type DoctorGroupByOutputType = {
    id: string
    clinicId: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    otp: string | null
    licenceNo: string | null
    specialities: string[]
    emailVerifiedAt: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: DoctorCountAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  type GetDoctorGroupByPayload<T extends DoctorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorGroupByOutputType[P]>
        }
      >
    >


  export type DoctorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    otp?: boolean
    licenceNo?: boolean
    specialities?: boolean
    emailVerifiedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Doctor$clinicArgs<ExtArgs>
    sessions?: boolean | Doctor$sessionsArgs<ExtArgs>
    appointments?: boolean | Doctor$appointmentsArgs<ExtArgs>
    calls?: boolean | Doctor$callsArgs<ExtArgs>
    prescriptions?: boolean | Doctor$prescriptionsArgs<ExtArgs>
    diagnoses?: boolean | Doctor$diagnosesArgs<ExtArgs>
    assignedTasks?: boolean | Doctor$assignedTasksArgs<ExtArgs>
    auditLogs?: boolean | Doctor$auditLogsArgs<ExtArgs>
    staffPersonalInfo?: boolean | Doctor$staffPersonalInfoArgs<ExtArgs>
    staffEmploymentInfo?: boolean | Doctor$staffEmploymentInfoArgs<ExtArgs>
    subordinates?: boolean | Doctor$subordinatesArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    otp?: boolean
    licenceNo?: boolean
    specialities?: boolean
    emailVerifiedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Doctor$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    otp?: boolean
    licenceNo?: boolean
    specialities?: boolean
    emailVerifiedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    clinic?: boolean | Doctor$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectScalar = {
    id?: boolean
    clinicId?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    otp?: boolean
    licenceNo?: boolean
    specialities?: boolean
    emailVerifiedAt?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type DoctorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "email" | "passwordHash" | "firstName" | "lastName" | "otp" | "licenceNo" | "specialities" | "emailVerifiedAt" | "twoFactorSecret" | "twoFactorEnabled" | "lastLoginAt" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["doctor"]>
  export type DoctorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Doctor$clinicArgs<ExtArgs>
    sessions?: boolean | Doctor$sessionsArgs<ExtArgs>
    appointments?: boolean | Doctor$appointmentsArgs<ExtArgs>
    calls?: boolean | Doctor$callsArgs<ExtArgs>
    prescriptions?: boolean | Doctor$prescriptionsArgs<ExtArgs>
    diagnoses?: boolean | Doctor$diagnosesArgs<ExtArgs>
    assignedTasks?: boolean | Doctor$assignedTasksArgs<ExtArgs>
    auditLogs?: boolean | Doctor$auditLogsArgs<ExtArgs>
    staffPersonalInfo?: boolean | Doctor$staffPersonalInfoArgs<ExtArgs>
    staffEmploymentInfo?: boolean | Doctor$staffEmploymentInfoArgs<ExtArgs>
    subordinates?: boolean | Doctor$subordinatesArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DoctorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Doctor$clinicArgs<ExtArgs>
  }
  export type DoctorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | Doctor$clinicArgs<ExtArgs>
  }

  export type $DoctorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Doctor"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      calls: Prisma.$CallPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      diagnoses: Prisma.$DiagnosisPayload<ExtArgs>[]
      assignedTasks: Prisma.$TaskPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      staffPersonalInfo: Prisma.$StaffPersonalInfoPayload<ExtArgs> | null
      staffEmploymentInfo: Prisma.$StaffEmploymentInfoPayload<ExtArgs> | null
      subordinates: Prisma.$StaffEmploymentInfoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string | null
      email: string | null
      passwordHash: string | null
      firstName: string | null
      lastName: string | null
      otp: string | null
      licenceNo: string | null
      specialities: string[]
      emailVerifiedAt: Date | null
      twoFactorSecret: string | null
      twoFactorEnabled: boolean | null
      lastLoginAt: Date | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["doctor"]>
    composites: {}
  }

  type DoctorGetPayload<S extends boolean | null | undefined | DoctorDefaultArgs> = $Result.GetResult<Prisma.$DoctorPayload, S>

  type DoctorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DoctorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DoctorCountAggregateInputType | true
    }

  export interface DoctorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Doctor'], meta: { name: 'Doctor' } }
    /**
     * Find zero or one Doctor that matches the filter.
     * @param {DoctorFindUniqueArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorFindUniqueArgs>(args: SelectSubset<T, DoctorFindUniqueArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Doctor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoctorFindUniqueOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Doctor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorFindFirstArgs>(args?: SelectSubset<T, DoctorFindFirstArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Doctor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctors
     * const doctors = await prisma.doctor.findMany()
     * 
     * // Get first 10 Doctors
     * const doctors = await prisma.doctor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorWithIdOnly = await prisma.doctor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorFindManyArgs>(args?: SelectSubset<T, DoctorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Doctor.
     * @param {DoctorCreateArgs} args - Arguments to create a Doctor.
     * @example
     * // Create one Doctor
     * const Doctor = await prisma.doctor.create({
     *   data: {
     *     // ... data to create a Doctor
     *   }
     * })
     * 
     */
    create<T extends DoctorCreateArgs>(args: SelectSubset<T, DoctorCreateArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Doctors.
     * @param {DoctorCreateManyArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorCreateManyArgs>(args?: SelectSubset<T, DoctorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Doctors and returns the data saved in the database.
     * @param {DoctorCreateManyAndReturnArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Doctors and only return the `id`
     * const doctorWithIdOnly = await prisma.doctor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Doctor.
     * @param {DoctorDeleteArgs} args - Arguments to delete one Doctor.
     * @example
     * // Delete one Doctor
     * const Doctor = await prisma.doctor.delete({
     *   where: {
     *     // ... filter to delete one Doctor
     *   }
     * })
     * 
     */
    delete<T extends DoctorDeleteArgs>(args: SelectSubset<T, DoctorDeleteArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Doctor.
     * @param {DoctorUpdateArgs} args - Arguments to update one Doctor.
     * @example
     * // Update one Doctor
     * const doctor = await prisma.doctor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorUpdateArgs>(args: SelectSubset<T, DoctorUpdateArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Doctors.
     * @param {DoctorDeleteManyArgs} args - Arguments to filter Doctors to delete.
     * @example
     * // Delete a few Doctors
     * const { count } = await prisma.doctor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorDeleteManyArgs>(args?: SelectSubset<T, DoctorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorUpdateManyArgs>(args: SelectSubset<T, DoctorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors and returns the data updated in the database.
     * @param {DoctorUpdateManyAndReturnArgs} args - Arguments to update many Doctors.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Doctors and only return the `id`
     * const doctorWithIdOnly = await prisma.doctor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DoctorUpdateManyAndReturnArgs>(args: SelectSubset<T, DoctorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Doctor.
     * @param {DoctorUpsertArgs} args - Arguments to update or create a Doctor.
     * @example
     * // Update or create a Doctor
     * const doctor = await prisma.doctor.upsert({
     *   create: {
     *     // ... data to create a Doctor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctor we want to update
     *   }
     * })
     */
    upsert<T extends DoctorUpsertArgs>(args: SelectSubset<T, DoctorUpsertArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorCountArgs} args - Arguments to filter Doctors to count.
     * @example
     * // Count the number of Doctors
     * const count = await prisma.doctor.count({
     *   where: {
     *     // ... the filter for the Doctors we want to count
     *   }
     * })
    **/
    count<T extends DoctorCountArgs>(
      args?: Subset<T, DoctorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorAggregateArgs>(args: Subset<T, DoctorAggregateArgs>): Prisma.PrismaPromise<GetDoctorAggregateType<T>>

    /**
     * Group by Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorGroupByArgs['orderBy'] }
        : { orderBy?: DoctorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Doctor model
   */
  readonly fields: DoctorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Doctor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends Doctor$clinicArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sessions<T extends Doctor$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Doctor$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calls<T extends Doctor$callsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$callsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends Doctor$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    diagnoses<T extends Doctor$diagnosesArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$diagnosesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTasks<T extends Doctor$assignedTasksArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$assignedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Doctor$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staffPersonalInfo<T extends Doctor$staffPersonalInfoArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$staffPersonalInfoArgs<ExtArgs>>): Prisma__StaffPersonalInfoClient<$Result.GetResult<Prisma.$StaffPersonalInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staffEmploymentInfo<T extends Doctor$staffEmploymentInfoArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$staffEmploymentInfoArgs<ExtArgs>>): Prisma__StaffEmploymentInfoClient<$Result.GetResult<Prisma.$StaffEmploymentInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subordinates<T extends Doctor$subordinatesArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$subordinatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffEmploymentInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Doctor model
   */
  interface DoctorFieldRefs {
    readonly id: FieldRef<"Doctor", 'String'>
    readonly clinicId: FieldRef<"Doctor", 'String'>
    readonly email: FieldRef<"Doctor", 'String'>
    readonly passwordHash: FieldRef<"Doctor", 'String'>
    readonly firstName: FieldRef<"Doctor", 'String'>
    readonly lastName: FieldRef<"Doctor", 'String'>
    readonly otp: FieldRef<"Doctor", 'String'>
    readonly licenceNo: FieldRef<"Doctor", 'String'>
    readonly specialities: FieldRef<"Doctor", 'String[]'>
    readonly emailVerifiedAt: FieldRef<"Doctor", 'DateTime'>
    readonly twoFactorSecret: FieldRef<"Doctor", 'String'>
    readonly twoFactorEnabled: FieldRef<"Doctor", 'Boolean'>
    readonly lastLoginAt: FieldRef<"Doctor", 'DateTime'>
    readonly createdAt: FieldRef<"Doctor", 'DateTime'>
    readonly updatedAt: FieldRef<"Doctor", 'DateTime'>
    readonly deletedAt: FieldRef<"Doctor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Doctor findUnique
   */
  export type DoctorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor findUniqueOrThrow
   */
  export type DoctorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor findFirst
   */
  export type DoctorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor findFirstOrThrow
   */
  export type DoctorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor findMany
   */
  export type DoctorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor create
   */
  export type DoctorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to create a Doctor.
     */
    data?: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
  }

  /**
   * Doctor createMany
   */
  export type DoctorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Doctor createManyAndReturn
   */
  export type DoctorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Doctor update
   */
  export type DoctorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to update a Doctor.
     */
    data: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
    /**
     * Choose, which Doctor to update.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor updateMany
   */
  export type DoctorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to update.
     */
    limit?: number
  }

  /**
   * Doctor updateManyAndReturn
   */
  export type DoctorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Doctor upsert
   */
  export type DoctorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The filter to search for the Doctor to update in case it exists.
     */
    where: DoctorWhereUniqueInput
    /**
     * In case the Doctor found by the `where` argument doesn't exist, create a new Doctor with this data.
     */
    create: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
    /**
     * In case the Doctor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
  }

  /**
   * Doctor delete
   */
  export type DoctorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter which Doctor to delete.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor deleteMany
   */
  export type DoctorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctors to delete
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to delete.
     */
    limit?: number
  }

  /**
   * Doctor.clinic
   */
  export type Doctor$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * Doctor.sessions
   */
  export type Doctor$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Doctor.appointments
   */
  export type Doctor$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Doctor.calls
   */
  export type Doctor$callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call
     */
    select?: CallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Call
     */
    omit?: CallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallInclude<ExtArgs> | null
    where?: CallWhereInput
    orderBy?: CallOrderByWithRelationInput | CallOrderByWithRelationInput[]
    cursor?: CallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallScalarFieldEnum | CallScalarFieldEnum[]
  }

  /**
   * Doctor.prescriptions
   */
  export type Doctor$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Doctor.diagnoses
   */
  export type Doctor$diagnosesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    where?: DiagnosisWhereInput
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    cursor?: DiagnosisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Doctor.assignedTasks
   */
  export type Doctor$assignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Doctor.auditLogs
   */
  export type Doctor$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Doctor.staffPersonalInfo
   */
  export type Doctor$staffPersonalInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffPersonalInfo
     */
    select?: StaffPersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffPersonalInfo
     */
    omit?: StaffPersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffPersonalInfoInclude<ExtArgs> | null
    where?: StaffPersonalInfoWhereInput
  }

  /**
   * Doctor.staffEmploymentInfo
   */
  export type Doctor$staffEmploymentInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffEmploymentInfo
     */
    select?: StaffEmploymentInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffEmploymentInfo
     */
    omit?: StaffEmploymentInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffEmploymentInfoInclude<ExtArgs> | null
    where?: StaffEmploymentInfoWhereInput
  }

  /**
   * Doctor.subordinates
   */
  export type Doctor$subordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffEmploymentInfo
     */
    select?: StaffEmploymentInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffEmploymentInfo
     */
    omit?: StaffEmploymentInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffEmploymentInfoInclude<ExtArgs> | null
    where?: StaffEmploymentInfoWhereInput
    orderBy?: StaffEmploymentInfoOrderByWithRelationInput | StaffEmploymentInfoOrderByWithRelationInput[]
    cursor?: StaffEmploymentInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffEmploymentInfoScalarFieldEnum | StaffEmploymentInfoScalarFieldEnum[]
  }

  /**
   * Doctor without action
   */
  export type DoctorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    doctorId: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    doctorId: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    adminId: number
    doctorId: number
    ip: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    adminId?: true
    doctorId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    adminId?: true
    doctorId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    adminId?: true
    doctorId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    adminId: string | null
    doctorId: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    doctorId?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    admin?: boolean | Session$adminArgs<ExtArgs>
    doctor?: boolean | Session$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    doctorId?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    admin?: boolean | Session$adminArgs<ExtArgs>
    doctor?: boolean | Session$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    doctorId?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    admin?: boolean | Session$adminArgs<ExtArgs>
    doctor?: boolean | Session$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    adminId?: boolean
    doctorId?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "doctorId" | "ip" | "userAgent" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Session$adminArgs<ExtArgs>
    doctor?: boolean | Session$doctorArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Session$adminArgs<ExtArgs>
    doctor?: boolean | Session$doctorArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Session$adminArgs<ExtArgs>
    doctor?: boolean | Session$doctorArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
      doctor: Prisma.$DoctorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string | null
      doctorId: string | null
      ip: string | null
      userAgent: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends Session$adminArgs<ExtArgs> = {}>(args?: Subset<T, Session$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    doctor<T extends Session$doctorArgs<ExtArgs> = {}>(args?: Subset<T, Session$doctorArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly adminId: FieldRef<"Session", 'String'>
    readonly doctorId: FieldRef<"Session", 'String'>
    readonly ip: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data?: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session.admin
   */
  export type Session$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * Session.doctor
   */
  export type Session$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    plan: 'plan',
    status: 'status',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    stripeInvoiceId: 'stripeInvoiceId',
    invoiceNo: 'invoiceNo',
    amountDue: 'amountDue',
    amountPaid: 'amountPaid',
    currency: 'currency',
    status: 'status',
    invoicePdfUrl: 'invoicePdfUrl',
    createdAt: 'createdAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const NotificationQueueScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    type: 'type',
    recipient: 'recipient',
    payload: 'payload',
    status: 'status',
    sentAt: 'sentAt',
    createdAt: 'createdAt'
  };

  export type NotificationQueueScalarFieldEnum = (typeof NotificationQueueScalarFieldEnum)[keyof typeof NotificationQueueScalarFieldEnum]


  export const ClinicScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    vatId: 'vatId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicScalarFieldEnum = (typeof ClinicScalarFieldEnum)[keyof typeof ClinicScalarFieldEnum]


  export const ConsentVersionScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    type: 'type',
    version: 'version',
    title: 'title',
    body: 'body',
    effectiveDate: 'effectiveDate',
    createdAt: 'createdAt'
  };

  export type ConsentVersionScalarFieldEnum = (typeof ConsentVersionScalarFieldEnum)[keyof typeof ConsentVersionScalarFieldEnum]


  export const PatientConsentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    consentVersionId: 'consentVersionId',
    type: 'type',
    given: 'given',
    givenAt: 'givenAt',
    withdrawnAt: 'withdrawnAt',
    ip: 'ip',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientConsentScalarFieldEnum = (typeof PatientConsentScalarFieldEnum)[keyof typeof PatientConsentScalarFieldEnum]


  export const KeyManagementScalarFieldEnum: {
    id: 'id',
    version: 'version',
    dekCipher: 'dekCipher',
    createdAt: 'createdAt',
    rotatedAt: 'rotatedAt'
  };

  export type KeyManagementScalarFieldEnum = (typeof KeyManagementScalarFieldEnum)[keyof typeof KeyManagementScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    table: 'table',
    rowId: 'rowId',
    action: 'action',
    oldValues: 'oldValues',
    newValues: 'newValues',
    adminId: 'adminId',
    doctorId: 'doctorId',
    clinicId: 'clinicId',
    ip: 'ip',
    userAgent: 'userAgent',
    occurredAt: 'occurredAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const DataRequestScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    patientId: 'patientId',
    type: 'type',
    status: 'status',
    requestReason: 'requestReason',
    requestedAt: 'requestedAt',
    completedAt: 'completedAt',
    downloadUrl: 'downloadUrl',
    downloadExpiresAt: 'downloadExpiresAt'
  };

  export type DataRequestScalarFieldEnum = (typeof DataRequestScalarFieldEnum)[keyof typeof DataRequestScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    patientId: 'patientId',
    doctorId: 'doctorId',
    startAt: 'startAt',
    endAt: 'endAt',
    status: 'status',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const CallScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    patientId: 'patientId',
    doctorId: 'doctorId',
    startAt: 'startAt',
    endAt: 'endAt',
    durationSeconds: 'durationSeconds',
    status: 'status',
    recordingUrlCipher: 'recordingUrlCipher',
    transcript: 'transcript',
    aiSummary: 'aiSummary',
    sentiment: 'sentiment',
    escalated: 'escalated',
    minutesUsed: 'minutesUsed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    aiModelId: 'aiModelId',
    aiDecision: 'aiDecision'
  };

  export type CallScalarFieldEnum = (typeof CallScalarFieldEnum)[keyof typeof CallScalarFieldEnum]


  export const DiagnosisScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    diagnosisCode: 'diagnosisCode',
    diagnosisName: 'diagnosisName',
    description: 'description',
    status: 'status',
    diagnosedDate: 'diagnosedDate',
    resolvedDate: 'resolvedDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiagnosisScalarFieldEnum = (typeof DiagnosisScalarFieldEnum)[keyof typeof DiagnosisScalarFieldEnum]


  export const LabScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    patientId: 'patientId',
    testDate: 'testDate',
    pdfKeyCipher: 'pdfKeyCipher',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type LabScalarFieldEnum = (typeof LabScalarFieldEnum)[keyof typeof LabScalarFieldEnum]


  export const LabResultScalarFieldEnum: {
    id: 'id',
    labId: 'labId',
    testName: 'testName',
    result: 'result',
    unit: 'unit',
    normalMin: 'normalMin',
    normalMax: 'normalMax',
    flag: 'flag'
  };

  export type LabResultScalarFieldEnum = (typeof LabResultScalarFieldEnum)[keyof typeof LabResultScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    patientId: 'patientId',
    doctorId: 'doctorId',
    prescriptionNo: 'prescriptionNo',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const PrescriptionMedicineScalarFieldEnum: {
    id: 'id',
    prescriptionId: 'prescriptionId',
    medicine: 'medicine',
    strength: 'strength',
    dose: 'dose',
    frequency: 'frequency',
    route: 'route',
    duration: 'duration',
    refill: 'refill'
  };

  export type PrescriptionMedicineScalarFieldEnum = (typeof PrescriptionMedicineScalarFieldEnum)[keyof typeof PrescriptionMedicineScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    firstNameCipher: 'firstNameCipher',
    lastNameCipher: 'lastNameCipher',
    phoneCipher: 'phoneCipher',
    emailCipher: 'emailCipher',
    insuranceIdCipher: 'insuranceIdCipher',
    addressCipher: 'addressCipher',
    emergencyContactCipher: 'emergencyContactCipher',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    bloodGroup: 'bloodGroup',
    conditionName: 'conditionName',
    diagnosedDate: 'diagnosedDate',
    severity: 'severity',
    status: 'status',
    retentionExpiresAt: 'retentionExpiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    firstNameBlind: 'firstNameBlind',
    lastNameBlind: 'lastNameBlind',
    insuranceIdBlind: 'insuranceIdBlind'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const EmergencyContactScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    nameCipher: 'nameCipher',
    relationship: 'relationship',
    phoneCipher: 'phoneCipher',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmergencyContactScalarFieldEnum = (typeof EmergencyContactScalarFieldEnum)[keyof typeof EmergencyContactScalarFieldEnum]


  export const StaffPersonalInfoScalarFieldEnum: {
    id: 'id',
    doctorId: 'doctorId',
    dateOfBirth: 'dateOfBirth',
    phoneCipher: 'phoneCipher',
    addressCipher: 'addressCipher',
    stateProvince: 'stateProvince',
    postalCode: 'postalCode',
    country: 'country',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    emergencyContactRelationship: 'emergencyContactRelationship',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffPersonalInfoScalarFieldEnum = (typeof StaffPersonalInfoScalarFieldEnum)[keyof typeof StaffPersonalInfoScalarFieldEnum]


  export const StaffEmploymentInfoScalarFieldEnum: {
    id: 'id',
    doctorId: 'doctorId',
    employeeId: 'employeeId',
    department: 'department',
    position: 'position',
    reportingToId: 'reportingToId',
    joinDate: 'joinDate',
    employmentType: 'employmentType',
    workSchedule: 'workSchedule',
    weeklyHours: 'weeklyHours',
    salaryCipher: 'salaryCipher',
    employmentStatus: 'employmentStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffEmploymentInfoScalarFieldEnum = (typeof StaffEmploymentInfoScalarFieldEnum)[keyof typeof StaffEmploymentInfoScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    assigneeDoctorId: 'assigneeDoctorId',
    assigneeAdminId: 'assigneeAdminId',
    patientId: 'patientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const SystemMetricScalarFieldEnum: {
    id: 'id',
    serviceName: 'serviceName',
    metricType: 'metricType',
    value: 'value',
    unit: 'unit',
    recordedAt: 'recordedAt',
    createdAt: 'createdAt'
  };

  export type SystemMetricScalarFieldEnum = (typeof SystemMetricScalarFieldEnum)[keyof typeof SystemMetricScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    otp: 'otp',
    emailVerifiedAt: 'emailVerifiedAt',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorEnabled: 'twoFactorEnabled',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const DoctorScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    otp: 'otp',
    licenceNo: 'licenceNo',
    specialities: 'specialities',
    emailVerifiedAt: 'emailVerifiedAt',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorEnabled: 'twoFactorEnabled',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type DoctorScalarFieldEnum = (typeof DoctorScalarFieldEnum)[keyof typeof DoctorScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    doctorId: 'doctorId',
    ip: 'ip',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Plan'
   */
  export type EnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan'>
    


  /**
   * Reference to a field of type 'Plan[]'
   */
  export type ListEnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'ConsentType'
   */
  export type EnumConsentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentType'>
    


  /**
   * Reference to a field of type 'ConsentType[]'
   */
  export type ListEnumConsentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'DataRequestType'
   */
  export type EnumDataRequestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataRequestType'>
    


  /**
   * Reference to a field of type 'DataRequestType[]'
   */
  export type ListEnumDataRequestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataRequestType[]'>
    


  /**
   * Reference to a field of type 'DataRequestStatus'
   */
  export type EnumDataRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataRequestStatus'>
    


  /**
   * Reference to a field of type 'DataRequestStatus[]'
   */
  export type ListEnumDataRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataRequestStatus[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'CallStatus'
   */
  export type EnumCallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallStatus'>
    


  /**
   * Reference to a field of type 'CallStatus[]'
   */
  export type ListEnumCallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallStatus[]'>
    


  /**
   * Reference to a field of type 'Sentiment'
   */
  export type EnumSentimentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sentiment'>
    


  /**
   * Reference to a field of type 'Sentiment[]'
   */
  export type ListEnumSentimentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sentiment[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Flag'
   */
  export type EnumFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Flag'>
    


  /**
   * Reference to a field of type 'Flag[]'
   */
  export type ListEnumFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Flag[]'>
    


  /**
   * Reference to a field of type 'PrescriptionStatus'
   */
  export type EnumPrescriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrescriptionStatus'>
    


  /**
   * Reference to a field of type 'PrescriptionStatus[]'
   */
  export type ListEnumPrescriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrescriptionStatus[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Department'
   */
  export type EnumDepartmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Department'>
    


  /**
   * Reference to a field of type 'Department[]'
   */
  export type ListEnumDepartmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Department[]'>
    


  /**
   * Reference to a field of type 'EmploymentType'
   */
  export type EnumEmploymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentType'>
    


  /**
   * Reference to a field of type 'EmploymentType[]'
   */
  export type ListEnumEmploymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentType[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'ServiceName'
   */
  export type EnumServiceNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceName'>
    


  /**
   * Reference to a field of type 'ServiceName[]'
   */
  export type ListEnumServiceNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceName[]'>
    


  /**
   * Reference to a field of type 'MetricType'
   */
  export type EnumMetricTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetricType'>
    


  /**
   * Reference to a field of type 'MetricType[]'
   */
  export type ListEnumMetricTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetricType[]'>
    
  /**
   * Deep Input Types
   */


  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: UuidFilter<"Subscription"> | string
    clinicId?: UuidNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    plan?: EnumPlanNullableFilter<"Subscription"> | $Enums.Plan | null
    status?: EnumSubscriptionStatusNullableFilter<"Subscription"> | $Enums.SubscriptionStatus | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    plan?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    clinic?: ClinicOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clinicId?: string
    stripeCustomerId?: string
    stripeSubscriptionId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    plan?: EnumPlanNullableFilter<"Subscription"> | $Enums.Plan | null
    status?: EnumSubscriptionStatusNullableFilter<"Subscription"> | $Enums.SubscriptionStatus | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
  }, "id" | "clinicId" | "stripeCustomerId" | "stripeSubscriptionId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    plan?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Subscription"> | string
    clinicId?: UuidNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    plan?: EnumPlanNullableWithAggregatesFilter<"Subscription"> | $Enums.Plan | null
    status?: EnumSubscriptionStatusNullableWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus | null
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    clinicId?: UuidNullableFilter<"Invoice"> | string | null
    stripeInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    invoiceNo?: StringNullableFilter<"Invoice"> | string | null
    amountDue?: IntNullableFilter<"Invoice"> | number | null
    amountPaid?: IntNullableFilter<"Invoice"> | number | null
    currency?: StringNullableFilter<"Invoice"> | string | null
    status?: StringNullableFilter<"Invoice"> | string | null
    invoicePdfUrl?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    invoiceNo?: SortOrderInput | SortOrder
    amountDue?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    invoicePdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    clinic?: ClinicOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeInvoiceId?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    clinicId?: UuidNullableFilter<"Invoice"> | string | null
    invoiceNo?: StringNullableFilter<"Invoice"> | string | null
    amountDue?: IntNullableFilter<"Invoice"> | number | null
    amountPaid?: IntNullableFilter<"Invoice"> | number | null
    currency?: StringNullableFilter<"Invoice"> | string | null
    status?: StringNullableFilter<"Invoice"> | string | null
    invoicePdfUrl?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
  }, "id" | "stripeInvoiceId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    invoiceNo?: SortOrderInput | SortOrder
    amountDue?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    invoicePdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Invoice"> | string
    clinicId?: UuidNullableWithAggregatesFilter<"Invoice"> | string | null
    stripeInvoiceId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    invoiceNo?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    amountDue?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
    amountPaid?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
    currency?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    status?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    invoicePdfUrl?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
  }

  export type NotificationQueueWhereInput = {
    AND?: NotificationQueueWhereInput | NotificationQueueWhereInput[]
    OR?: NotificationQueueWhereInput[]
    NOT?: NotificationQueueWhereInput | NotificationQueueWhereInput[]
    id?: UuidFilter<"NotificationQueue"> | string
    clinicId?: UuidNullableFilter<"NotificationQueue"> | string | null
    type?: EnumNotificationTypeNullableFilter<"NotificationQueue"> | $Enums.NotificationType | null
    recipient?: StringNullableFilter<"NotificationQueue"> | string | null
    payload?: JsonNullableFilter<"NotificationQueue">
    status?: EnumNotificationStatusNullableFilter<"NotificationQueue"> | $Enums.NotificationStatus | null
    sentAt?: DateTimeNullableFilter<"NotificationQueue"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"NotificationQueue"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
  }

  export type NotificationQueueOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    recipient?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    clinic?: ClinicOrderByWithRelationInput
  }

  export type NotificationQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationQueueWhereInput | NotificationQueueWhereInput[]
    OR?: NotificationQueueWhereInput[]
    NOT?: NotificationQueueWhereInput | NotificationQueueWhereInput[]
    clinicId?: UuidNullableFilter<"NotificationQueue"> | string | null
    type?: EnumNotificationTypeNullableFilter<"NotificationQueue"> | $Enums.NotificationType | null
    recipient?: StringNullableFilter<"NotificationQueue"> | string | null
    payload?: JsonNullableFilter<"NotificationQueue">
    status?: EnumNotificationStatusNullableFilter<"NotificationQueue"> | $Enums.NotificationStatus | null
    sentAt?: DateTimeNullableFilter<"NotificationQueue"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"NotificationQueue"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
  }, "id">

  export type NotificationQueueOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    recipient?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: NotificationQueueCountOrderByAggregateInput
    _max?: NotificationQueueMaxOrderByAggregateInput
    _min?: NotificationQueueMinOrderByAggregateInput
  }

  export type NotificationQueueScalarWhereWithAggregatesInput = {
    AND?: NotificationQueueScalarWhereWithAggregatesInput | NotificationQueueScalarWhereWithAggregatesInput[]
    OR?: NotificationQueueScalarWhereWithAggregatesInput[]
    NOT?: NotificationQueueScalarWhereWithAggregatesInput | NotificationQueueScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"NotificationQueue"> | string
    clinicId?: UuidNullableWithAggregatesFilter<"NotificationQueue"> | string | null
    type?: EnumNotificationTypeNullableWithAggregatesFilter<"NotificationQueue"> | $Enums.NotificationType | null
    recipient?: StringNullableWithAggregatesFilter<"NotificationQueue"> | string | null
    payload?: JsonNullableWithAggregatesFilter<"NotificationQueue">
    status?: EnumNotificationStatusNullableWithAggregatesFilter<"NotificationQueue"> | $Enums.NotificationStatus | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"NotificationQueue"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"NotificationQueue"> | Date | string | null
  }

  export type ClinicWhereInput = {
    AND?: ClinicWhereInput | ClinicWhereInput[]
    OR?: ClinicWhereInput[]
    NOT?: ClinicWhereInput | ClinicWhereInput[]
    id?: UuidFilter<"Clinic"> | string
    name?: StringNullableFilter<"Clinic"> | string | null
    address?: StringNullableFilter<"Clinic"> | string | null
    vatId?: StringNullableFilter<"Clinic"> | string | null
    createdAt?: DateTimeNullableFilter<"Clinic"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Clinic"> | Date | string | null
    admins?: AdminListRelationFilter
    doctors?: DoctorListRelationFilter
    patients?: PatientListRelationFilter
    appointments?: AppointmentListRelationFilter
    calls?: CallListRelationFilter
    labs?: LabListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    tasks?: TaskListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    invoices?: InvoiceListRelationFilter
    notificationQueues?: NotificationQueueListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    dataRequests?: DataRequestListRelationFilter
    consentVersions?: ConsentVersionListRelationFilter
  }

  export type ClinicOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    vatId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    admins?: AdminOrderByRelationAggregateInput
    doctors?: DoctorOrderByRelationAggregateInput
    patients?: PatientOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    calls?: CallOrderByRelationAggregateInput
    labs?: LabOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    notificationQueues?: NotificationQueueOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    dataRequests?: DataRequestOrderByRelationAggregateInput
    consentVersions?: ConsentVersionOrderByRelationAggregateInput
  }

  export type ClinicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vatId?: string
    AND?: ClinicWhereInput | ClinicWhereInput[]
    OR?: ClinicWhereInput[]
    NOT?: ClinicWhereInput | ClinicWhereInput[]
    name?: StringNullableFilter<"Clinic"> | string | null
    address?: StringNullableFilter<"Clinic"> | string | null
    createdAt?: DateTimeNullableFilter<"Clinic"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Clinic"> | Date | string | null
    admins?: AdminListRelationFilter
    doctors?: DoctorListRelationFilter
    patients?: PatientListRelationFilter
    appointments?: AppointmentListRelationFilter
    calls?: CallListRelationFilter
    labs?: LabListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    tasks?: TaskListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    invoices?: InvoiceListRelationFilter
    notificationQueues?: NotificationQueueListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    dataRequests?: DataRequestListRelationFilter
    consentVersions?: ConsentVersionListRelationFilter
  }, "id" | "vatId">

  export type ClinicOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    vatId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ClinicCountOrderByAggregateInput
    _max?: ClinicMaxOrderByAggregateInput
    _min?: ClinicMinOrderByAggregateInput
  }

  export type ClinicScalarWhereWithAggregatesInput = {
    AND?: ClinicScalarWhereWithAggregatesInput | ClinicScalarWhereWithAggregatesInput[]
    OR?: ClinicScalarWhereWithAggregatesInput[]
    NOT?: ClinicScalarWhereWithAggregatesInput | ClinicScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Clinic"> | string
    name?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    address?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    vatId?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Clinic"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Clinic"> | Date | string | null
  }

  export type ConsentVersionWhereInput = {
    AND?: ConsentVersionWhereInput | ConsentVersionWhereInput[]
    OR?: ConsentVersionWhereInput[]
    NOT?: ConsentVersionWhereInput | ConsentVersionWhereInput[]
    id?: UuidFilter<"ConsentVersion"> | string
    clinicId?: UuidNullableFilter<"ConsentVersion"> | string | null
    type?: EnumConsentTypeNullableFilter<"ConsentVersion"> | $Enums.ConsentType | null
    version?: StringNullableFilter<"ConsentVersion"> | string | null
    title?: StringNullableFilter<"ConsentVersion"> | string | null
    body?: StringNullableFilter<"ConsentVersion"> | string | null
    effectiveDate?: DateTimeNullableFilter<"ConsentVersion"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"ConsentVersion"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    patientConsents?: PatientConsentListRelationFilter
  }

  export type ConsentVersionOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    effectiveDate?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    clinic?: ClinicOrderByWithRelationInput
    patientConsents?: PatientConsentOrderByRelationAggregateInput
  }

  export type ConsentVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsentVersionWhereInput | ConsentVersionWhereInput[]
    OR?: ConsentVersionWhereInput[]
    NOT?: ConsentVersionWhereInput | ConsentVersionWhereInput[]
    clinicId?: UuidNullableFilter<"ConsentVersion"> | string | null
    type?: EnumConsentTypeNullableFilter<"ConsentVersion"> | $Enums.ConsentType | null
    version?: StringNullableFilter<"ConsentVersion"> | string | null
    title?: StringNullableFilter<"ConsentVersion"> | string | null
    body?: StringNullableFilter<"ConsentVersion"> | string | null
    effectiveDate?: DateTimeNullableFilter<"ConsentVersion"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"ConsentVersion"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    patientConsents?: PatientConsentListRelationFilter
  }, "id">

  export type ConsentVersionOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    effectiveDate?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: ConsentVersionCountOrderByAggregateInput
    _max?: ConsentVersionMaxOrderByAggregateInput
    _min?: ConsentVersionMinOrderByAggregateInput
  }

  export type ConsentVersionScalarWhereWithAggregatesInput = {
    AND?: ConsentVersionScalarWhereWithAggregatesInput | ConsentVersionScalarWhereWithAggregatesInput[]
    OR?: ConsentVersionScalarWhereWithAggregatesInput[]
    NOT?: ConsentVersionScalarWhereWithAggregatesInput | ConsentVersionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ConsentVersion"> | string
    clinicId?: UuidNullableWithAggregatesFilter<"ConsentVersion"> | string | null
    type?: EnumConsentTypeNullableWithAggregatesFilter<"ConsentVersion"> | $Enums.ConsentType | null
    version?: StringNullableWithAggregatesFilter<"ConsentVersion"> | string | null
    title?: StringNullableWithAggregatesFilter<"ConsentVersion"> | string | null
    body?: StringNullableWithAggregatesFilter<"ConsentVersion"> | string | null
    effectiveDate?: DateTimeNullableWithAggregatesFilter<"ConsentVersion"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"ConsentVersion"> | Date | string | null
  }

  export type PatientConsentWhereInput = {
    AND?: PatientConsentWhereInput | PatientConsentWhereInput[]
    OR?: PatientConsentWhereInput[]
    NOT?: PatientConsentWhereInput | PatientConsentWhereInput[]
    id?: UuidFilter<"PatientConsent"> | string
    patientId?: UuidNullableFilter<"PatientConsent"> | string | null
    consentVersionId?: UuidNullableFilter<"PatientConsent"> | string | null
    type?: EnumConsentTypeNullableFilter<"PatientConsent"> | $Enums.ConsentType | null
    given?: BoolNullableFilter<"PatientConsent"> | boolean | null
    givenAt?: DateTimeNullableFilter<"PatientConsent"> | Date | string | null
    withdrawnAt?: DateTimeNullableFilter<"PatientConsent"> | Date | string | null
    ip?: StringNullableFilter<"PatientConsent"> | string | null
    userAgent?: StringNullableFilter<"PatientConsent"> | string | null
    createdAt?: DateTimeNullableFilter<"PatientConsent"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"PatientConsent"> | Date | string | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    consentVersion?: XOR<ConsentVersionNullableScalarRelationFilter, ConsentVersionWhereInput> | null
  }

  export type PatientConsentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    consentVersionId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    given?: SortOrderInput | SortOrder
    givenAt?: SortOrderInput | SortOrder
    withdrawnAt?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    consentVersion?: ConsentVersionOrderByWithRelationInput
  }

  export type PatientConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PatientConsentWhereInput | PatientConsentWhereInput[]
    OR?: PatientConsentWhereInput[]
    NOT?: PatientConsentWhereInput | PatientConsentWhereInput[]
    patientId?: UuidNullableFilter<"PatientConsent"> | string | null
    consentVersionId?: UuidNullableFilter<"PatientConsent"> | string | null
    type?: EnumConsentTypeNullableFilter<"PatientConsent"> | $Enums.ConsentType | null
    given?: BoolNullableFilter<"PatientConsent"> | boolean | null
    givenAt?: DateTimeNullableFilter<"PatientConsent"> | Date | string | null
    withdrawnAt?: DateTimeNullableFilter<"PatientConsent"> | Date | string | null
    ip?: StringNullableFilter<"PatientConsent"> | string | null
    userAgent?: StringNullableFilter<"PatientConsent"> | string | null
    createdAt?: DateTimeNullableFilter<"PatientConsent"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"PatientConsent"> | Date | string | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    consentVersion?: XOR<ConsentVersionNullableScalarRelationFilter, ConsentVersionWhereInput> | null
  }, "id">

  export type PatientConsentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    consentVersionId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    given?: SortOrderInput | SortOrder
    givenAt?: SortOrderInput | SortOrder
    withdrawnAt?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: PatientConsentCountOrderByAggregateInput
    _max?: PatientConsentMaxOrderByAggregateInput
    _min?: PatientConsentMinOrderByAggregateInput
  }

  export type PatientConsentScalarWhereWithAggregatesInput = {
    AND?: PatientConsentScalarWhereWithAggregatesInput | PatientConsentScalarWhereWithAggregatesInput[]
    OR?: PatientConsentScalarWhereWithAggregatesInput[]
    NOT?: PatientConsentScalarWhereWithAggregatesInput | PatientConsentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PatientConsent"> | string
    patientId?: UuidNullableWithAggregatesFilter<"PatientConsent"> | string | null
    consentVersionId?: UuidNullableWithAggregatesFilter<"PatientConsent"> | string | null
    type?: EnumConsentTypeNullableWithAggregatesFilter<"PatientConsent"> | $Enums.ConsentType | null
    given?: BoolNullableWithAggregatesFilter<"PatientConsent"> | boolean | null
    givenAt?: DateTimeNullableWithAggregatesFilter<"PatientConsent"> | Date | string | null
    withdrawnAt?: DateTimeNullableWithAggregatesFilter<"PatientConsent"> | Date | string | null
    ip?: StringNullableWithAggregatesFilter<"PatientConsent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"PatientConsent"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"PatientConsent"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"PatientConsent"> | Date | string | null
  }

  export type KeyManagementWhereInput = {
    AND?: KeyManagementWhereInput | KeyManagementWhereInput[]
    OR?: KeyManagementWhereInput[]
    NOT?: KeyManagementWhereInput | KeyManagementWhereInput[]
    id?: UuidFilter<"KeyManagement"> | string
    version?: StringNullableFilter<"KeyManagement"> | string | null
    dekCipher?: BytesNullableFilter<"KeyManagement"> | Uint8Array | null
    createdAt?: DateTimeNullableFilter<"KeyManagement"> | Date | string | null
    rotatedAt?: DateTimeNullableFilter<"KeyManagement"> | Date | string | null
  }

  export type KeyManagementOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrderInput | SortOrder
    dekCipher?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    rotatedAt?: SortOrderInput | SortOrder
  }

  export type KeyManagementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    version?: string
    AND?: KeyManagementWhereInput | KeyManagementWhereInput[]
    OR?: KeyManagementWhereInput[]
    NOT?: KeyManagementWhereInput | KeyManagementWhereInput[]
    dekCipher?: BytesNullableFilter<"KeyManagement"> | Uint8Array | null
    createdAt?: DateTimeNullableFilter<"KeyManagement"> | Date | string | null
    rotatedAt?: DateTimeNullableFilter<"KeyManagement"> | Date | string | null
  }, "id" | "version">

  export type KeyManagementOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrderInput | SortOrder
    dekCipher?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    rotatedAt?: SortOrderInput | SortOrder
    _count?: KeyManagementCountOrderByAggregateInput
    _max?: KeyManagementMaxOrderByAggregateInput
    _min?: KeyManagementMinOrderByAggregateInput
  }

  export type KeyManagementScalarWhereWithAggregatesInput = {
    AND?: KeyManagementScalarWhereWithAggregatesInput | KeyManagementScalarWhereWithAggregatesInput[]
    OR?: KeyManagementScalarWhereWithAggregatesInput[]
    NOT?: KeyManagementScalarWhereWithAggregatesInput | KeyManagementScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"KeyManagement"> | string
    version?: StringNullableWithAggregatesFilter<"KeyManagement"> | string | null
    dekCipher?: BytesNullableWithAggregatesFilter<"KeyManagement"> | Uint8Array | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"KeyManagement"> | Date | string | null
    rotatedAt?: DateTimeNullableWithAggregatesFilter<"KeyManagement"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    table?: StringNullableFilter<"AuditLog"> | string | null
    rowId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    adminId?: UuidNullableFilter<"AuditLog"> | string | null
    doctorId?: UuidNullableFilter<"AuditLog"> | string | null
    clinicId?: UuidNullableFilter<"AuditLog"> | string | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    occurredAt?: DateTimeNullableFilter<"AuditLog"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    table?: SortOrderInput | SortOrder
    rowId?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    occurredAt?: SortOrderInput | SortOrder
    clinic?: ClinicOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    table?: StringNullableFilter<"AuditLog"> | string | null
    rowId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    adminId?: UuidNullableFilter<"AuditLog"> | string | null
    doctorId?: UuidNullableFilter<"AuditLog"> | string | null
    clinicId?: UuidNullableFilter<"AuditLog"> | string | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    occurredAt?: DateTimeNullableFilter<"AuditLog"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    table?: SortOrderInput | SortOrder
    rowId?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    occurredAt?: SortOrderInput | SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuditLog"> | string
    table?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    rowId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    adminId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    doctorId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    clinicId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    ip?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    occurredAt?: DateTimeNullableWithAggregatesFilter<"AuditLog"> | Date | string | null
  }

  export type DataRequestWhereInput = {
    AND?: DataRequestWhereInput | DataRequestWhereInput[]
    OR?: DataRequestWhereInput[]
    NOT?: DataRequestWhereInput | DataRequestWhereInput[]
    id?: UuidFilter<"DataRequest"> | string
    clinicId?: UuidNullableFilter<"DataRequest"> | string | null
    patientId?: UuidNullableFilter<"DataRequest"> | string | null
    type?: EnumDataRequestTypeNullableFilter<"DataRequest"> | $Enums.DataRequestType | null
    status?: EnumDataRequestStatusNullableFilter<"DataRequest"> | $Enums.DataRequestStatus | null
    requestReason?: StringNullableFilter<"DataRequest"> | string | null
    requestedAt?: DateTimeNullableFilter<"DataRequest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DataRequest"> | Date | string | null
    downloadUrl?: StringNullableFilter<"DataRequest"> | string | null
    downloadExpiresAt?: DateTimeNullableFilter<"DataRequest"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
  }

  export type DataRequestOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    requestReason?: SortOrderInput | SortOrder
    requestedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    downloadExpiresAt?: SortOrderInput | SortOrder
    clinic?: ClinicOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type DataRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DataRequestWhereInput | DataRequestWhereInput[]
    OR?: DataRequestWhereInput[]
    NOT?: DataRequestWhereInput | DataRequestWhereInput[]
    clinicId?: UuidNullableFilter<"DataRequest"> | string | null
    patientId?: UuidNullableFilter<"DataRequest"> | string | null
    type?: EnumDataRequestTypeNullableFilter<"DataRequest"> | $Enums.DataRequestType | null
    status?: EnumDataRequestStatusNullableFilter<"DataRequest"> | $Enums.DataRequestStatus | null
    requestReason?: StringNullableFilter<"DataRequest"> | string | null
    requestedAt?: DateTimeNullableFilter<"DataRequest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DataRequest"> | Date | string | null
    downloadUrl?: StringNullableFilter<"DataRequest"> | string | null
    downloadExpiresAt?: DateTimeNullableFilter<"DataRequest"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
  }, "id">

  export type DataRequestOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    requestReason?: SortOrderInput | SortOrder
    requestedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    downloadExpiresAt?: SortOrderInput | SortOrder
    _count?: DataRequestCountOrderByAggregateInput
    _max?: DataRequestMaxOrderByAggregateInput
    _min?: DataRequestMinOrderByAggregateInput
  }

  export type DataRequestScalarWhereWithAggregatesInput = {
    AND?: DataRequestScalarWhereWithAggregatesInput | DataRequestScalarWhereWithAggregatesInput[]
    OR?: DataRequestScalarWhereWithAggregatesInput[]
    NOT?: DataRequestScalarWhereWithAggregatesInput | DataRequestScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DataRequest"> | string
    clinicId?: UuidNullableWithAggregatesFilter<"DataRequest"> | string | null
    patientId?: UuidNullableWithAggregatesFilter<"DataRequest"> | string | null
    type?: EnumDataRequestTypeNullableWithAggregatesFilter<"DataRequest"> | $Enums.DataRequestType | null
    status?: EnumDataRequestStatusNullableWithAggregatesFilter<"DataRequest"> | $Enums.DataRequestStatus | null
    requestReason?: StringNullableWithAggregatesFilter<"DataRequest"> | string | null
    requestedAt?: DateTimeNullableWithAggregatesFilter<"DataRequest"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"DataRequest"> | Date | string | null
    downloadUrl?: StringNullableWithAggregatesFilter<"DataRequest"> | string | null
    downloadExpiresAt?: DateTimeNullableWithAggregatesFilter<"DataRequest"> | Date | string | null
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: UuidFilter<"Appointment"> | string
    clinicId?: UuidNullableFilter<"Appointment"> | string | null
    patientId?: UuidNullableFilter<"Appointment"> | string | null
    doctorId?: UuidNullableFilter<"Appointment"> | string | null
    startAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    endAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    status?: EnumAppointmentStatusNullableFilter<"Appointment"> | $Enums.AppointmentStatus | null
    note?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    clinic?: ClinicOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    clinicId?: UuidNullableFilter<"Appointment"> | string | null
    patientId?: UuidNullableFilter<"Appointment"> | string | null
    doctorId?: UuidNullableFilter<"Appointment"> | string | null
    startAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    endAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    status?: EnumAppointmentStatusNullableFilter<"Appointment"> | $Enums.AppointmentStatus | null
    note?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Appointment"> | string
    clinicId?: UuidNullableWithAggregatesFilter<"Appointment"> | string | null
    patientId?: UuidNullableWithAggregatesFilter<"Appointment"> | string | null
    doctorId?: UuidNullableWithAggregatesFilter<"Appointment"> | string | null
    startAt?: DateTimeNullableWithAggregatesFilter<"Appointment"> | Date | string | null
    endAt?: DateTimeNullableWithAggregatesFilter<"Appointment"> | Date | string | null
    status?: EnumAppointmentStatusNullableWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus | null
    note?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Appointment"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Appointment"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Appointment"> | Date | string | null
  }

  export type CallWhereInput = {
    AND?: CallWhereInput | CallWhereInput[]
    OR?: CallWhereInput[]
    NOT?: CallWhereInput | CallWhereInput[]
    id?: UuidFilter<"Call"> | string
    clinicId?: UuidNullableFilter<"Call"> | string | null
    patientId?: UuidNullableFilter<"Call"> | string | null
    doctorId?: UuidNullableFilter<"Call"> | string | null
    startAt?: DateTimeNullableFilter<"Call"> | Date | string | null
    endAt?: DateTimeNullableFilter<"Call"> | Date | string | null
    durationSeconds?: IntNullableFilter<"Call"> | number | null
    status?: EnumCallStatusNullableFilter<"Call"> | $Enums.CallStatus | null
    recordingUrlCipher?: StringNullableFilter<"Call"> | string | null
    transcript?: StringNullableFilter<"Call"> | string | null
    aiSummary?: StringNullableFilter<"Call"> | string | null
    sentiment?: EnumSentimentNullableFilter<"Call"> | $Enums.Sentiment | null
    escalated?: BoolNullableFilter<"Call"> | boolean | null
    minutesUsed?: IntNullableFilter<"Call"> | number | null
    createdAt?: DateTimeNullableFilter<"Call"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Call"> | Date | string | null
    aiModelId?: UuidNullableFilter<"Call"> | string | null
    aiDecision?: StringNullableFilter<"Call"> | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }

  export type CallOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    recordingUrlCipher?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    aiSummary?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    escalated?: SortOrderInput | SortOrder
    minutesUsed?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    aiModelId?: SortOrderInput | SortOrder
    aiDecision?: SortOrderInput | SortOrder
    clinic?: ClinicOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
  }

  export type CallWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CallWhereInput | CallWhereInput[]
    OR?: CallWhereInput[]
    NOT?: CallWhereInput | CallWhereInput[]
    clinicId?: UuidNullableFilter<"Call"> | string | null
    patientId?: UuidNullableFilter<"Call"> | string | null
    doctorId?: UuidNullableFilter<"Call"> | string | null
    startAt?: DateTimeNullableFilter<"Call"> | Date | string | null
    endAt?: DateTimeNullableFilter<"Call"> | Date | string | null
    durationSeconds?: IntNullableFilter<"Call"> | number | null
    status?: EnumCallStatusNullableFilter<"Call"> | $Enums.CallStatus | null
    recordingUrlCipher?: StringNullableFilter<"Call"> | string | null
    transcript?: StringNullableFilter<"Call"> | string | null
    aiSummary?: StringNullableFilter<"Call"> | string | null
    sentiment?: EnumSentimentNullableFilter<"Call"> | $Enums.Sentiment | null
    escalated?: BoolNullableFilter<"Call"> | boolean | null
    minutesUsed?: IntNullableFilter<"Call"> | number | null
    createdAt?: DateTimeNullableFilter<"Call"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Call"> | Date | string | null
    aiModelId?: UuidNullableFilter<"Call"> | string | null
    aiDecision?: StringNullableFilter<"Call"> | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }, "id">

  export type CallOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    recordingUrlCipher?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    aiSummary?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    escalated?: SortOrderInput | SortOrder
    minutesUsed?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    aiModelId?: SortOrderInput | SortOrder
    aiDecision?: SortOrderInput | SortOrder
    _count?: CallCountOrderByAggregateInput
    _avg?: CallAvgOrderByAggregateInput
    _max?: CallMaxOrderByAggregateInput
    _min?: CallMinOrderByAggregateInput
    _sum?: CallSumOrderByAggregateInput
  }

  export type CallScalarWhereWithAggregatesInput = {
    AND?: CallScalarWhereWithAggregatesInput | CallScalarWhereWithAggregatesInput[]
    OR?: CallScalarWhereWithAggregatesInput[]
    NOT?: CallScalarWhereWithAggregatesInput | CallScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Call"> | string
    clinicId?: UuidNullableWithAggregatesFilter<"Call"> | string | null
    patientId?: UuidNullableWithAggregatesFilter<"Call"> | string | null
    doctorId?: UuidNullableWithAggregatesFilter<"Call"> | string | null
    startAt?: DateTimeNullableWithAggregatesFilter<"Call"> | Date | string | null
    endAt?: DateTimeNullableWithAggregatesFilter<"Call"> | Date | string | null
    durationSeconds?: IntNullableWithAggregatesFilter<"Call"> | number | null
    status?: EnumCallStatusNullableWithAggregatesFilter<"Call"> | $Enums.CallStatus | null
    recordingUrlCipher?: StringNullableWithAggregatesFilter<"Call"> | string | null
    transcript?: StringNullableWithAggregatesFilter<"Call"> | string | null
    aiSummary?: StringNullableWithAggregatesFilter<"Call"> | string | null
    sentiment?: EnumSentimentNullableWithAggregatesFilter<"Call"> | $Enums.Sentiment | null
    escalated?: BoolNullableWithAggregatesFilter<"Call"> | boolean | null
    minutesUsed?: IntNullableWithAggregatesFilter<"Call"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Call"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Call"> | Date | string | null
    aiModelId?: UuidNullableWithAggregatesFilter<"Call"> | string | null
    aiDecision?: StringNullableWithAggregatesFilter<"Call"> | string | null
  }

  export type DiagnosisWhereInput = {
    AND?: DiagnosisWhereInput | DiagnosisWhereInput[]
    OR?: DiagnosisWhereInput[]
    NOT?: DiagnosisWhereInput | DiagnosisWhereInput[]
    id?: UuidFilter<"Diagnosis"> | string
    patientId?: UuidNullableFilter<"Diagnosis"> | string | null
    doctorId?: UuidNullableFilter<"Diagnosis"> | string | null
    diagnosisCode?: StringNullableFilter<"Diagnosis"> | string | null
    diagnosisName?: StringNullableFilter<"Diagnosis"> | string | null
    description?: StringNullableFilter<"Diagnosis"> | string | null
    status?: StringNullableFilter<"Diagnosis"> | string | null
    diagnosedDate?: DateTimeNullableFilter<"Diagnosis"> | Date | string | null
    resolvedDate?: DateTimeNullableFilter<"Diagnosis"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Diagnosis"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Diagnosis"> | Date | string | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }

  export type DiagnosisOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    diagnosisCode?: SortOrderInput | SortOrder
    diagnosisName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    diagnosedDate?: SortOrderInput | SortOrder
    resolvedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
  }

  export type DiagnosisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DiagnosisWhereInput | DiagnosisWhereInput[]
    OR?: DiagnosisWhereInput[]
    NOT?: DiagnosisWhereInput | DiagnosisWhereInput[]
    patientId?: UuidNullableFilter<"Diagnosis"> | string | null
    doctorId?: UuidNullableFilter<"Diagnosis"> | string | null
    diagnosisCode?: StringNullableFilter<"Diagnosis"> | string | null
    diagnosisName?: StringNullableFilter<"Diagnosis"> | string | null
    description?: StringNullableFilter<"Diagnosis"> | string | null
    status?: StringNullableFilter<"Diagnosis"> | string | null
    diagnosedDate?: DateTimeNullableFilter<"Diagnosis"> | Date | string | null
    resolvedDate?: DateTimeNullableFilter<"Diagnosis"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Diagnosis"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Diagnosis"> | Date | string | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }, "id">

  export type DiagnosisOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    diagnosisCode?: SortOrderInput | SortOrder
    diagnosisName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    diagnosedDate?: SortOrderInput | SortOrder
    resolvedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: DiagnosisCountOrderByAggregateInput
    _max?: DiagnosisMaxOrderByAggregateInput
    _min?: DiagnosisMinOrderByAggregateInput
  }

  export type DiagnosisScalarWhereWithAggregatesInput = {
    AND?: DiagnosisScalarWhereWithAggregatesInput | DiagnosisScalarWhereWithAggregatesInput[]
    OR?: DiagnosisScalarWhereWithAggregatesInput[]
    NOT?: DiagnosisScalarWhereWithAggregatesInput | DiagnosisScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Diagnosis"> | string
    patientId?: UuidNullableWithAggregatesFilter<"Diagnosis"> | string | null
    doctorId?: UuidNullableWithAggregatesFilter<"Diagnosis"> | string | null
    diagnosisCode?: StringNullableWithAggregatesFilter<"Diagnosis"> | string | null
    diagnosisName?: StringNullableWithAggregatesFilter<"Diagnosis"> | string | null
    description?: StringNullableWithAggregatesFilter<"Diagnosis"> | string | null
    status?: StringNullableWithAggregatesFilter<"Diagnosis"> | string | null
    diagnosedDate?: DateTimeNullableWithAggregatesFilter<"Diagnosis"> | Date | string | null
    resolvedDate?: DateTimeNullableWithAggregatesFilter<"Diagnosis"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Diagnosis"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Diagnosis"> | Date | string | null
  }

  export type LabWhereInput = {
    AND?: LabWhereInput | LabWhereInput[]
    OR?: LabWhereInput[]
    NOT?: LabWhereInput | LabWhereInput[]
    id?: UuidFilter<"Lab"> | string
    clinicId?: UuidNullableFilter<"Lab"> | string | null
    patientId?: UuidNullableFilter<"Lab"> | string | null
    testDate?: DateTimeNullableFilter<"Lab"> | Date | string | null
    pdfKeyCipher?: StringNullableFilter<"Lab"> | string | null
    createdAt?: DateTimeNullableFilter<"Lab"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Lab"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Lab"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    results?: LabResultListRelationFilter
  }

  export type LabOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    testDate?: SortOrderInput | SortOrder
    pdfKeyCipher?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    clinic?: ClinicOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    results?: LabResultOrderByRelationAggregateInput
  }

  export type LabWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabWhereInput | LabWhereInput[]
    OR?: LabWhereInput[]
    NOT?: LabWhereInput | LabWhereInput[]
    clinicId?: UuidNullableFilter<"Lab"> | string | null
    patientId?: UuidNullableFilter<"Lab"> | string | null
    testDate?: DateTimeNullableFilter<"Lab"> | Date | string | null
    pdfKeyCipher?: StringNullableFilter<"Lab"> | string | null
    createdAt?: DateTimeNullableFilter<"Lab"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Lab"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Lab"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    results?: LabResultListRelationFilter
  }, "id">

  export type LabOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    testDate?: SortOrderInput | SortOrder
    pdfKeyCipher?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: LabCountOrderByAggregateInput
    _max?: LabMaxOrderByAggregateInput
    _min?: LabMinOrderByAggregateInput
  }

  export type LabScalarWhereWithAggregatesInput = {
    AND?: LabScalarWhereWithAggregatesInput | LabScalarWhereWithAggregatesInput[]
    OR?: LabScalarWhereWithAggregatesInput[]
    NOT?: LabScalarWhereWithAggregatesInput | LabScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Lab"> | string
    clinicId?: UuidNullableWithAggregatesFilter<"Lab"> | string | null
    patientId?: UuidNullableWithAggregatesFilter<"Lab"> | string | null
    testDate?: DateTimeNullableWithAggregatesFilter<"Lab"> | Date | string | null
    pdfKeyCipher?: StringNullableWithAggregatesFilter<"Lab"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Lab"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Lab"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Lab"> | Date | string | null
  }

  export type LabResultWhereInput = {
    AND?: LabResultWhereInput | LabResultWhereInput[]
    OR?: LabResultWhereInput[]
    NOT?: LabResultWhereInput | LabResultWhereInput[]
    id?: UuidFilter<"LabResult"> | string
    labId?: UuidNullableFilter<"LabResult"> | string | null
    testName?: StringNullableFilter<"LabResult"> | string | null
    result?: StringNullableFilter<"LabResult"> | string | null
    unit?: StringNullableFilter<"LabResult"> | string | null
    normalMin?: FloatNullableFilter<"LabResult"> | number | null
    normalMax?: FloatNullableFilter<"LabResult"> | number | null
    flag?: EnumFlagNullableFilter<"LabResult"> | $Enums.Flag | null
    lab?: XOR<LabNullableScalarRelationFilter, LabWhereInput> | null
  }

  export type LabResultOrderByWithRelationInput = {
    id?: SortOrder
    labId?: SortOrderInput | SortOrder
    testName?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    normalMin?: SortOrderInput | SortOrder
    normalMax?: SortOrderInput | SortOrder
    flag?: SortOrderInput | SortOrder
    lab?: LabOrderByWithRelationInput
  }

  export type LabResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabResultWhereInput | LabResultWhereInput[]
    OR?: LabResultWhereInput[]
    NOT?: LabResultWhereInput | LabResultWhereInput[]
    labId?: UuidNullableFilter<"LabResult"> | string | null
    testName?: StringNullableFilter<"LabResult"> | string | null
    result?: StringNullableFilter<"LabResult"> | string | null
    unit?: StringNullableFilter<"LabResult"> | string | null
    normalMin?: FloatNullableFilter<"LabResult"> | number | null
    normalMax?: FloatNullableFilter<"LabResult"> | number | null
    flag?: EnumFlagNullableFilter<"LabResult"> | $Enums.Flag | null
    lab?: XOR<LabNullableScalarRelationFilter, LabWhereInput> | null
  }, "id">

  export type LabResultOrderByWithAggregationInput = {
    id?: SortOrder
    labId?: SortOrderInput | SortOrder
    testName?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    normalMin?: SortOrderInput | SortOrder
    normalMax?: SortOrderInput | SortOrder
    flag?: SortOrderInput | SortOrder
    _count?: LabResultCountOrderByAggregateInput
    _avg?: LabResultAvgOrderByAggregateInput
    _max?: LabResultMaxOrderByAggregateInput
    _min?: LabResultMinOrderByAggregateInput
    _sum?: LabResultSumOrderByAggregateInput
  }

  export type LabResultScalarWhereWithAggregatesInput = {
    AND?: LabResultScalarWhereWithAggregatesInput | LabResultScalarWhereWithAggregatesInput[]
    OR?: LabResultScalarWhereWithAggregatesInput[]
    NOT?: LabResultScalarWhereWithAggregatesInput | LabResultScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LabResult"> | string
    labId?: UuidNullableWithAggregatesFilter<"LabResult"> | string | null
    testName?: StringNullableWithAggregatesFilter<"LabResult"> | string | null
    result?: StringNullableWithAggregatesFilter<"LabResult"> | string | null
    unit?: StringNullableWithAggregatesFilter<"LabResult"> | string | null
    normalMin?: FloatNullableWithAggregatesFilter<"LabResult"> | number | null
    normalMax?: FloatNullableWithAggregatesFilter<"LabResult"> | number | null
    flag?: EnumFlagNullableWithAggregatesFilter<"LabResult"> | $Enums.Flag | null
  }

  export type PrescriptionWhereInput = {
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    id?: UuidFilter<"Prescription"> | string
    clinicId?: UuidNullableFilter<"Prescription"> | string | null
    patientId?: UuidNullableFilter<"Prescription"> | string | null
    doctorId?: UuidNullableFilter<"Prescription"> | string | null
    prescriptionNo?: IntNullableFilter<"Prescription"> | number | null
    status?: EnumPrescriptionStatusNullableFilter<"Prescription"> | $Enums.PrescriptionStatus | null
    createdAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
    medicines?: PrescriptionMedicineListRelationFilter
  }

  export type PrescriptionOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    prescriptionNo?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    clinic?: ClinicOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
    medicines?: PrescriptionMedicineOrderByRelationAggregateInput
  }

  export type PrescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    clinicId?: UuidNullableFilter<"Prescription"> | string | null
    patientId?: UuidNullableFilter<"Prescription"> | string | null
    doctorId?: UuidNullableFilter<"Prescription"> | string | null
    prescriptionNo?: IntNullableFilter<"Prescription"> | number | null
    status?: EnumPrescriptionStatusNullableFilter<"Prescription"> | $Enums.PrescriptionStatus | null
    createdAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
    medicines?: PrescriptionMedicineListRelationFilter
  }, "id">

  export type PrescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    prescriptionNo?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PrescriptionCountOrderByAggregateInput
    _avg?: PrescriptionAvgOrderByAggregateInput
    _max?: PrescriptionMaxOrderByAggregateInput
    _min?: PrescriptionMinOrderByAggregateInput
    _sum?: PrescriptionSumOrderByAggregateInput
  }

  export type PrescriptionScalarWhereWithAggregatesInput = {
    AND?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    OR?: PrescriptionScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Prescription"> | string
    clinicId?: UuidNullableWithAggregatesFilter<"Prescription"> | string | null
    patientId?: UuidNullableWithAggregatesFilter<"Prescription"> | string | null
    doctorId?: UuidNullableWithAggregatesFilter<"Prescription"> | string | null
    prescriptionNo?: IntNullableWithAggregatesFilter<"Prescription"> | number | null
    status?: EnumPrescriptionStatusNullableWithAggregatesFilter<"Prescription"> | $Enums.PrescriptionStatus | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Prescription"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Prescription"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Prescription"> | Date | string | null
  }

  export type PrescriptionMedicineWhereInput = {
    AND?: PrescriptionMedicineWhereInput | PrescriptionMedicineWhereInput[]
    OR?: PrescriptionMedicineWhereInput[]
    NOT?: PrescriptionMedicineWhereInput | PrescriptionMedicineWhereInput[]
    id?: UuidFilter<"PrescriptionMedicine"> | string
    prescriptionId?: UuidNullableFilter<"PrescriptionMedicine"> | string | null
    medicine?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    strength?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    dose?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    frequency?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    route?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    duration?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    refill?: IntNullableFilter<"PrescriptionMedicine"> | number | null
    prescription?: XOR<PrescriptionNullableScalarRelationFilter, PrescriptionWhereInput> | null
  }

  export type PrescriptionMedicineOrderByWithRelationInput = {
    id?: SortOrder
    prescriptionId?: SortOrderInput | SortOrder
    medicine?: SortOrderInput | SortOrder
    strength?: SortOrderInput | SortOrder
    dose?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    route?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    refill?: SortOrderInput | SortOrder
    prescription?: PrescriptionOrderByWithRelationInput
  }

  export type PrescriptionMedicineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrescriptionMedicineWhereInput | PrescriptionMedicineWhereInput[]
    OR?: PrescriptionMedicineWhereInput[]
    NOT?: PrescriptionMedicineWhereInput | PrescriptionMedicineWhereInput[]
    prescriptionId?: UuidNullableFilter<"PrescriptionMedicine"> | string | null
    medicine?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    strength?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    dose?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    frequency?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    route?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    duration?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    refill?: IntNullableFilter<"PrescriptionMedicine"> | number | null
    prescription?: XOR<PrescriptionNullableScalarRelationFilter, PrescriptionWhereInput> | null
  }, "id">

  export type PrescriptionMedicineOrderByWithAggregationInput = {
    id?: SortOrder
    prescriptionId?: SortOrderInput | SortOrder
    medicine?: SortOrderInput | SortOrder
    strength?: SortOrderInput | SortOrder
    dose?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    route?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    refill?: SortOrderInput | SortOrder
    _count?: PrescriptionMedicineCountOrderByAggregateInput
    _avg?: PrescriptionMedicineAvgOrderByAggregateInput
    _max?: PrescriptionMedicineMaxOrderByAggregateInput
    _min?: PrescriptionMedicineMinOrderByAggregateInput
    _sum?: PrescriptionMedicineSumOrderByAggregateInput
  }

  export type PrescriptionMedicineScalarWhereWithAggregatesInput = {
    AND?: PrescriptionMedicineScalarWhereWithAggregatesInput | PrescriptionMedicineScalarWhereWithAggregatesInput[]
    OR?: PrescriptionMedicineScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionMedicineScalarWhereWithAggregatesInput | PrescriptionMedicineScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PrescriptionMedicine"> | string
    prescriptionId?: UuidNullableWithAggregatesFilter<"PrescriptionMedicine"> | string | null
    medicine?: StringNullableWithAggregatesFilter<"PrescriptionMedicine"> | string | null
    strength?: StringNullableWithAggregatesFilter<"PrescriptionMedicine"> | string | null
    dose?: StringNullableWithAggregatesFilter<"PrescriptionMedicine"> | string | null
    frequency?: StringNullableWithAggregatesFilter<"PrescriptionMedicine"> | string | null
    route?: StringNullableWithAggregatesFilter<"PrescriptionMedicine"> | string | null
    duration?: StringNullableWithAggregatesFilter<"PrescriptionMedicine"> | string | null
    refill?: IntNullableWithAggregatesFilter<"PrescriptionMedicine"> | number | null
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: UuidFilter<"Patient"> | string
    clinicId?: UuidNullableFilter<"Patient"> | string | null
    firstNameCipher?: StringNullableFilter<"Patient"> | string | null
    lastNameCipher?: StringNullableFilter<"Patient"> | string | null
    phoneCipher?: StringNullableFilter<"Patient"> | string | null
    emailCipher?: StringNullableFilter<"Patient"> | string | null
    insuranceIdCipher?: StringNullableFilter<"Patient"> | string | null
    addressCipher?: StringNullableFilter<"Patient"> | string | null
    emergencyContactCipher?: StringNullableFilter<"Patient"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Patient"> | Date | string | null
    gender?: EnumGenderNullableFilter<"Patient"> | $Enums.Gender | null
    bloodGroup?: StringNullableFilter<"Patient"> | string | null
    conditionName?: StringNullableFilter<"Patient"> | string | null
    diagnosedDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    severity?: StringNullableFilter<"Patient"> | string | null
    status?: StringNullableFilter<"Patient"> | string | null
    retentionExpiresAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    firstNameBlind?: StringNullableFilter<"Patient"> | string | null
    lastNameBlind?: StringNullableFilter<"Patient"> | string | null
    insuranceIdBlind?: StringNullableFilter<"Patient"> | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    appointments?: AppointmentListRelationFilter
    calls?: CallListRelationFilter
    labs?: LabListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    tasks?: TaskListRelationFilter
    dataRequests?: DataRequestListRelationFilter
    emergencyContacts?: EmergencyContactListRelationFilter
    diagnoses?: DiagnosisListRelationFilter
    consents?: PatientConsentListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    firstNameCipher?: SortOrderInput | SortOrder
    lastNameCipher?: SortOrderInput | SortOrder
    phoneCipher?: SortOrderInput | SortOrder
    emailCipher?: SortOrderInput | SortOrder
    insuranceIdCipher?: SortOrderInput | SortOrder
    addressCipher?: SortOrderInput | SortOrder
    emergencyContactCipher?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    conditionName?: SortOrderInput | SortOrder
    diagnosedDate?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    retentionExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    firstNameBlind?: SortOrderInput | SortOrder
    lastNameBlind?: SortOrderInput | SortOrder
    insuranceIdBlind?: SortOrderInput | SortOrder
    clinic?: ClinicOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    calls?: CallOrderByRelationAggregateInput
    labs?: LabOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    dataRequests?: DataRequestOrderByRelationAggregateInput
    emergencyContacts?: EmergencyContactOrderByRelationAggregateInput
    diagnoses?: DiagnosisOrderByRelationAggregateInput
    consents?: PatientConsentOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    clinicId?: UuidNullableFilter<"Patient"> | string | null
    firstNameCipher?: StringNullableFilter<"Patient"> | string | null
    lastNameCipher?: StringNullableFilter<"Patient"> | string | null
    phoneCipher?: StringNullableFilter<"Patient"> | string | null
    emailCipher?: StringNullableFilter<"Patient"> | string | null
    insuranceIdCipher?: StringNullableFilter<"Patient"> | string | null
    addressCipher?: StringNullableFilter<"Patient"> | string | null
    emergencyContactCipher?: StringNullableFilter<"Patient"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Patient"> | Date | string | null
    gender?: EnumGenderNullableFilter<"Patient"> | $Enums.Gender | null
    bloodGroup?: StringNullableFilter<"Patient"> | string | null
    conditionName?: StringNullableFilter<"Patient"> | string | null
    diagnosedDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    severity?: StringNullableFilter<"Patient"> | string | null
    status?: StringNullableFilter<"Patient"> | string | null
    retentionExpiresAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    firstNameBlind?: StringNullableFilter<"Patient"> | string | null
    lastNameBlind?: StringNullableFilter<"Patient"> | string | null
    insuranceIdBlind?: StringNullableFilter<"Patient"> | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    appointments?: AppointmentListRelationFilter
    calls?: CallListRelationFilter
    labs?: LabListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    tasks?: TaskListRelationFilter
    dataRequests?: DataRequestListRelationFilter
    emergencyContacts?: EmergencyContactListRelationFilter
    diagnoses?: DiagnosisListRelationFilter
    consents?: PatientConsentListRelationFilter
  }, "id">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    firstNameCipher?: SortOrderInput | SortOrder
    lastNameCipher?: SortOrderInput | SortOrder
    phoneCipher?: SortOrderInput | SortOrder
    emailCipher?: SortOrderInput | SortOrder
    insuranceIdCipher?: SortOrderInput | SortOrder
    addressCipher?: SortOrderInput | SortOrder
    emergencyContactCipher?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    conditionName?: SortOrderInput | SortOrder
    diagnosedDate?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    retentionExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    firstNameBlind?: SortOrderInput | SortOrder
    lastNameBlind?: SortOrderInput | SortOrder
    insuranceIdBlind?: SortOrderInput | SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Patient"> | string
    clinicId?: UuidNullableWithAggregatesFilter<"Patient"> | string | null
    firstNameCipher?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    lastNameCipher?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    phoneCipher?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emailCipher?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    insuranceIdCipher?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    addressCipher?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyContactCipher?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"Patient"> | $Enums.Gender | null
    bloodGroup?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    conditionName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    diagnosedDate?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    severity?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    status?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    retentionExpiresAt?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    firstNameBlind?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    lastNameBlind?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    insuranceIdBlind?: StringNullableWithAggregatesFilter<"Patient"> | string | null
  }

  export type EmergencyContactWhereInput = {
    AND?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    OR?: EmergencyContactWhereInput[]
    NOT?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    id?: UuidFilter<"EmergencyContact"> | string
    patientId?: UuidNullableFilter<"EmergencyContact"> | string | null
    nameCipher?: StringNullableFilter<"EmergencyContact"> | string | null
    relationship?: StringNullableFilter<"EmergencyContact"> | string | null
    phoneCipher?: StringNullableFilter<"EmergencyContact"> | string | null
    createdAt?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
  }

  export type EmergencyContactOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    nameCipher?: SortOrderInput | SortOrder
    relationship?: SortOrderInput | SortOrder
    phoneCipher?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type EmergencyContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    OR?: EmergencyContactWhereInput[]
    NOT?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    patientId?: UuidNullableFilter<"EmergencyContact"> | string | null
    nameCipher?: StringNullableFilter<"EmergencyContact"> | string | null
    relationship?: StringNullableFilter<"EmergencyContact"> | string | null
    phoneCipher?: StringNullableFilter<"EmergencyContact"> | string | null
    createdAt?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
  }, "id">

  export type EmergencyContactOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    nameCipher?: SortOrderInput | SortOrder
    relationship?: SortOrderInput | SortOrder
    phoneCipher?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: EmergencyContactCountOrderByAggregateInput
    _max?: EmergencyContactMaxOrderByAggregateInput
    _min?: EmergencyContactMinOrderByAggregateInput
  }

  export type EmergencyContactScalarWhereWithAggregatesInput = {
    AND?: EmergencyContactScalarWhereWithAggregatesInput | EmergencyContactScalarWhereWithAggregatesInput[]
    OR?: EmergencyContactScalarWhereWithAggregatesInput[]
    NOT?: EmergencyContactScalarWhereWithAggregatesInput | EmergencyContactScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"EmergencyContact"> | string
    patientId?: UuidNullableWithAggregatesFilter<"EmergencyContact"> | string | null
    nameCipher?: StringNullableWithAggregatesFilter<"EmergencyContact"> | string | null
    relationship?: StringNullableWithAggregatesFilter<"EmergencyContact"> | string | null
    phoneCipher?: StringNullableWithAggregatesFilter<"EmergencyContact"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"EmergencyContact"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"EmergencyContact"> | Date | string | null
  }

  export type StaffPersonalInfoWhereInput = {
    AND?: StaffPersonalInfoWhereInput | StaffPersonalInfoWhereInput[]
    OR?: StaffPersonalInfoWhereInput[]
    NOT?: StaffPersonalInfoWhereInput | StaffPersonalInfoWhereInput[]
    id?: UuidFilter<"StaffPersonalInfo"> | string
    doctorId?: UuidNullableFilter<"StaffPersonalInfo"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"StaffPersonalInfo"> | Date | string | null
    phoneCipher?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    addressCipher?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    stateProvince?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    postalCode?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    country?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    emergencyContactName?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    emergencyContactPhone?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    emergencyContactRelationship?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    createdAt?: DateTimeNullableFilter<"StaffPersonalInfo"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"StaffPersonalInfo"> | Date | string | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }

  export type StaffPersonalInfoOrderByWithRelationInput = {
    id?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    phoneCipher?: SortOrderInput | SortOrder
    addressCipher?: SortOrderInput | SortOrder
    stateProvince?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    emergencyContactRelationship?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    doctor?: DoctorOrderByWithRelationInput
  }

  export type StaffPersonalInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    doctorId?: string
    AND?: StaffPersonalInfoWhereInput | StaffPersonalInfoWhereInput[]
    OR?: StaffPersonalInfoWhereInput[]
    NOT?: StaffPersonalInfoWhereInput | StaffPersonalInfoWhereInput[]
    dateOfBirth?: DateTimeNullableFilter<"StaffPersonalInfo"> | Date | string | null
    phoneCipher?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    addressCipher?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    stateProvince?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    postalCode?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    country?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    emergencyContactName?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    emergencyContactPhone?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    emergencyContactRelationship?: StringNullableFilter<"StaffPersonalInfo"> | string | null
    createdAt?: DateTimeNullableFilter<"StaffPersonalInfo"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"StaffPersonalInfo"> | Date | string | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }, "id" | "doctorId">

  export type StaffPersonalInfoOrderByWithAggregationInput = {
    id?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    phoneCipher?: SortOrderInput | SortOrder
    addressCipher?: SortOrderInput | SortOrder
    stateProvince?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    emergencyContactRelationship?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: StaffPersonalInfoCountOrderByAggregateInput
    _max?: StaffPersonalInfoMaxOrderByAggregateInput
    _min?: StaffPersonalInfoMinOrderByAggregateInput
  }

  export type StaffPersonalInfoScalarWhereWithAggregatesInput = {
    AND?: StaffPersonalInfoScalarWhereWithAggregatesInput | StaffPersonalInfoScalarWhereWithAggregatesInput[]
    OR?: StaffPersonalInfoScalarWhereWithAggregatesInput[]
    NOT?: StaffPersonalInfoScalarWhereWithAggregatesInput | StaffPersonalInfoScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"StaffPersonalInfo"> | string
    doctorId?: UuidNullableWithAggregatesFilter<"StaffPersonalInfo"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"StaffPersonalInfo"> | Date | string | null
    phoneCipher?: StringNullableWithAggregatesFilter<"StaffPersonalInfo"> | string | null
    addressCipher?: StringNullableWithAggregatesFilter<"StaffPersonalInfo"> | string | null
    stateProvince?: StringNullableWithAggregatesFilter<"StaffPersonalInfo"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"StaffPersonalInfo"> | string | null
    country?: StringNullableWithAggregatesFilter<"StaffPersonalInfo"> | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"StaffPersonalInfo"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"StaffPersonalInfo"> | string | null
    emergencyContactRelationship?: StringNullableWithAggregatesFilter<"StaffPersonalInfo"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"StaffPersonalInfo"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"StaffPersonalInfo"> | Date | string | null
  }

  export type StaffEmploymentInfoWhereInput = {
    AND?: StaffEmploymentInfoWhereInput | StaffEmploymentInfoWhereInput[]
    OR?: StaffEmploymentInfoWhereInput[]
    NOT?: StaffEmploymentInfoWhereInput | StaffEmploymentInfoWhereInput[]
    id?: UuidFilter<"StaffEmploymentInfo"> | string
    doctorId?: UuidNullableFilter<"StaffEmploymentInfo"> | string | null
    employeeId?: StringNullableFilter<"StaffEmploymentInfo"> | string | null
    department?: EnumDepartmentNullableFilter<"StaffEmploymentInfo"> | $Enums.Department | null
    position?: StringNullableFilter<"StaffEmploymentInfo"> | string | null
    reportingToId?: UuidNullableFilter<"StaffEmploymentInfo"> | string | null
    joinDate?: DateTimeNullableFilter<"StaffEmploymentInfo"> | Date | string | null
    employmentType?: EnumEmploymentTypeNullableFilter<"StaffEmploymentInfo"> | $Enums.EmploymentType | null
    workSchedule?: StringNullableFilter<"StaffEmploymentInfo"> | string | null
    weeklyHours?: IntNullableFilter<"StaffEmploymentInfo"> | number | null
    salaryCipher?: StringNullableFilter<"StaffEmploymentInfo"> | string | null
    employmentStatus?: StringNullableFilter<"StaffEmploymentInfo"> | string | null
    createdAt?: DateTimeNullableFilter<"StaffEmploymentInfo"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"StaffEmploymentInfo"> | Date | string | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
    reportingTo?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }

  export type StaffEmploymentInfoOrderByWithRelationInput = {
    id?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    reportingToId?: SortOrderInput | SortOrder
    joinDate?: SortOrderInput | SortOrder
    employmentType?: SortOrderInput | SortOrder
    workSchedule?: SortOrderInput | SortOrder
    weeklyHours?: SortOrderInput | SortOrder
    salaryCipher?: SortOrderInput | SortOrder
    employmentStatus?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    doctor?: DoctorOrderByWithRelationInput
    reportingTo?: DoctorOrderByWithRelationInput
  }

  export type StaffEmploymentInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    doctorId?: string
    employeeId?: string
    AND?: StaffEmploymentInfoWhereInput | StaffEmploymentInfoWhereInput[]
    OR?: StaffEmploymentInfoWhereInput[]
    NOT?: StaffEmploymentInfoWhereInput | StaffEmploymentInfoWhereInput[]
    department?: EnumDepartmentNullableFilter<"StaffEmploymentInfo"> | $Enums.Department | null
    position?: StringNullableFilter<"StaffEmploymentInfo"> | string | null
    reportingToId?: UuidNullableFilter<"StaffEmploymentInfo"> | string | null
    joinDate?: DateTimeNullableFilter<"StaffEmploymentInfo"> | Date | string | null
    employmentType?: EnumEmploymentTypeNullableFilter<"StaffEmploymentInfo"> | $Enums.EmploymentType | null
    workSchedule?: StringNullableFilter<"StaffEmploymentInfo"> | string | null
    weeklyHours?: IntNullableFilter<"StaffEmploymentInfo"> | number | null
    salaryCipher?: StringNullableFilter<"StaffEmploymentInfo"> | string | null
    employmentStatus?: StringNullableFilter<"StaffEmploymentInfo"> | string | null
    createdAt?: DateTimeNullableFilter<"StaffEmploymentInfo"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"StaffEmploymentInfo"> | Date | string | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
    reportingTo?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }, "id" | "doctorId" | "employeeId">

  export type StaffEmploymentInfoOrderByWithAggregationInput = {
    id?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    reportingToId?: SortOrderInput | SortOrder
    joinDate?: SortOrderInput | SortOrder
    employmentType?: SortOrderInput | SortOrder
    workSchedule?: SortOrderInput | SortOrder
    weeklyHours?: SortOrderInput | SortOrder
    salaryCipher?: SortOrderInput | SortOrder
    employmentStatus?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: StaffEmploymentInfoCountOrderByAggregateInput
    _avg?: StaffEmploymentInfoAvgOrderByAggregateInput
    _max?: StaffEmploymentInfoMaxOrderByAggregateInput
    _min?: StaffEmploymentInfoMinOrderByAggregateInput
    _sum?: StaffEmploymentInfoSumOrderByAggregateInput
  }

  export type StaffEmploymentInfoScalarWhereWithAggregatesInput = {
    AND?: StaffEmploymentInfoScalarWhereWithAggregatesInput | StaffEmploymentInfoScalarWhereWithAggregatesInput[]
    OR?: StaffEmploymentInfoScalarWhereWithAggregatesInput[]
    NOT?: StaffEmploymentInfoScalarWhereWithAggregatesInput | StaffEmploymentInfoScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"StaffEmploymentInfo"> | string
    doctorId?: UuidNullableWithAggregatesFilter<"StaffEmploymentInfo"> | string | null
    employeeId?: StringNullableWithAggregatesFilter<"StaffEmploymentInfo"> | string | null
    department?: EnumDepartmentNullableWithAggregatesFilter<"StaffEmploymentInfo"> | $Enums.Department | null
    position?: StringNullableWithAggregatesFilter<"StaffEmploymentInfo"> | string | null
    reportingToId?: UuidNullableWithAggregatesFilter<"StaffEmploymentInfo"> | string | null
    joinDate?: DateTimeNullableWithAggregatesFilter<"StaffEmploymentInfo"> | Date | string | null
    employmentType?: EnumEmploymentTypeNullableWithAggregatesFilter<"StaffEmploymentInfo"> | $Enums.EmploymentType | null
    workSchedule?: StringNullableWithAggregatesFilter<"StaffEmploymentInfo"> | string | null
    weeklyHours?: IntNullableWithAggregatesFilter<"StaffEmploymentInfo"> | number | null
    salaryCipher?: StringNullableWithAggregatesFilter<"StaffEmploymentInfo"> | string | null
    employmentStatus?: StringNullableWithAggregatesFilter<"StaffEmploymentInfo"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"StaffEmploymentInfo"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"StaffEmploymentInfo"> | Date | string | null
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: UuidFilter<"Task"> | string
    clinicId?: UuidNullableFilter<"Task"> | string | null
    title?: StringNullableFilter<"Task"> | string | null
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusNullableFilter<"Task"> | $Enums.TaskStatus | null
    priority?: EnumPriorityNullableFilter<"Task"> | $Enums.Priority | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    assigneeDoctorId?: UuidNullableFilter<"Task"> | string | null
    assigneeAdminId?: UuidNullableFilter<"Task"> | string | null
    patientId?: UuidNullableFilter<"Task"> | string | null
    createdAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    assignedDoctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
    assignedAdmin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    assigneeDoctorId?: SortOrderInput | SortOrder
    assigneeAdminId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    clinic?: ClinicOrderByWithRelationInput
    assignedDoctor?: DoctorOrderByWithRelationInput
    assignedAdmin?: AdminOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    clinicId?: UuidNullableFilter<"Task"> | string | null
    title?: StringNullableFilter<"Task"> | string | null
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusNullableFilter<"Task"> | $Enums.TaskStatus | null
    priority?: EnumPriorityNullableFilter<"Task"> | $Enums.Priority | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    assigneeDoctorId?: UuidNullableFilter<"Task"> | string | null
    assigneeAdminId?: UuidNullableFilter<"Task"> | string | null
    patientId?: UuidNullableFilter<"Task"> | string | null
    createdAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    assignedDoctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
    assignedAdmin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    assigneeDoctorId?: SortOrderInput | SortOrder
    assigneeAdminId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Task"> | string
    clinicId?: UuidNullableWithAggregatesFilter<"Task"> | string | null
    title?: StringNullableWithAggregatesFilter<"Task"> | string | null
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: EnumTaskStatusNullableWithAggregatesFilter<"Task"> | $Enums.TaskStatus | null
    priority?: EnumPriorityNullableWithAggregatesFilter<"Task"> | $Enums.Priority | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    assigneeDoctorId?: UuidNullableWithAggregatesFilter<"Task"> | string | null
    assigneeAdminId?: UuidNullableWithAggregatesFilter<"Task"> | string | null
    patientId?: UuidNullableWithAggregatesFilter<"Task"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
  }

  export type SystemMetricWhereInput = {
    AND?: SystemMetricWhereInput | SystemMetricWhereInput[]
    OR?: SystemMetricWhereInput[]
    NOT?: SystemMetricWhereInput | SystemMetricWhereInput[]
    id?: UuidFilter<"SystemMetric"> | string
    serviceName?: EnumServiceNameNullableFilter<"SystemMetric"> | $Enums.ServiceName | null
    metricType?: EnumMetricTypeNullableFilter<"SystemMetric"> | $Enums.MetricType | null
    value?: FloatNullableFilter<"SystemMetric"> | number | null
    unit?: StringNullableFilter<"SystemMetric"> | string | null
    recordedAt?: DateTimeNullableFilter<"SystemMetric"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"SystemMetric"> | Date | string | null
  }

  export type SystemMetricOrderByWithRelationInput = {
    id?: SortOrder
    serviceName?: SortOrderInput | SortOrder
    metricType?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    recordedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
  }

  export type SystemMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemMetricWhereInput | SystemMetricWhereInput[]
    OR?: SystemMetricWhereInput[]
    NOT?: SystemMetricWhereInput | SystemMetricWhereInput[]
    serviceName?: EnumServiceNameNullableFilter<"SystemMetric"> | $Enums.ServiceName | null
    metricType?: EnumMetricTypeNullableFilter<"SystemMetric"> | $Enums.MetricType | null
    value?: FloatNullableFilter<"SystemMetric"> | number | null
    unit?: StringNullableFilter<"SystemMetric"> | string | null
    recordedAt?: DateTimeNullableFilter<"SystemMetric"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"SystemMetric"> | Date | string | null
  }, "id">

  export type SystemMetricOrderByWithAggregationInput = {
    id?: SortOrder
    serviceName?: SortOrderInput | SortOrder
    metricType?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    recordedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: SystemMetricCountOrderByAggregateInput
    _avg?: SystemMetricAvgOrderByAggregateInput
    _max?: SystemMetricMaxOrderByAggregateInput
    _min?: SystemMetricMinOrderByAggregateInput
    _sum?: SystemMetricSumOrderByAggregateInput
  }

  export type SystemMetricScalarWhereWithAggregatesInput = {
    AND?: SystemMetricScalarWhereWithAggregatesInput | SystemMetricScalarWhereWithAggregatesInput[]
    OR?: SystemMetricScalarWhereWithAggregatesInput[]
    NOT?: SystemMetricScalarWhereWithAggregatesInput | SystemMetricScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SystemMetric"> | string
    serviceName?: EnumServiceNameNullableWithAggregatesFilter<"SystemMetric"> | $Enums.ServiceName | null
    metricType?: EnumMetricTypeNullableWithAggregatesFilter<"SystemMetric"> | $Enums.MetricType | null
    value?: FloatNullableWithAggregatesFilter<"SystemMetric"> | number | null
    unit?: StringNullableWithAggregatesFilter<"SystemMetric"> | string | null
    recordedAt?: DateTimeNullableWithAggregatesFilter<"SystemMetric"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"SystemMetric"> | Date | string | null
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: UuidFilter<"Admin"> | string
    clinicId?: UuidNullableFilter<"Admin"> | string | null
    email?: StringNullableFilter<"Admin"> | string | null
    passwordHash?: StringNullableFilter<"Admin"> | string | null
    firstName?: StringNullableFilter<"Admin"> | string | null
    lastName?: StringNullableFilter<"Admin"> | string | null
    otp?: StringNullableFilter<"Admin"> | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"Admin"> | string | null
    twoFactorEnabled?: BoolNullableFilter<"Admin"> | boolean | null
    lastLoginAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    sessions?: SessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    assignedTasks?: TaskListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    clinic?: ClinicOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    assignedTasks?: TaskOrderByRelationAggregateInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    clinicId?: UuidNullableFilter<"Admin"> | string | null
    passwordHash?: StringNullableFilter<"Admin"> | string | null
    firstName?: StringNullableFilter<"Admin"> | string | null
    lastName?: StringNullableFilter<"Admin"> | string | null
    otp?: StringNullableFilter<"Admin"> | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"Admin"> | string | null
    twoFactorEnabled?: BoolNullableFilter<"Admin"> | boolean | null
    lastLoginAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    sessions?: SessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    assignedTasks?: TaskListRelationFilter
  }, "id" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Admin"> | string
    clinicId?: UuidNullableWithAggregatesFilter<"Admin"> | string | null
    email?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    otp?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    twoFactorSecret?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    twoFactorEnabled?: BoolNullableWithAggregatesFilter<"Admin"> | boolean | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
  }

  export type DoctorWhereInput = {
    AND?: DoctorWhereInput | DoctorWhereInput[]
    OR?: DoctorWhereInput[]
    NOT?: DoctorWhereInput | DoctorWhereInput[]
    id?: UuidFilter<"Doctor"> | string
    clinicId?: UuidNullableFilter<"Doctor"> | string | null
    email?: StringNullableFilter<"Doctor"> | string | null
    passwordHash?: StringNullableFilter<"Doctor"> | string | null
    firstName?: StringNullableFilter<"Doctor"> | string | null
    lastName?: StringNullableFilter<"Doctor"> | string | null
    otp?: StringNullableFilter<"Doctor"> | string | null
    licenceNo?: StringNullableFilter<"Doctor"> | string | null
    specialities?: StringNullableListFilter<"Doctor">
    emailVerifiedAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"Doctor"> | string | null
    twoFactorEnabled?: BoolNullableFilter<"Doctor"> | boolean | null
    lastLoginAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    sessions?: SessionListRelationFilter
    appointments?: AppointmentListRelationFilter
    calls?: CallListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    diagnoses?: DiagnosisListRelationFilter
    assignedTasks?: TaskListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    staffPersonalInfo?: XOR<StaffPersonalInfoNullableScalarRelationFilter, StaffPersonalInfoWhereInput> | null
    staffEmploymentInfo?: XOR<StaffEmploymentInfoNullableScalarRelationFilter, StaffEmploymentInfoWhereInput> | null
    subordinates?: StaffEmploymentInfoListRelationFilter
  }

  export type DoctorOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    licenceNo?: SortOrderInput | SortOrder
    specialities?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    clinic?: ClinicOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    calls?: CallOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    diagnoses?: DiagnosisOrderByRelationAggregateInput
    assignedTasks?: TaskOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    staffPersonalInfo?: StaffPersonalInfoOrderByWithRelationInput
    staffEmploymentInfo?: StaffEmploymentInfoOrderByWithRelationInput
    subordinates?: StaffEmploymentInfoOrderByRelationAggregateInput
  }

  export type DoctorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: DoctorWhereInput | DoctorWhereInput[]
    OR?: DoctorWhereInput[]
    NOT?: DoctorWhereInput | DoctorWhereInput[]
    clinicId?: UuidNullableFilter<"Doctor"> | string | null
    passwordHash?: StringNullableFilter<"Doctor"> | string | null
    firstName?: StringNullableFilter<"Doctor"> | string | null
    lastName?: StringNullableFilter<"Doctor"> | string | null
    otp?: StringNullableFilter<"Doctor"> | string | null
    licenceNo?: StringNullableFilter<"Doctor"> | string | null
    specialities?: StringNullableListFilter<"Doctor">
    emailVerifiedAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"Doctor"> | string | null
    twoFactorEnabled?: BoolNullableFilter<"Doctor"> | boolean | null
    lastLoginAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    sessions?: SessionListRelationFilter
    appointments?: AppointmentListRelationFilter
    calls?: CallListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    diagnoses?: DiagnosisListRelationFilter
    assignedTasks?: TaskListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    staffPersonalInfo?: XOR<StaffPersonalInfoNullableScalarRelationFilter, StaffPersonalInfoWhereInput> | null
    staffEmploymentInfo?: XOR<StaffEmploymentInfoNullableScalarRelationFilter, StaffEmploymentInfoWhereInput> | null
    subordinates?: StaffEmploymentInfoListRelationFilter
  }, "id" | "email">

  export type DoctorOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    licenceNo?: SortOrderInput | SortOrder
    specialities?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: DoctorCountOrderByAggregateInput
    _max?: DoctorMaxOrderByAggregateInput
    _min?: DoctorMinOrderByAggregateInput
  }

  export type DoctorScalarWhereWithAggregatesInput = {
    AND?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[]
    OR?: DoctorScalarWhereWithAggregatesInput[]
    NOT?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Doctor"> | string
    clinicId?: UuidNullableWithAggregatesFilter<"Doctor"> | string | null
    email?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    otp?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    licenceNo?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    specialities?: StringNullableListFilter<"Doctor">
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"Doctor"> | Date | string | null
    twoFactorSecret?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    twoFactorEnabled?: BoolNullableWithAggregatesFilter<"Doctor"> | boolean | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"Doctor"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Doctor"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Doctor"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Doctor"> | Date | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: UuidFilter<"Session"> | string
    adminId?: UuidNullableFilter<"Session"> | string | null
    doctorId?: UuidNullableFilter<"Session"> | string | null
    ip?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    adminId?: UuidNullableFilter<"Session"> | string | null
    doctorId?: UuidNullableFilter<"Session"> | string | null
    ip?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Session"> | string
    adminId?: UuidNullableWithAggregatesFilter<"Session"> | string | null
    doctorId?: UuidNullableWithAggregatesFilter<"Session"> | string | null
    ip?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
  }

  export type SubscriptionCreateInput = {
    id?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    plan?: $Enums.Plan | null
    status?: $Enums.SubscriptionStatus | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    clinicId?: string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    plan?: $Enums.Plan | null
    status?: $Enums.SubscriptionStatus | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    status?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    status?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    clinicId?: string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    plan?: $Enums.Plan | null
    status?: $Enums.SubscriptionStatus | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    status?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    status?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceCreateInput = {
    id?: string
    stripeInvoiceId?: string | null
    invoiceNo?: string | null
    amountDue?: number | null
    amountPaid?: number | null
    currency?: string | null
    status?: string | null
    invoicePdfUrl?: string | null
    createdAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    clinicId?: string | null
    stripeInvoiceId?: string | null
    invoiceNo?: string | null
    amountDue?: number | null
    amountPaid?: number | null
    currency?: string | null
    status?: string | null
    invoicePdfUrl?: string | null
    createdAt?: Date | string | null
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    amountDue?: NullableIntFieldUpdateOperationsInput | number | null
    amountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    amountDue?: NullableIntFieldUpdateOperationsInput | number | null
    amountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceCreateManyInput = {
    id?: string
    clinicId?: string | null
    stripeInvoiceId?: string | null
    invoiceNo?: string | null
    amountDue?: number | null
    amountPaid?: number | null
    currency?: string | null
    status?: string | null
    invoicePdfUrl?: string | null
    createdAt?: Date | string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    amountDue?: NullableIntFieldUpdateOperationsInput | number | null
    amountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    amountDue?: NullableIntFieldUpdateOperationsInput | number | null
    amountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationQueueCreateInput = {
    id?: string
    type?: $Enums.NotificationType | null
    recipient?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.NotificationStatus | null
    sentAt?: Date | string | null
    createdAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutNotificationQueuesInput
  }

  export type NotificationQueueUncheckedCreateInput = {
    id?: string
    clinicId?: string | null
    type?: $Enums.NotificationType | null
    recipient?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.NotificationStatus | null
    sentAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type NotificationQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableEnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutNotificationQueuesNestedInput
  }

  export type NotificationQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableEnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationQueueCreateManyInput = {
    id?: string
    clinicId?: string | null
    type?: $Enums.NotificationType | null
    recipient?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.NotificationStatus | null
    sentAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type NotificationQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableEnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableEnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClinicCreateInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminCreateNestedManyWithoutClinicInput
    doctors?: DoctorCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    calls?: CallCreateNestedManyWithoutClinicInput
    labs?: LabCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionCreateNestedManyWithoutClinicInput
    tasks?: TaskCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    invoices?: InvoiceCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutClinicInput
    doctors?: DoctorUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    calls?: CallUncheckedCreateNestedManyWithoutClinicInput
    labs?: LabUncheckedCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutClinicInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    calls?: CallUpdateManyWithoutClinicNestedInput
    labs?: LabUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutClinicNestedInput
    tasks?: TaskUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    calls?: CallUncheckedUpdateManyWithoutClinicNestedInput
    labs?: LabUncheckedUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutClinicNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ClinicCreateManyInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ClinicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClinicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConsentVersionCreateInput = {
    id?: string
    type?: $Enums.ConsentType | null
    version?: string | null
    title?: string | null
    body?: string | null
    effectiveDate?: Date | string | null
    createdAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutConsentVersionsInput
    patientConsents?: PatientConsentCreateNestedManyWithoutConsentVersionInput
  }

  export type ConsentVersionUncheckedCreateInput = {
    id?: string
    clinicId?: string | null
    type?: $Enums.ConsentType | null
    version?: string | null
    title?: string | null
    body?: string | null
    effectiveDate?: Date | string | null
    createdAt?: Date | string | null
    patientConsents?: PatientConsentUncheckedCreateNestedManyWithoutConsentVersionInput
  }

  export type ConsentVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutConsentVersionsNestedInput
    patientConsents?: PatientConsentUpdateManyWithoutConsentVersionNestedInput
  }

  export type ConsentVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientConsents?: PatientConsentUncheckedUpdateManyWithoutConsentVersionNestedInput
  }

  export type ConsentVersionCreateManyInput = {
    id?: string
    clinicId?: string | null
    type?: $Enums.ConsentType | null
    version?: string | null
    title?: string | null
    body?: string | null
    effectiveDate?: Date | string | null
    createdAt?: Date | string | null
  }

  export type ConsentVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConsentVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatientConsentCreateInput = {
    id?: string
    type?: $Enums.ConsentType | null
    given?: boolean | null
    givenAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    patient?: PatientCreateNestedOneWithoutConsentsInput
    consentVersion?: ConsentVersionCreateNestedOneWithoutPatientConsentsInput
  }

  export type PatientConsentUncheckedCreateInput = {
    id?: string
    patientId?: string | null
    consentVersionId?: string | null
    type?: $Enums.ConsentType | null
    given?: boolean | null
    givenAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PatientConsentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    given?: NullableBoolFieldUpdateOperationsInput | boolean | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneWithoutConsentsNestedInput
    consentVersion?: ConsentVersionUpdateOneWithoutPatientConsentsNestedInput
  }

  export type PatientConsentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    consentVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    given?: NullableBoolFieldUpdateOperationsInput | boolean | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatientConsentCreateManyInput = {
    id?: string
    patientId?: string | null
    consentVersionId?: string | null
    type?: $Enums.ConsentType | null
    given?: boolean | null
    givenAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PatientConsentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    given?: NullableBoolFieldUpdateOperationsInput | boolean | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatientConsentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    consentVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    given?: NullableBoolFieldUpdateOperationsInput | boolean | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KeyManagementCreateInput = {
    id?: string
    version?: string | null
    dekCipher?: Uint8Array | null
    createdAt?: Date | string | null
    rotatedAt?: Date | string | null
  }

  export type KeyManagementUncheckedCreateInput = {
    id?: string
    version?: string | null
    dekCipher?: Uint8Array | null
    createdAt?: Date | string | null
    rotatedAt?: Date | string | null
  }

  export type KeyManagementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    dekCipher?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rotatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KeyManagementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    dekCipher?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rotatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KeyManagementCreateManyInput = {
    id?: string
    version?: string | null
    dekCipher?: Uint8Array | null
    createdAt?: Date | string | null
    rotatedAt?: Date | string | null
  }

  export type KeyManagementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    dekCipher?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rotatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KeyManagementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    dekCipher?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rotatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    table?: string | null
    rowId?: string | null
    action?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    occurredAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutAuditLogsInput
    admin?: AdminCreateNestedOneWithoutAuditLogsInput
    doctor?: DoctorCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    table?: string | null
    rowId?: string | null
    action?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    adminId?: string | null
    doctorId?: string | null
    clinicId?: string | null
    ip?: string | null
    userAgent?: string | null
    occurredAt?: Date | string | null
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutAuditLogsNestedInput
    admin?: AdminUpdateOneWithoutAuditLogsNestedInput
    doctor?: DoctorUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateManyInput = {
    id?: string
    table?: string | null
    rowId?: string | null
    action?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    adminId?: string | null
    doctorId?: string | null
    clinicId?: string | null
    ip?: string | null
    userAgent?: string | null
    occurredAt?: Date | string | null
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataRequestCreateInput = {
    id?: string
    type?: $Enums.DataRequestType | null
    status?: $Enums.DataRequestStatus | null
    requestReason?: string | null
    requestedAt?: Date | string | null
    completedAt?: Date | string | null
    downloadUrl?: string | null
    downloadExpiresAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutDataRequestsInput
    patient?: PatientCreateNestedOneWithoutDataRequestsInput
  }

  export type DataRequestUncheckedCreateInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    type?: $Enums.DataRequestType | null
    status?: $Enums.DataRequestStatus | null
    requestReason?: string | null
    requestedAt?: Date | string | null
    completedAt?: Date | string | null
    downloadUrl?: string | null
    downloadExpiresAt?: Date | string | null
  }

  export type DataRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType | null
    status?: NullableEnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus | null
    requestReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutDataRequestsNestedInput
    patient?: PatientUpdateOneWithoutDataRequestsNestedInput
  }

  export type DataRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType | null
    status?: NullableEnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus | null
    requestReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataRequestCreateManyInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    type?: $Enums.DataRequestType | null
    status?: $Enums.DataRequestStatus | null
    requestReason?: string | null
    requestedAt?: Date | string | null
    completedAt?: Date | string | null
    downloadUrl?: string | null
    downloadExpiresAt?: Date | string | null
  }

  export type DataRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType | null
    status?: NullableEnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus | null
    requestReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType | null
    status?: NullableEnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus | null
    requestReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppointmentCreateInput = {
    id?: string
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.AppointmentStatus | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutAppointmentsInput
    patient?: PatientCreateNestedOneWithoutAppointmentsInput
    doctor?: DoctorCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    doctorId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.AppointmentStatus | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutAppointmentsNestedInput
    patient?: PatientUpdateOneWithoutAppointmentsNestedInput
    doctor?: DoctorUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppointmentCreateManyInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    doctorId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.AppointmentStatus | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CallCreateInput = {
    id?: string
    startAt?: Date | string | null
    endAt?: Date | string | null
    durationSeconds?: number | null
    status?: $Enums.CallStatus | null
    recordingUrlCipher?: string | null
    transcript?: string | null
    aiSummary?: string | null
    sentiment?: $Enums.Sentiment | null
    escalated?: boolean | null
    minutesUsed?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    aiModelId?: string | null
    aiDecision?: string | null
    clinic?: ClinicCreateNestedOneWithoutCallsInput
    patient?: PatientCreateNestedOneWithoutCallsInput
    doctor?: DoctorCreateNestedOneWithoutCallsInput
  }

  export type CallUncheckedCreateInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    doctorId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    durationSeconds?: number | null
    status?: $Enums.CallStatus | null
    recordingUrlCipher?: string | null
    transcript?: string | null
    aiSummary?: string | null
    sentiment?: $Enums.Sentiment | null
    escalated?: boolean | null
    minutesUsed?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    aiModelId?: string | null
    aiDecision?: string | null
  }

  export type CallUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus | null
    recordingUrlCipher?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    escalated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    minutesUsed?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    aiDecision?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClinicUpdateOneWithoutCallsNestedInput
    patient?: PatientUpdateOneWithoutCallsNestedInput
    doctor?: DoctorUpdateOneWithoutCallsNestedInput
  }

  export type CallUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus | null
    recordingUrlCipher?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    escalated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    minutesUsed?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    aiDecision?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CallCreateManyInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    doctorId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    durationSeconds?: number | null
    status?: $Enums.CallStatus | null
    recordingUrlCipher?: string | null
    transcript?: string | null
    aiSummary?: string | null
    sentiment?: $Enums.Sentiment | null
    escalated?: boolean | null
    minutesUsed?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    aiModelId?: string | null
    aiDecision?: string | null
  }

  export type CallUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus | null
    recordingUrlCipher?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    escalated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    minutesUsed?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    aiDecision?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CallUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus | null
    recordingUrlCipher?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    escalated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    minutesUsed?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    aiDecision?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DiagnosisCreateInput = {
    id?: string
    diagnosisCode?: string | null
    diagnosisName?: string | null
    description?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    resolvedDate?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    patient?: PatientCreateNestedOneWithoutDiagnosesInput
    doctor?: DoctorCreateNestedOneWithoutDiagnosesInput
  }

  export type DiagnosisUncheckedCreateInput = {
    id?: string
    patientId?: string | null
    doctorId?: string | null
    diagnosisCode?: string | null
    diagnosisName?: string | null
    description?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    resolvedDate?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DiagnosisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosisCode?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneWithoutDiagnosesNestedInput
    doctor?: DoctorUpdateOneWithoutDiagnosesNestedInput
  }

  export type DiagnosisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisCode?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiagnosisCreateManyInput = {
    id?: string
    patientId?: string | null
    doctorId?: string | null
    diagnosisCode?: string | null
    diagnosisName?: string | null
    description?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    resolvedDate?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DiagnosisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosisCode?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiagnosisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisCode?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LabCreateInput = {
    id?: string
    testDate?: Date | string | null
    pdfKeyCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutLabsInput
    patient?: PatientCreateNestedOneWithoutLabsInput
    results?: LabResultCreateNestedManyWithoutLabInput
  }

  export type LabUncheckedCreateInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    testDate?: Date | string | null
    pdfKeyCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    results?: LabResultUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfKeyCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutLabsNestedInput
    patient?: PatientUpdateOneWithoutLabsNestedInput
    results?: LabResultUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    testDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfKeyCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    results?: LabResultUncheckedUpdateManyWithoutLabNestedInput
  }

  export type LabCreateManyInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    testDate?: Date | string | null
    pdfKeyCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LabUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    testDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfKeyCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LabUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    testDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfKeyCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LabResultCreateInput = {
    id?: string
    testName?: string | null
    result?: string | null
    unit?: string | null
    normalMin?: number | null
    normalMax?: number | null
    flag?: $Enums.Flag | null
    lab?: LabCreateNestedOneWithoutResultsInput
  }

  export type LabResultUncheckedCreateInput = {
    id?: string
    labId?: string | null
    testName?: string | null
    result?: string | null
    unit?: string | null
    normalMin?: number | null
    normalMax?: number | null
    flag?: $Enums.Flag | null
  }

  export type LabResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    normalMin?: NullableFloatFieldUpdateOperationsInput | number | null
    normalMax?: NullableFloatFieldUpdateOperationsInput | number | null
    flag?: NullableEnumFlagFieldUpdateOperationsInput | $Enums.Flag | null
    lab?: LabUpdateOneWithoutResultsNestedInput
  }

  export type LabResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    labId?: NullableStringFieldUpdateOperationsInput | string | null
    testName?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    normalMin?: NullableFloatFieldUpdateOperationsInput | number | null
    normalMax?: NullableFloatFieldUpdateOperationsInput | number | null
    flag?: NullableEnumFlagFieldUpdateOperationsInput | $Enums.Flag | null
  }

  export type LabResultCreateManyInput = {
    id?: string
    labId?: string | null
    testName?: string | null
    result?: string | null
    unit?: string | null
    normalMin?: number | null
    normalMax?: number | null
    flag?: $Enums.Flag | null
  }

  export type LabResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    normalMin?: NullableFloatFieldUpdateOperationsInput | number | null
    normalMax?: NullableFloatFieldUpdateOperationsInput | number | null
    flag?: NullableEnumFlagFieldUpdateOperationsInput | $Enums.Flag | null
  }

  export type LabResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    labId?: NullableStringFieldUpdateOperationsInput | string | null
    testName?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    normalMin?: NullableFloatFieldUpdateOperationsInput | number | null
    normalMax?: NullableFloatFieldUpdateOperationsInput | number | null
    flag?: NullableEnumFlagFieldUpdateOperationsInput | $Enums.Flag | null
  }

  export type PrescriptionCreateInput = {
    id?: string
    prescriptionNo?: number | null
    status?: $Enums.PrescriptionStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutPrescriptionsInput
    patient?: PatientCreateNestedOneWithoutPrescriptionsInput
    doctor?: DoctorCreateNestedOneWithoutPrescriptionsInput
    medicines?: PrescriptionMedicineCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    doctorId?: string | null
    prescriptionNo?: number | null
    status?: $Enums.PrescriptionStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    medicines?: PrescriptionMedicineUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutPrescriptionsNestedInput
    patient?: PatientUpdateOneWithoutPrescriptionsNestedInput
    doctor?: DoctorUpdateOneWithoutPrescriptionsNestedInput
    medicines?: PrescriptionMedicineUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicines?: PrescriptionMedicineUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionCreateManyInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    doctorId?: string | null
    prescriptionNo?: number | null
    status?: $Enums.PrescriptionStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type PrescriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PrescriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PrescriptionMedicineCreateInput = {
    id?: string
    medicine?: string | null
    strength?: string | null
    dose?: string | null
    frequency?: string | null
    route?: string | null
    duration?: string | null
    refill?: number | null
    prescription?: PrescriptionCreateNestedOneWithoutMedicinesInput
  }

  export type PrescriptionMedicineUncheckedCreateInput = {
    id?: string
    prescriptionId?: string | null
    medicine?: string | null
    strength?: string | null
    dose?: string | null
    frequency?: string | null
    route?: string | null
    duration?: string | null
    refill?: number | null
  }

  export type PrescriptionMedicineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicine?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    refill?: NullableIntFieldUpdateOperationsInput | number | null
    prescription?: PrescriptionUpdateOneWithoutMedicinesNestedInput
  }

  export type PrescriptionMedicineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    medicine?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    refill?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PrescriptionMedicineCreateManyInput = {
    id?: string
    prescriptionId?: string | null
    medicine?: string | null
    strength?: string | null
    dose?: string | null
    frequency?: string | null
    route?: string | null
    duration?: string | null
    refill?: number | null
  }

  export type PrescriptionMedicineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicine?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    refill?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PrescriptionMedicineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    medicine?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    refill?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PatientCreateInput = {
    id?: string
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    clinic?: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    calls?: CallCreateNestedManyWithoutPatientInput
    labs?: LabCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    tasks?: TaskCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisCreateNestedManyWithoutPatientInput
    consents?: PatientConsentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    clinicId?: string | null
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    calls?: CallUncheckedCreateNestedManyWithoutPatientInput
    labs?: LabUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    consents?: PatientConsentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClinicUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    calls?: CallUpdateManyWithoutPatientNestedInput
    labs?: LabUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    tasks?: TaskUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    calls?: CallUncheckedUpdateManyWithoutPatientNestedInput
    labs?: LabUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    clinicId?: string | null
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmergencyContactCreateInput = {
    id?: string
    nameCipher?: string | null
    relationship?: string | null
    phoneCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    patient?: PatientCreateNestedOneWithoutEmergencyContactsInput
  }

  export type EmergencyContactUncheckedCreateInput = {
    id?: string
    patientId?: string | null
    nameCipher?: string | null
    relationship?: string | null
    phoneCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type EmergencyContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneWithoutEmergencyContactsNestedInput
  }

  export type EmergencyContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    nameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyContactCreateManyInput = {
    id?: string
    patientId?: string | null
    nameCipher?: string | null
    relationship?: string | null
    phoneCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type EmergencyContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    nameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StaffPersonalInfoCreateInput = {
    id?: string
    dateOfBirth?: Date | string | null
    phoneCipher?: string | null
    addressCipher?: string | null
    stateProvince?: string | null
    postalCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelationship?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    doctor?: DoctorCreateNestedOneWithoutStaffPersonalInfoInput
  }

  export type StaffPersonalInfoUncheckedCreateInput = {
    id?: string
    doctorId?: string | null
    dateOfBirth?: Date | string | null
    phoneCipher?: string | null
    addressCipher?: string | null
    stateProvince?: string | null
    postalCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelationship?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type StaffPersonalInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    stateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: DoctorUpdateOneWithoutStaffPersonalInfoNestedInput
  }

  export type StaffPersonalInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    stateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StaffPersonalInfoCreateManyInput = {
    id?: string
    doctorId?: string | null
    dateOfBirth?: Date | string | null
    phoneCipher?: string | null
    addressCipher?: string | null
    stateProvince?: string | null
    postalCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelationship?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type StaffPersonalInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    stateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StaffPersonalInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    stateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StaffEmploymentInfoCreateInput = {
    id?: string
    employeeId?: string | null
    department?: $Enums.Department | null
    position?: string | null
    joinDate?: Date | string | null
    employmentType?: $Enums.EmploymentType | null
    workSchedule?: string | null
    weeklyHours?: number | null
    salaryCipher?: string | null
    employmentStatus?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    doctor?: DoctorCreateNestedOneWithoutStaffEmploymentInfoInput
    reportingTo?: DoctorCreateNestedOneWithoutSubordinatesInput
  }

  export type StaffEmploymentInfoUncheckedCreateInput = {
    id?: string
    doctorId?: string | null
    employeeId?: string | null
    department?: $Enums.Department | null
    position?: string | null
    reportingToId?: string | null
    joinDate?: Date | string | null
    employmentType?: $Enums.EmploymentType | null
    workSchedule?: string | null
    weeklyHours?: number | null
    salaryCipher?: string | null
    employmentStatus?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type StaffEmploymentInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableEnumDepartmentFieldUpdateOperationsInput | $Enums.Department | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null
    workSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    salaryCipher?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: DoctorUpdateOneWithoutStaffEmploymentInfoNestedInput
    reportingTo?: DoctorUpdateOneWithoutSubordinatesNestedInput
  }

  export type StaffEmploymentInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableEnumDepartmentFieldUpdateOperationsInput | $Enums.Department | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    reportingToId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null
    workSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    salaryCipher?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StaffEmploymentInfoCreateManyInput = {
    id?: string
    doctorId?: string | null
    employeeId?: string | null
    department?: $Enums.Department | null
    position?: string | null
    reportingToId?: string | null
    joinDate?: Date | string | null
    employmentType?: $Enums.EmploymentType | null
    workSchedule?: string | null
    weeklyHours?: number | null
    salaryCipher?: string | null
    employmentStatus?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type StaffEmploymentInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableEnumDepartmentFieldUpdateOperationsInput | $Enums.Department | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null
    workSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    salaryCipher?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StaffEmploymentInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableEnumDepartmentFieldUpdateOperationsInput | $Enums.Department | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    reportingToId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null
    workSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    salaryCipher?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskCreateInput = {
    id?: string
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutTasksInput
    assignedDoctor?: DoctorCreateNestedOneWithoutAssignedTasksInput
    assignedAdmin?: AdminCreateNestedOneWithoutAssignedTasksInput
    patient?: PatientCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    clinicId?: string | null
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assigneeDoctorId?: string | null
    assigneeAdminId?: string | null
    patientId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutTasksNestedInput
    assignedDoctor?: DoctorUpdateOneWithoutAssignedTasksNestedInput
    assignedAdmin?: AdminUpdateOneWithoutAssignedTasksNestedInput
    patient?: PatientUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskCreateManyInput = {
    id?: string
    clinicId?: string | null
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assigneeDoctorId?: string | null
    assigneeAdminId?: string | null
    patientId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemMetricCreateInput = {
    id?: string
    serviceName?: $Enums.ServiceName | null
    metricType?: $Enums.MetricType | null
    value?: number | null
    unit?: string | null
    recordedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type SystemMetricUncheckedCreateInput = {
    id?: string
    serviceName?: $Enums.ServiceName | null
    metricType?: $Enums.MetricType | null
    value?: number | null
    unit?: string | null
    recordedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type SystemMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: NullableEnumServiceNameFieldUpdateOperationsInput | $Enums.ServiceName | null
    metricType?: NullableEnumMetricTypeFieldUpdateOperationsInput | $Enums.MetricType | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: NullableEnumServiceNameFieldUpdateOperationsInput | $Enums.ServiceName | null
    metricType?: NullableEnumMetricTypeFieldUpdateOperationsInput | $Enums.MetricType | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemMetricCreateManyInput = {
    id?: string
    serviceName?: $Enums.ServiceName | null
    metricType?: $Enums.MetricType | null
    value?: number | null
    unit?: string | null
    recordedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type SystemMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: NullableEnumServiceNameFieldUpdateOperationsInput | $Enums.ServiceName | null
    metricType?: NullableEnumMetricTypeFieldUpdateOperationsInput | $Enums.MetricType | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: NullableEnumServiceNameFieldUpdateOperationsInput | $Enums.ServiceName | null
    metricType?: NullableEnumMetricTypeFieldUpdateOperationsInput | $Enums.MetricType | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminCreateInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutAdminsInput
    sessions?: SessionCreateNestedManyWithoutAdminInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedAdminInput
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutAdminsNestedInput
    sessions?: SessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedAdminNestedInput
  }

  export type AdminCreateManyInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DoctorCreateInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutDoctorsInput
    sessions?: SessionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    calls?: CallCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoCreateNestedManyWithoutReportingToInput
  }

  export type DoctorUncheckedCreateInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    calls?: CallUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoUncheckedCreateNestedManyWithoutReportingToInput
  }

  export type DoctorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutDoctorsNestedInput
    sessions?: SessionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    calls?: CallUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    calls?: CallUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUncheckedUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorCreateManyInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type DoctorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DoctorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateInput = {
    id?: string
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
    admin?: AdminCreateNestedOneWithoutSessionsInput
    doctor?: DoctorCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    adminId?: string | null
    doctorId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneWithoutSessionsNestedInput
    doctor?: DoctorUpdateOneWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateManyInput = {
    id?: string
    adminId?: string | null
    doctorId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumPlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanNullableFilter<$PrismaModel> | $Enums.Plan | null
  }

  export type EnumSubscriptionStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ClinicNullableScalarRelationFilter = {
    is?: ClinicWhereInput | null
    isNot?: ClinicWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumPlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.Plan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlanNullableFilter<$PrismaModel>
    _max?: NestedEnumPlanNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    stripeInvoiceId?: SortOrder
    invoiceNo?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    invoicePdfUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amountDue?: SortOrder
    amountPaid?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    stripeInvoiceId?: SortOrder
    invoiceNo?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    invoicePdfUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    stripeInvoiceId?: SortOrder
    invoiceNo?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    invoicePdfUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amountDue?: SortOrder
    amountPaid?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumNotificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationTypeNullableFilter<$PrismaModel> | $Enums.NotificationType | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumNotificationStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationStatusNullableFilter<$PrismaModel> | $Enums.NotificationStatus | null
  }

  export type NotificationQueueCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    recipient?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    recipient?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationQueueMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    recipient?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumNotificationStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusNullableFilter<$PrismaModel>
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type DoctorListRelationFilter = {
    every?: DoctorWhereInput
    some?: DoctorWhereInput
    none?: DoctorWhereInput
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type CallListRelationFilter = {
    every?: CallWhereInput
    some?: CallWhereInput
    none?: CallWhereInput
  }

  export type LabListRelationFilter = {
    every?: LabWhereInput
    some?: LabWhereInput
    none?: LabWhereInput
  }

  export type PrescriptionListRelationFilter = {
    every?: PrescriptionWhereInput
    some?: PrescriptionWhereInput
    none?: PrescriptionWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type NotificationQueueListRelationFilter = {
    every?: NotificationQueueWhereInput
    some?: NotificationQueueWhereInput
    none?: NotificationQueueWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type DataRequestListRelationFilter = {
    every?: DataRequestWhereInput
    some?: DataRequestWhereInput
    none?: DataRequestWhereInput
  }

  export type ConsentVersionListRelationFilter = {
    every?: ConsentVersionWhereInput
    some?: ConsentVersionWhereInput
    none?: ConsentVersionWhereInput
  }

  export type AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CallOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationQueueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConsentVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    vatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    vatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    vatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumConsentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentType | EnumConsentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConsentTypeNullableFilter<$PrismaModel> | $Enums.ConsentType | null
  }

  export type PatientConsentListRelationFilter = {
    every?: PatientConsentWhereInput
    some?: PatientConsentWhereInput
    none?: PatientConsentWhereInput
  }

  export type PatientConsentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConsentVersionCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    version?: SortOrder
    title?: SortOrder
    body?: SortOrder
    effectiveDate?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsentVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    version?: SortOrder
    title?: SortOrder
    body?: SortOrder
    effectiveDate?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsentVersionMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    type?: SortOrder
    version?: SortOrder
    title?: SortOrder
    body?: SortOrder
    effectiveDate?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumConsentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentType | EnumConsentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConsentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ConsentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumConsentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumConsentTypeNullableFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type PatientNullableScalarRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type ConsentVersionNullableScalarRelationFilter = {
    is?: ConsentVersionWhereInput | null
    isNot?: ConsentVersionWhereInput | null
  }

  export type PatientConsentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consentVersionId?: SortOrder
    type?: SortOrder
    given?: SortOrder
    givenAt?: SortOrder
    withdrawnAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consentVersionId?: SortOrder
    type?: SortOrder
    given?: SortOrder
    givenAt?: SortOrder
    withdrawnAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientConsentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consentVersionId?: SortOrder
    type?: SortOrder
    given?: SortOrder
    givenAt?: SortOrder
    withdrawnAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type KeyManagementCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    dekCipher?: SortOrder
    createdAt?: SortOrder
    rotatedAt?: SortOrder
  }

  export type KeyManagementMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    dekCipher?: SortOrder
    createdAt?: SortOrder
    rotatedAt?: SortOrder
  }

  export type KeyManagementMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    dekCipher?: SortOrder
    createdAt?: SortOrder
    rotatedAt?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type DoctorNullableScalarRelationFilter = {
    is?: DoctorWhereInput | null
    isNot?: DoctorWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    table?: SortOrder
    rowId?: SortOrder
    action?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    adminId?: SortOrder
    doctorId?: SortOrder
    clinicId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    occurredAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    table?: SortOrder
    rowId?: SortOrder
    action?: SortOrder
    adminId?: SortOrder
    doctorId?: SortOrder
    clinicId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    occurredAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    table?: SortOrder
    rowId?: SortOrder
    action?: SortOrder
    adminId?: SortOrder
    doctorId?: SortOrder
    clinicId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    occurredAt?: SortOrder
  }

  export type EnumDataRequestTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestType | EnumDataRequestTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDataRequestTypeNullableFilter<$PrismaModel> | $Enums.DataRequestType | null
  }

  export type EnumDataRequestStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestStatus | EnumDataRequestStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDataRequestStatusNullableFilter<$PrismaModel> | $Enums.DataRequestStatus | null
  }

  export type DataRequestCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    requestReason?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    downloadUrl?: SortOrder
    downloadExpiresAt?: SortOrder
  }

  export type DataRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    requestReason?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    downloadUrl?: SortOrder
    downloadExpiresAt?: SortOrder
  }

  export type DataRequestMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    requestReason?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    downloadUrl?: SortOrder
    downloadExpiresAt?: SortOrder
  }

  export type EnumDataRequestTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestType | EnumDataRequestTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDataRequestTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DataRequestType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDataRequestTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDataRequestTypeNullableFilter<$PrismaModel>
  }

  export type EnumDataRequestStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestStatus | EnumDataRequestStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDataRequestStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.DataRequestStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDataRequestStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumDataRequestStatusNullableFilter<$PrismaModel>
  }

  export type EnumAppointmentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAppointmentStatusNullableFilter<$PrismaModel> | $Enums.AppointmentStatus | null
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumAppointmentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAppointmentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusNullableFilter<$PrismaModel>
  }

  export type EnumCallStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CallStatus | EnumCallStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCallStatusNullableFilter<$PrismaModel> | $Enums.CallStatus | null
  }

  export type EnumSentimentNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sentiment | EnumSentimentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSentimentNullableFilter<$PrismaModel> | $Enums.Sentiment | null
  }

  export type CallCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    durationSeconds?: SortOrder
    status?: SortOrder
    recordingUrlCipher?: SortOrder
    transcript?: SortOrder
    aiSummary?: SortOrder
    sentiment?: SortOrder
    escalated?: SortOrder
    minutesUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiModelId?: SortOrder
    aiDecision?: SortOrder
  }

  export type CallAvgOrderByAggregateInput = {
    durationSeconds?: SortOrder
    minutesUsed?: SortOrder
  }

  export type CallMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    durationSeconds?: SortOrder
    status?: SortOrder
    recordingUrlCipher?: SortOrder
    transcript?: SortOrder
    aiSummary?: SortOrder
    sentiment?: SortOrder
    escalated?: SortOrder
    minutesUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiModelId?: SortOrder
    aiDecision?: SortOrder
  }

  export type CallMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    durationSeconds?: SortOrder
    status?: SortOrder
    recordingUrlCipher?: SortOrder
    transcript?: SortOrder
    aiSummary?: SortOrder
    sentiment?: SortOrder
    escalated?: SortOrder
    minutesUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiModelId?: SortOrder
    aiDecision?: SortOrder
  }

  export type CallSumOrderByAggregateInput = {
    durationSeconds?: SortOrder
    minutesUsed?: SortOrder
  }

  export type EnumCallStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallStatus | EnumCallStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCallStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.CallStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCallStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumCallStatusNullableFilter<$PrismaModel>
  }

  export type EnumSentimentNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sentiment | EnumSentimentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSentimentNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sentiment | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSentimentNullableFilter<$PrismaModel>
    _max?: NestedEnumSentimentNullableFilter<$PrismaModel>
  }

  export type DiagnosisCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    diagnosisCode?: SortOrder
    diagnosisName?: SortOrder
    description?: SortOrder
    status?: SortOrder
    diagnosedDate?: SortOrder
    resolvedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiagnosisMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    diagnosisCode?: SortOrder
    diagnosisName?: SortOrder
    description?: SortOrder
    status?: SortOrder
    diagnosedDate?: SortOrder
    resolvedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiagnosisMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    diagnosisCode?: SortOrder
    diagnosisName?: SortOrder
    description?: SortOrder
    status?: SortOrder
    diagnosedDate?: SortOrder
    resolvedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabResultListRelationFilter = {
    every?: LabResultWhereInput
    some?: LabResultWhereInput
    none?: LabResultWhereInput
  }

  export type LabResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    testDate?: SortOrder
    pdfKeyCipher?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LabMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    testDate?: SortOrder
    pdfKeyCipher?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LabMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    testDate?: SortOrder
    pdfKeyCipher?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumFlagNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Flag | EnumFlagFieldRefInput<$PrismaModel> | null
    in?: $Enums.Flag[] | ListEnumFlagFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Flag[] | ListEnumFlagFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFlagNullableFilter<$PrismaModel> | $Enums.Flag | null
  }

  export type LabNullableScalarRelationFilter = {
    is?: LabWhereInput | null
    isNot?: LabWhereInput | null
  }

  export type LabResultCountOrderByAggregateInput = {
    id?: SortOrder
    labId?: SortOrder
    testName?: SortOrder
    result?: SortOrder
    unit?: SortOrder
    normalMin?: SortOrder
    normalMax?: SortOrder
    flag?: SortOrder
  }

  export type LabResultAvgOrderByAggregateInput = {
    normalMin?: SortOrder
    normalMax?: SortOrder
  }

  export type LabResultMaxOrderByAggregateInput = {
    id?: SortOrder
    labId?: SortOrder
    testName?: SortOrder
    result?: SortOrder
    unit?: SortOrder
    normalMin?: SortOrder
    normalMax?: SortOrder
    flag?: SortOrder
  }

  export type LabResultMinOrderByAggregateInput = {
    id?: SortOrder
    labId?: SortOrder
    testName?: SortOrder
    result?: SortOrder
    unit?: SortOrder
    normalMin?: SortOrder
    normalMax?: SortOrder
    flag?: SortOrder
  }

  export type LabResultSumOrderByAggregateInput = {
    normalMin?: SortOrder
    normalMax?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumFlagNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Flag | EnumFlagFieldRefInput<$PrismaModel> | null
    in?: $Enums.Flag[] | ListEnumFlagFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Flag[] | ListEnumFlagFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFlagNullableWithAggregatesFilter<$PrismaModel> | $Enums.Flag | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFlagNullableFilter<$PrismaModel>
    _max?: NestedEnumFlagNullableFilter<$PrismaModel>
  }

  export type EnumPrescriptionStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PrescriptionStatus | EnumPrescriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPrescriptionStatusNullableFilter<$PrismaModel> | $Enums.PrescriptionStatus | null
  }

  export type PrescriptionMedicineListRelationFilter = {
    every?: PrescriptionMedicineWhereInput
    some?: PrescriptionMedicineWhereInput
    none?: PrescriptionMedicineWhereInput
  }

  export type PrescriptionMedicineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    prescriptionNo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PrescriptionAvgOrderByAggregateInput = {
    prescriptionNo?: SortOrder
  }

  export type PrescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    prescriptionNo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PrescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    prescriptionNo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PrescriptionSumOrderByAggregateInput = {
    prescriptionNo?: SortOrder
  }

  export type EnumPrescriptionStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrescriptionStatus | EnumPrescriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPrescriptionStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.PrescriptionStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPrescriptionStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumPrescriptionStatusNullableFilter<$PrismaModel>
  }

  export type PrescriptionNullableScalarRelationFilter = {
    is?: PrescriptionWhereInput | null
    isNot?: PrescriptionWhereInput | null
  }

  export type PrescriptionMedicineCountOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicine?: SortOrder
    strength?: SortOrder
    dose?: SortOrder
    frequency?: SortOrder
    route?: SortOrder
    duration?: SortOrder
    refill?: SortOrder
  }

  export type PrescriptionMedicineAvgOrderByAggregateInput = {
    refill?: SortOrder
  }

  export type PrescriptionMedicineMaxOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicine?: SortOrder
    strength?: SortOrder
    dose?: SortOrder
    frequency?: SortOrder
    route?: SortOrder
    duration?: SortOrder
    refill?: SortOrder
  }

  export type PrescriptionMedicineMinOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicine?: SortOrder
    strength?: SortOrder
    dose?: SortOrder
    frequency?: SortOrder
    route?: SortOrder
    duration?: SortOrder
    refill?: SortOrder
  }

  export type PrescriptionMedicineSumOrderByAggregateInput = {
    refill?: SortOrder
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EmergencyContactListRelationFilter = {
    every?: EmergencyContactWhereInput
    some?: EmergencyContactWhereInput
    none?: EmergencyContactWhereInput
  }

  export type DiagnosisListRelationFilter = {
    every?: DiagnosisWhereInput
    some?: DiagnosisWhereInput
    none?: DiagnosisWhereInput
  }

  export type EmergencyContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiagnosisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    firstNameCipher?: SortOrder
    lastNameCipher?: SortOrder
    phoneCipher?: SortOrder
    emailCipher?: SortOrder
    insuranceIdCipher?: SortOrder
    addressCipher?: SortOrder
    emergencyContactCipher?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    conditionName?: SortOrder
    diagnosedDate?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    retentionExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    firstNameBlind?: SortOrder
    lastNameBlind?: SortOrder
    insuranceIdBlind?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    firstNameCipher?: SortOrder
    lastNameCipher?: SortOrder
    phoneCipher?: SortOrder
    emailCipher?: SortOrder
    insuranceIdCipher?: SortOrder
    addressCipher?: SortOrder
    emergencyContactCipher?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    conditionName?: SortOrder
    diagnosedDate?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    retentionExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    firstNameBlind?: SortOrder
    lastNameBlind?: SortOrder
    insuranceIdBlind?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    firstNameCipher?: SortOrder
    lastNameCipher?: SortOrder
    phoneCipher?: SortOrder
    emailCipher?: SortOrder
    insuranceIdCipher?: SortOrder
    addressCipher?: SortOrder
    emergencyContactCipher?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    conditionName?: SortOrder
    diagnosedDate?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    retentionExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    firstNameBlind?: SortOrder
    lastNameBlind?: SortOrder
    insuranceIdBlind?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EmergencyContactCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameCipher?: SortOrder
    relationship?: SortOrder
    phoneCipher?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmergencyContactMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameCipher?: SortOrder
    relationship?: SortOrder
    phoneCipher?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmergencyContactMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameCipher?: SortOrder
    relationship?: SortOrder
    phoneCipher?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffPersonalInfoCountOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    dateOfBirth?: SortOrder
    phoneCipher?: SortOrder
    addressCipher?: SortOrder
    stateProvince?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactRelationship?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffPersonalInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    dateOfBirth?: SortOrder
    phoneCipher?: SortOrder
    addressCipher?: SortOrder
    stateProvince?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactRelationship?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffPersonalInfoMinOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    dateOfBirth?: SortOrder
    phoneCipher?: SortOrder
    addressCipher?: SortOrder
    stateProvince?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactRelationship?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDepartmentNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Department | EnumDepartmentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDepartmentNullableFilter<$PrismaModel> | $Enums.Department | null
  }

  export type EnumEmploymentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEmploymentTypeNullableFilter<$PrismaModel> | $Enums.EmploymentType | null
  }

  export type StaffEmploymentInfoCountOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    reportingToId?: SortOrder
    joinDate?: SortOrder
    employmentType?: SortOrder
    workSchedule?: SortOrder
    weeklyHours?: SortOrder
    salaryCipher?: SortOrder
    employmentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffEmploymentInfoAvgOrderByAggregateInput = {
    weeklyHours?: SortOrder
  }

  export type StaffEmploymentInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    reportingToId?: SortOrder
    joinDate?: SortOrder
    employmentType?: SortOrder
    workSchedule?: SortOrder
    weeklyHours?: SortOrder
    salaryCipher?: SortOrder
    employmentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffEmploymentInfoMinOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    reportingToId?: SortOrder
    joinDate?: SortOrder
    employmentType?: SortOrder
    workSchedule?: SortOrder
    weeklyHours?: SortOrder
    salaryCipher?: SortOrder
    employmentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffEmploymentInfoSumOrderByAggregateInput = {
    weeklyHours?: SortOrder
  }

  export type EnumDepartmentNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Department | EnumDepartmentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDepartmentNullableWithAggregatesFilter<$PrismaModel> | $Enums.Department | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDepartmentNullableFilter<$PrismaModel>
    _max?: NestedEnumDepartmentNullableFilter<$PrismaModel>
  }

  export type EnumEmploymentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEmploymentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEmploymentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEmploymentTypeNullableFilter<$PrismaModel>
  }

  export type EnumTaskStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskStatusNullableFilter<$PrismaModel> | $Enums.TaskStatus | null
  }

  export type EnumPriorityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableFilter<$PrismaModel> | $Enums.Priority | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    assigneeDoctorId?: SortOrder
    assigneeAdminId?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    assigneeDoctorId?: SortOrder
    assigneeAdminId?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    assigneeDoctorId?: SortOrder
    assigneeAdminId?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumTaskStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusNullableFilter<$PrismaModel>
  }

  export type EnumPriorityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Priority | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPriorityNullableFilter<$PrismaModel>
    _max?: NestedEnumPriorityNullableFilter<$PrismaModel>
  }

  export type EnumServiceNameNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceName | EnumServiceNameFieldRefInput<$PrismaModel> | null
    in?: $Enums.ServiceName[] | ListEnumServiceNameFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ServiceName[] | ListEnumServiceNameFieldRefInput<$PrismaModel> | null
    not?: NestedEnumServiceNameNullableFilter<$PrismaModel> | $Enums.ServiceName | null
  }

  export type EnumMetricTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MetricType | EnumMetricTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMetricTypeNullableFilter<$PrismaModel> | $Enums.MetricType | null
  }

  export type SystemMetricCountOrderByAggregateInput = {
    id?: SortOrder
    serviceName?: SortOrder
    metricType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemMetricAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type SystemMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceName?: SortOrder
    metricType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemMetricMinOrderByAggregateInput = {
    id?: SortOrder
    serviceName?: SortOrder
    metricType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemMetricSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumServiceNameNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceName | EnumServiceNameFieldRefInput<$PrismaModel> | null
    in?: $Enums.ServiceName[] | ListEnumServiceNameFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ServiceName[] | ListEnumServiceNameFieldRefInput<$PrismaModel> | null
    not?: NestedEnumServiceNameNullableWithAggregatesFilter<$PrismaModel> | $Enums.ServiceName | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumServiceNameNullableFilter<$PrismaModel>
    _max?: NestedEnumServiceNameNullableFilter<$PrismaModel>
  }

  export type EnumMetricTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetricType | EnumMetricTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMetricTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.MetricType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMetricTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumMetricTypeNullableFilter<$PrismaModel>
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otp?: SortOrder
    emailVerifiedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otp?: SortOrder
    emailVerifiedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otp?: SortOrder
    emailVerifiedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type StaffPersonalInfoNullableScalarRelationFilter = {
    is?: StaffPersonalInfoWhereInput | null
    isNot?: StaffPersonalInfoWhereInput | null
  }

  export type StaffEmploymentInfoNullableScalarRelationFilter = {
    is?: StaffEmploymentInfoWhereInput | null
    isNot?: StaffEmploymentInfoWhereInput | null
  }

  export type StaffEmploymentInfoListRelationFilter = {
    every?: StaffEmploymentInfoWhereInput
    some?: StaffEmploymentInfoWhereInput
    none?: StaffEmploymentInfoWhereInput
  }

  export type StaffEmploymentInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otp?: SortOrder
    licenceNo?: SortOrder
    specialities?: SortOrder
    emailVerifiedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DoctorMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otp?: SortOrder
    licenceNo?: SortOrder
    emailVerifiedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DoctorMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otp?: SortOrder
    licenceNo?: SortOrder
    emailVerifiedAt?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    doctorId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    doctorId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    doctorId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type ClinicCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<ClinicCreateWithoutSubscriptionInput, ClinicUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutSubscriptionInput
    connect?: ClinicWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumPlanFieldUpdateOperationsInput = {
    set?: $Enums.Plan | null
  }

  export type NullableEnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ClinicUpdateOneWithoutSubscriptionNestedInput = {
    create?: XOR<ClinicCreateWithoutSubscriptionInput, ClinicUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutSubscriptionInput
    upsert?: ClinicUpsertWithoutSubscriptionInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutSubscriptionInput, ClinicUpdateWithoutSubscriptionInput>, ClinicUncheckedUpdateWithoutSubscriptionInput>
  }

  export type ClinicCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<ClinicCreateWithoutInvoicesInput, ClinicUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutInvoicesInput
    connect?: ClinicWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClinicUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<ClinicCreateWithoutInvoicesInput, ClinicUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutInvoicesInput
    upsert?: ClinicUpsertWithoutInvoicesInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutInvoicesInput, ClinicUpdateWithoutInvoicesInput>, ClinicUncheckedUpdateWithoutInvoicesInput>
  }

  export type ClinicCreateNestedOneWithoutNotificationQueuesInput = {
    create?: XOR<ClinicCreateWithoutNotificationQueuesInput, ClinicUncheckedCreateWithoutNotificationQueuesInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutNotificationQueuesInput
    connect?: ClinicWhereUniqueInput
  }

  export type NullableEnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType | null
  }

  export type NullableEnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus | null
  }

  export type ClinicUpdateOneWithoutNotificationQueuesNestedInput = {
    create?: XOR<ClinicCreateWithoutNotificationQueuesInput, ClinicUncheckedCreateWithoutNotificationQueuesInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutNotificationQueuesInput
    upsert?: ClinicUpsertWithoutNotificationQueuesInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutNotificationQueuesInput, ClinicUpdateWithoutNotificationQueuesInput>, ClinicUncheckedUpdateWithoutNotificationQueuesInput>
  }

  export type AdminCreateNestedManyWithoutClinicInput = {
    create?: XOR<AdminCreateWithoutClinicInput, AdminUncheckedCreateWithoutClinicInput> | AdminCreateWithoutClinicInput[] | AdminUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutClinicInput | AdminCreateOrConnectWithoutClinicInput[]
    createMany?: AdminCreateManyClinicInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type DoctorCreateNestedManyWithoutClinicInput = {
    create?: XOR<DoctorCreateWithoutClinicInput, DoctorUncheckedCreateWithoutClinicInput> | DoctorCreateWithoutClinicInput[] | DoctorUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: DoctorCreateOrConnectWithoutClinicInput | DoctorCreateOrConnectWithoutClinicInput[]
    createMany?: DoctorCreateManyClinicInputEnvelope
    connect?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutClinicInput = {
    create?: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput> | PatientCreateWithoutClinicInput[] | PatientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutClinicInput | PatientCreateOrConnectWithoutClinicInput[]
    createMany?: PatientCreateManyClinicInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutClinicInput = {
    create?: XOR<AppointmentCreateWithoutClinicInput, AppointmentUncheckedCreateWithoutClinicInput> | AppointmentCreateWithoutClinicInput[] | AppointmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClinicInput | AppointmentCreateOrConnectWithoutClinicInput[]
    createMany?: AppointmentCreateManyClinicInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type CallCreateNestedManyWithoutClinicInput = {
    create?: XOR<CallCreateWithoutClinicInput, CallUncheckedCreateWithoutClinicInput> | CallCreateWithoutClinicInput[] | CallUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: CallCreateOrConnectWithoutClinicInput | CallCreateOrConnectWithoutClinicInput[]
    createMany?: CallCreateManyClinicInputEnvelope
    connect?: CallWhereUniqueInput | CallWhereUniqueInput[]
  }

  export type LabCreateNestedManyWithoutClinicInput = {
    create?: XOR<LabCreateWithoutClinicInput, LabUncheckedCreateWithoutClinicInput> | LabCreateWithoutClinicInput[] | LabUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: LabCreateOrConnectWithoutClinicInput | LabCreateOrConnectWithoutClinicInput[]
    createMany?: LabCreateManyClinicInputEnvelope
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutClinicInput = {
    create?: XOR<PrescriptionCreateWithoutClinicInput, PrescriptionUncheckedCreateWithoutClinicInput> | PrescriptionCreateWithoutClinicInput[] | PrescriptionUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutClinicInput | PrescriptionCreateOrConnectWithoutClinicInput[]
    createMany?: PrescriptionCreateManyClinicInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutClinicInput = {
    create?: XOR<TaskCreateWithoutClinicInput, TaskUncheckedCreateWithoutClinicInput> | TaskCreateWithoutClinicInput[] | TaskUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClinicInput | TaskCreateOrConnectWithoutClinicInput[]
    createMany?: TaskCreateManyClinicInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutClinicInput = {
    create?: XOR<SubscriptionCreateWithoutClinicInput, SubscriptionUncheckedCreateWithoutClinicInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutClinicInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutClinicInput = {
    create?: XOR<InvoiceCreateWithoutClinicInput, InvoiceUncheckedCreateWithoutClinicInput> | InvoiceCreateWithoutClinicInput[] | InvoiceUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClinicInput | InvoiceCreateOrConnectWithoutClinicInput[]
    createMany?: InvoiceCreateManyClinicInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type NotificationQueueCreateNestedManyWithoutClinicInput = {
    create?: XOR<NotificationQueueCreateWithoutClinicInput, NotificationQueueUncheckedCreateWithoutClinicInput> | NotificationQueueCreateWithoutClinicInput[] | NotificationQueueUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: NotificationQueueCreateOrConnectWithoutClinicInput | NotificationQueueCreateOrConnectWithoutClinicInput[]
    createMany?: NotificationQueueCreateManyClinicInputEnvelope
    connect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutClinicInput = {
    create?: XOR<AuditLogCreateWithoutClinicInput, AuditLogUncheckedCreateWithoutClinicInput> | AuditLogCreateWithoutClinicInput[] | AuditLogUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutClinicInput | AuditLogCreateOrConnectWithoutClinicInput[]
    createMany?: AuditLogCreateManyClinicInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DataRequestCreateNestedManyWithoutClinicInput = {
    create?: XOR<DataRequestCreateWithoutClinicInput, DataRequestUncheckedCreateWithoutClinicInput> | DataRequestCreateWithoutClinicInput[] | DataRequestUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: DataRequestCreateOrConnectWithoutClinicInput | DataRequestCreateOrConnectWithoutClinicInput[]
    createMany?: DataRequestCreateManyClinicInputEnvelope
    connect?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
  }

  export type ConsentVersionCreateNestedManyWithoutClinicInput = {
    create?: XOR<ConsentVersionCreateWithoutClinicInput, ConsentVersionUncheckedCreateWithoutClinicInput> | ConsentVersionCreateWithoutClinicInput[] | ConsentVersionUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ConsentVersionCreateOrConnectWithoutClinicInput | ConsentVersionCreateOrConnectWithoutClinicInput[]
    createMany?: ConsentVersionCreateManyClinicInputEnvelope
    connect?: ConsentVersionWhereUniqueInput | ConsentVersionWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<AdminCreateWithoutClinicInput, AdminUncheckedCreateWithoutClinicInput> | AdminCreateWithoutClinicInput[] | AdminUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutClinicInput | AdminCreateOrConnectWithoutClinicInput[]
    createMany?: AdminCreateManyClinicInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type DoctorUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<DoctorCreateWithoutClinicInput, DoctorUncheckedCreateWithoutClinicInput> | DoctorCreateWithoutClinicInput[] | DoctorUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: DoctorCreateOrConnectWithoutClinicInput | DoctorCreateOrConnectWithoutClinicInput[]
    createMany?: DoctorCreateManyClinicInputEnvelope
    connect?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput> | PatientCreateWithoutClinicInput[] | PatientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutClinicInput | PatientCreateOrConnectWithoutClinicInput[]
    createMany?: PatientCreateManyClinicInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<AppointmentCreateWithoutClinicInput, AppointmentUncheckedCreateWithoutClinicInput> | AppointmentCreateWithoutClinicInput[] | AppointmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClinicInput | AppointmentCreateOrConnectWithoutClinicInput[]
    createMany?: AppointmentCreateManyClinicInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type CallUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<CallCreateWithoutClinicInput, CallUncheckedCreateWithoutClinicInput> | CallCreateWithoutClinicInput[] | CallUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: CallCreateOrConnectWithoutClinicInput | CallCreateOrConnectWithoutClinicInput[]
    createMany?: CallCreateManyClinicInputEnvelope
    connect?: CallWhereUniqueInput | CallWhereUniqueInput[]
  }

  export type LabUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<LabCreateWithoutClinicInput, LabUncheckedCreateWithoutClinicInput> | LabCreateWithoutClinicInput[] | LabUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: LabCreateOrConnectWithoutClinicInput | LabCreateOrConnectWithoutClinicInput[]
    createMany?: LabCreateManyClinicInputEnvelope
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<PrescriptionCreateWithoutClinicInput, PrescriptionUncheckedCreateWithoutClinicInput> | PrescriptionCreateWithoutClinicInput[] | PrescriptionUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutClinicInput | PrescriptionCreateOrConnectWithoutClinicInput[]
    createMany?: PrescriptionCreateManyClinicInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<TaskCreateWithoutClinicInput, TaskUncheckedCreateWithoutClinicInput> | TaskCreateWithoutClinicInput[] | TaskUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClinicInput | TaskCreateOrConnectWithoutClinicInput[]
    createMany?: TaskCreateManyClinicInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutClinicInput = {
    create?: XOR<SubscriptionCreateWithoutClinicInput, SubscriptionUncheckedCreateWithoutClinicInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutClinicInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type InvoiceUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<InvoiceCreateWithoutClinicInput, InvoiceUncheckedCreateWithoutClinicInput> | InvoiceCreateWithoutClinicInput[] | InvoiceUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClinicInput | InvoiceCreateOrConnectWithoutClinicInput[]
    createMany?: InvoiceCreateManyClinicInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type NotificationQueueUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<NotificationQueueCreateWithoutClinicInput, NotificationQueueUncheckedCreateWithoutClinicInput> | NotificationQueueCreateWithoutClinicInput[] | NotificationQueueUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: NotificationQueueCreateOrConnectWithoutClinicInput | NotificationQueueCreateOrConnectWithoutClinicInput[]
    createMany?: NotificationQueueCreateManyClinicInputEnvelope
    connect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<AuditLogCreateWithoutClinicInput, AuditLogUncheckedCreateWithoutClinicInput> | AuditLogCreateWithoutClinicInput[] | AuditLogUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutClinicInput | AuditLogCreateOrConnectWithoutClinicInput[]
    createMany?: AuditLogCreateManyClinicInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DataRequestUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<DataRequestCreateWithoutClinicInput, DataRequestUncheckedCreateWithoutClinicInput> | DataRequestCreateWithoutClinicInput[] | DataRequestUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: DataRequestCreateOrConnectWithoutClinicInput | DataRequestCreateOrConnectWithoutClinicInput[]
    createMany?: DataRequestCreateManyClinicInputEnvelope
    connect?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
  }

  export type ConsentVersionUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<ConsentVersionCreateWithoutClinicInput, ConsentVersionUncheckedCreateWithoutClinicInput> | ConsentVersionCreateWithoutClinicInput[] | ConsentVersionUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ConsentVersionCreateOrConnectWithoutClinicInput | ConsentVersionCreateOrConnectWithoutClinicInput[]
    createMany?: ConsentVersionCreateManyClinicInputEnvelope
    connect?: ConsentVersionWhereUniqueInput | ConsentVersionWhereUniqueInput[]
  }

  export type AdminUpdateManyWithoutClinicNestedInput = {
    create?: XOR<AdminCreateWithoutClinicInput, AdminUncheckedCreateWithoutClinicInput> | AdminCreateWithoutClinicInput[] | AdminUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutClinicInput | AdminCreateOrConnectWithoutClinicInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutClinicInput | AdminUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: AdminCreateManyClinicInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutClinicInput | AdminUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutClinicInput | AdminUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type DoctorUpdateManyWithoutClinicNestedInput = {
    create?: XOR<DoctorCreateWithoutClinicInput, DoctorUncheckedCreateWithoutClinicInput> | DoctorCreateWithoutClinicInput[] | DoctorUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: DoctorCreateOrConnectWithoutClinicInput | DoctorCreateOrConnectWithoutClinicInput[]
    upsert?: DoctorUpsertWithWhereUniqueWithoutClinicInput | DoctorUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: DoctorCreateManyClinicInputEnvelope
    set?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    disconnect?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    delete?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    connect?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    update?: DoctorUpdateWithWhereUniqueWithoutClinicInput | DoctorUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: DoctorUpdateManyWithWhereWithoutClinicInput | DoctorUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: DoctorScalarWhereInput | DoctorScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutClinicNestedInput = {
    create?: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput> | PatientCreateWithoutClinicInput[] | PatientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutClinicInput | PatientCreateOrConnectWithoutClinicInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutClinicInput | PatientUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: PatientCreateManyClinicInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutClinicInput | PatientUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutClinicInput | PatientUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutClinicNestedInput = {
    create?: XOR<AppointmentCreateWithoutClinicInput, AppointmentUncheckedCreateWithoutClinicInput> | AppointmentCreateWithoutClinicInput[] | AppointmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClinicInput | AppointmentCreateOrConnectWithoutClinicInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutClinicInput | AppointmentUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: AppointmentCreateManyClinicInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutClinicInput | AppointmentUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutClinicInput | AppointmentUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type CallUpdateManyWithoutClinicNestedInput = {
    create?: XOR<CallCreateWithoutClinicInput, CallUncheckedCreateWithoutClinicInput> | CallCreateWithoutClinicInput[] | CallUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: CallCreateOrConnectWithoutClinicInput | CallCreateOrConnectWithoutClinicInput[]
    upsert?: CallUpsertWithWhereUniqueWithoutClinicInput | CallUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: CallCreateManyClinicInputEnvelope
    set?: CallWhereUniqueInput | CallWhereUniqueInput[]
    disconnect?: CallWhereUniqueInput | CallWhereUniqueInput[]
    delete?: CallWhereUniqueInput | CallWhereUniqueInput[]
    connect?: CallWhereUniqueInput | CallWhereUniqueInput[]
    update?: CallUpdateWithWhereUniqueWithoutClinicInput | CallUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: CallUpdateManyWithWhereWithoutClinicInput | CallUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: CallScalarWhereInput | CallScalarWhereInput[]
  }

  export type LabUpdateManyWithoutClinicNestedInput = {
    create?: XOR<LabCreateWithoutClinicInput, LabUncheckedCreateWithoutClinicInput> | LabCreateWithoutClinicInput[] | LabUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: LabCreateOrConnectWithoutClinicInput | LabCreateOrConnectWithoutClinicInput[]
    upsert?: LabUpsertWithWhereUniqueWithoutClinicInput | LabUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: LabCreateManyClinicInputEnvelope
    set?: LabWhereUniqueInput | LabWhereUniqueInput[]
    disconnect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    delete?: LabWhereUniqueInput | LabWhereUniqueInput[]
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    update?: LabUpdateWithWhereUniqueWithoutClinicInput | LabUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: LabUpdateManyWithWhereWithoutClinicInput | LabUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: LabScalarWhereInput | LabScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutClinicNestedInput = {
    create?: XOR<PrescriptionCreateWithoutClinicInput, PrescriptionUncheckedCreateWithoutClinicInput> | PrescriptionCreateWithoutClinicInput[] | PrescriptionUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutClinicInput | PrescriptionCreateOrConnectWithoutClinicInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutClinicInput | PrescriptionUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: PrescriptionCreateManyClinicInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutClinicInput | PrescriptionUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutClinicInput | PrescriptionUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutClinicNestedInput = {
    create?: XOR<TaskCreateWithoutClinicInput, TaskUncheckedCreateWithoutClinicInput> | TaskCreateWithoutClinicInput[] | TaskUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClinicInput | TaskCreateOrConnectWithoutClinicInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutClinicInput | TaskUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: TaskCreateManyClinicInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutClinicInput | TaskUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutClinicInput | TaskUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutClinicNestedInput = {
    create?: XOR<SubscriptionCreateWithoutClinicInput, SubscriptionUncheckedCreateWithoutClinicInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutClinicInput
    upsert?: SubscriptionUpsertWithoutClinicInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutClinicInput, SubscriptionUpdateWithoutClinicInput>, SubscriptionUncheckedUpdateWithoutClinicInput>
  }

  export type InvoiceUpdateManyWithoutClinicNestedInput = {
    create?: XOR<InvoiceCreateWithoutClinicInput, InvoiceUncheckedCreateWithoutClinicInput> | InvoiceCreateWithoutClinicInput[] | InvoiceUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClinicInput | InvoiceCreateOrConnectWithoutClinicInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClinicInput | InvoiceUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: InvoiceCreateManyClinicInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClinicInput | InvoiceUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClinicInput | InvoiceUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type NotificationQueueUpdateManyWithoutClinicNestedInput = {
    create?: XOR<NotificationQueueCreateWithoutClinicInput, NotificationQueueUncheckedCreateWithoutClinicInput> | NotificationQueueCreateWithoutClinicInput[] | NotificationQueueUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: NotificationQueueCreateOrConnectWithoutClinicInput | NotificationQueueCreateOrConnectWithoutClinicInput[]
    upsert?: NotificationQueueUpsertWithWhereUniqueWithoutClinicInput | NotificationQueueUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: NotificationQueueCreateManyClinicInputEnvelope
    set?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[]
    disconnect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[]
    delete?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[]
    connect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[]
    update?: NotificationQueueUpdateWithWhereUniqueWithoutClinicInput | NotificationQueueUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: NotificationQueueUpdateManyWithWhereWithoutClinicInput | NotificationQueueUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: NotificationQueueScalarWhereInput | NotificationQueueScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutClinicNestedInput = {
    create?: XOR<AuditLogCreateWithoutClinicInput, AuditLogUncheckedCreateWithoutClinicInput> | AuditLogCreateWithoutClinicInput[] | AuditLogUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutClinicInput | AuditLogCreateOrConnectWithoutClinicInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutClinicInput | AuditLogUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: AuditLogCreateManyClinicInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutClinicInput | AuditLogUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutClinicInput | AuditLogUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DataRequestUpdateManyWithoutClinicNestedInput = {
    create?: XOR<DataRequestCreateWithoutClinicInput, DataRequestUncheckedCreateWithoutClinicInput> | DataRequestCreateWithoutClinicInput[] | DataRequestUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: DataRequestCreateOrConnectWithoutClinicInput | DataRequestCreateOrConnectWithoutClinicInput[]
    upsert?: DataRequestUpsertWithWhereUniqueWithoutClinicInput | DataRequestUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: DataRequestCreateManyClinicInputEnvelope
    set?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    disconnect?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    delete?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    connect?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    update?: DataRequestUpdateWithWhereUniqueWithoutClinicInput | DataRequestUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: DataRequestUpdateManyWithWhereWithoutClinicInput | DataRequestUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: DataRequestScalarWhereInput | DataRequestScalarWhereInput[]
  }

  export type ConsentVersionUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ConsentVersionCreateWithoutClinicInput, ConsentVersionUncheckedCreateWithoutClinicInput> | ConsentVersionCreateWithoutClinicInput[] | ConsentVersionUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ConsentVersionCreateOrConnectWithoutClinicInput | ConsentVersionCreateOrConnectWithoutClinicInput[]
    upsert?: ConsentVersionUpsertWithWhereUniqueWithoutClinicInput | ConsentVersionUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ConsentVersionCreateManyClinicInputEnvelope
    set?: ConsentVersionWhereUniqueInput | ConsentVersionWhereUniqueInput[]
    disconnect?: ConsentVersionWhereUniqueInput | ConsentVersionWhereUniqueInput[]
    delete?: ConsentVersionWhereUniqueInput | ConsentVersionWhereUniqueInput[]
    connect?: ConsentVersionWhereUniqueInput | ConsentVersionWhereUniqueInput[]
    update?: ConsentVersionUpdateWithWhereUniqueWithoutClinicInput | ConsentVersionUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ConsentVersionUpdateManyWithWhereWithoutClinicInput | ConsentVersionUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ConsentVersionScalarWhereInput | ConsentVersionScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<AdminCreateWithoutClinicInput, AdminUncheckedCreateWithoutClinicInput> | AdminCreateWithoutClinicInput[] | AdminUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutClinicInput | AdminCreateOrConnectWithoutClinicInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutClinicInput | AdminUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: AdminCreateManyClinicInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutClinicInput | AdminUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutClinicInput | AdminUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type DoctorUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<DoctorCreateWithoutClinicInput, DoctorUncheckedCreateWithoutClinicInput> | DoctorCreateWithoutClinicInput[] | DoctorUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: DoctorCreateOrConnectWithoutClinicInput | DoctorCreateOrConnectWithoutClinicInput[]
    upsert?: DoctorUpsertWithWhereUniqueWithoutClinicInput | DoctorUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: DoctorCreateManyClinicInputEnvelope
    set?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    disconnect?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    delete?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    connect?: DoctorWhereUniqueInput | DoctorWhereUniqueInput[]
    update?: DoctorUpdateWithWhereUniqueWithoutClinicInput | DoctorUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: DoctorUpdateManyWithWhereWithoutClinicInput | DoctorUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: DoctorScalarWhereInput | DoctorScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput> | PatientCreateWithoutClinicInput[] | PatientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutClinicInput | PatientCreateOrConnectWithoutClinicInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutClinicInput | PatientUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: PatientCreateManyClinicInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutClinicInput | PatientUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutClinicInput | PatientUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<AppointmentCreateWithoutClinicInput, AppointmentUncheckedCreateWithoutClinicInput> | AppointmentCreateWithoutClinicInput[] | AppointmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClinicInput | AppointmentCreateOrConnectWithoutClinicInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutClinicInput | AppointmentUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: AppointmentCreateManyClinicInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutClinicInput | AppointmentUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutClinicInput | AppointmentUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type CallUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<CallCreateWithoutClinicInput, CallUncheckedCreateWithoutClinicInput> | CallCreateWithoutClinicInput[] | CallUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: CallCreateOrConnectWithoutClinicInput | CallCreateOrConnectWithoutClinicInput[]
    upsert?: CallUpsertWithWhereUniqueWithoutClinicInput | CallUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: CallCreateManyClinicInputEnvelope
    set?: CallWhereUniqueInput | CallWhereUniqueInput[]
    disconnect?: CallWhereUniqueInput | CallWhereUniqueInput[]
    delete?: CallWhereUniqueInput | CallWhereUniqueInput[]
    connect?: CallWhereUniqueInput | CallWhereUniqueInput[]
    update?: CallUpdateWithWhereUniqueWithoutClinicInput | CallUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: CallUpdateManyWithWhereWithoutClinicInput | CallUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: CallScalarWhereInput | CallScalarWhereInput[]
  }

  export type LabUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<LabCreateWithoutClinicInput, LabUncheckedCreateWithoutClinicInput> | LabCreateWithoutClinicInput[] | LabUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: LabCreateOrConnectWithoutClinicInput | LabCreateOrConnectWithoutClinicInput[]
    upsert?: LabUpsertWithWhereUniqueWithoutClinicInput | LabUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: LabCreateManyClinicInputEnvelope
    set?: LabWhereUniqueInput | LabWhereUniqueInput[]
    disconnect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    delete?: LabWhereUniqueInput | LabWhereUniqueInput[]
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    update?: LabUpdateWithWhereUniqueWithoutClinicInput | LabUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: LabUpdateManyWithWhereWithoutClinicInput | LabUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: LabScalarWhereInput | LabScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<PrescriptionCreateWithoutClinicInput, PrescriptionUncheckedCreateWithoutClinicInput> | PrescriptionCreateWithoutClinicInput[] | PrescriptionUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutClinicInput | PrescriptionCreateOrConnectWithoutClinicInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutClinicInput | PrescriptionUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: PrescriptionCreateManyClinicInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutClinicInput | PrescriptionUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutClinicInput | PrescriptionUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<TaskCreateWithoutClinicInput, TaskUncheckedCreateWithoutClinicInput> | TaskCreateWithoutClinicInput[] | TaskUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClinicInput | TaskCreateOrConnectWithoutClinicInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutClinicInput | TaskUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: TaskCreateManyClinicInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutClinicInput | TaskUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutClinicInput | TaskUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutClinicNestedInput = {
    create?: XOR<SubscriptionCreateWithoutClinicInput, SubscriptionUncheckedCreateWithoutClinicInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutClinicInput
    upsert?: SubscriptionUpsertWithoutClinicInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutClinicInput, SubscriptionUpdateWithoutClinicInput>, SubscriptionUncheckedUpdateWithoutClinicInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<InvoiceCreateWithoutClinicInput, InvoiceUncheckedCreateWithoutClinicInput> | InvoiceCreateWithoutClinicInput[] | InvoiceUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClinicInput | InvoiceCreateOrConnectWithoutClinicInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClinicInput | InvoiceUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: InvoiceCreateManyClinicInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClinicInput | InvoiceUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClinicInput | InvoiceUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<NotificationQueueCreateWithoutClinicInput, NotificationQueueUncheckedCreateWithoutClinicInput> | NotificationQueueCreateWithoutClinicInput[] | NotificationQueueUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: NotificationQueueCreateOrConnectWithoutClinicInput | NotificationQueueCreateOrConnectWithoutClinicInput[]
    upsert?: NotificationQueueUpsertWithWhereUniqueWithoutClinicInput | NotificationQueueUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: NotificationQueueCreateManyClinicInputEnvelope
    set?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[]
    disconnect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[]
    delete?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[]
    connect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[]
    update?: NotificationQueueUpdateWithWhereUniqueWithoutClinicInput | NotificationQueueUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: NotificationQueueUpdateManyWithWhereWithoutClinicInput | NotificationQueueUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: NotificationQueueScalarWhereInput | NotificationQueueScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<AuditLogCreateWithoutClinicInput, AuditLogUncheckedCreateWithoutClinicInput> | AuditLogCreateWithoutClinicInput[] | AuditLogUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutClinicInput | AuditLogCreateOrConnectWithoutClinicInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutClinicInput | AuditLogUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: AuditLogCreateManyClinicInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutClinicInput | AuditLogUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutClinicInput | AuditLogUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DataRequestUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<DataRequestCreateWithoutClinicInput, DataRequestUncheckedCreateWithoutClinicInput> | DataRequestCreateWithoutClinicInput[] | DataRequestUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: DataRequestCreateOrConnectWithoutClinicInput | DataRequestCreateOrConnectWithoutClinicInput[]
    upsert?: DataRequestUpsertWithWhereUniqueWithoutClinicInput | DataRequestUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: DataRequestCreateManyClinicInputEnvelope
    set?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    disconnect?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    delete?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    connect?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    update?: DataRequestUpdateWithWhereUniqueWithoutClinicInput | DataRequestUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: DataRequestUpdateManyWithWhereWithoutClinicInput | DataRequestUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: DataRequestScalarWhereInput | DataRequestScalarWhereInput[]
  }

  export type ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ConsentVersionCreateWithoutClinicInput, ConsentVersionUncheckedCreateWithoutClinicInput> | ConsentVersionCreateWithoutClinicInput[] | ConsentVersionUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ConsentVersionCreateOrConnectWithoutClinicInput | ConsentVersionCreateOrConnectWithoutClinicInput[]
    upsert?: ConsentVersionUpsertWithWhereUniqueWithoutClinicInput | ConsentVersionUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ConsentVersionCreateManyClinicInputEnvelope
    set?: ConsentVersionWhereUniqueInput | ConsentVersionWhereUniqueInput[]
    disconnect?: ConsentVersionWhereUniqueInput | ConsentVersionWhereUniqueInput[]
    delete?: ConsentVersionWhereUniqueInput | ConsentVersionWhereUniqueInput[]
    connect?: ConsentVersionWhereUniqueInput | ConsentVersionWhereUniqueInput[]
    update?: ConsentVersionUpdateWithWhereUniqueWithoutClinicInput | ConsentVersionUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ConsentVersionUpdateManyWithWhereWithoutClinicInput | ConsentVersionUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ConsentVersionScalarWhereInput | ConsentVersionScalarWhereInput[]
  }

  export type ClinicCreateNestedOneWithoutConsentVersionsInput = {
    create?: XOR<ClinicCreateWithoutConsentVersionsInput, ClinicUncheckedCreateWithoutConsentVersionsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutConsentVersionsInput
    connect?: ClinicWhereUniqueInput
  }

  export type PatientConsentCreateNestedManyWithoutConsentVersionInput = {
    create?: XOR<PatientConsentCreateWithoutConsentVersionInput, PatientConsentUncheckedCreateWithoutConsentVersionInput> | PatientConsentCreateWithoutConsentVersionInput[] | PatientConsentUncheckedCreateWithoutConsentVersionInput[]
    connectOrCreate?: PatientConsentCreateOrConnectWithoutConsentVersionInput | PatientConsentCreateOrConnectWithoutConsentVersionInput[]
    createMany?: PatientConsentCreateManyConsentVersionInputEnvelope
    connect?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
  }

  export type PatientConsentUncheckedCreateNestedManyWithoutConsentVersionInput = {
    create?: XOR<PatientConsentCreateWithoutConsentVersionInput, PatientConsentUncheckedCreateWithoutConsentVersionInput> | PatientConsentCreateWithoutConsentVersionInput[] | PatientConsentUncheckedCreateWithoutConsentVersionInput[]
    connectOrCreate?: PatientConsentCreateOrConnectWithoutConsentVersionInput | PatientConsentCreateOrConnectWithoutConsentVersionInput[]
    createMany?: PatientConsentCreateManyConsentVersionInputEnvelope
    connect?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
  }

  export type NullableEnumConsentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ConsentType | null
  }

  export type ClinicUpdateOneWithoutConsentVersionsNestedInput = {
    create?: XOR<ClinicCreateWithoutConsentVersionsInput, ClinicUncheckedCreateWithoutConsentVersionsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutConsentVersionsInput
    upsert?: ClinicUpsertWithoutConsentVersionsInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutConsentVersionsInput, ClinicUpdateWithoutConsentVersionsInput>, ClinicUncheckedUpdateWithoutConsentVersionsInput>
  }

  export type PatientConsentUpdateManyWithoutConsentVersionNestedInput = {
    create?: XOR<PatientConsentCreateWithoutConsentVersionInput, PatientConsentUncheckedCreateWithoutConsentVersionInput> | PatientConsentCreateWithoutConsentVersionInput[] | PatientConsentUncheckedCreateWithoutConsentVersionInput[]
    connectOrCreate?: PatientConsentCreateOrConnectWithoutConsentVersionInput | PatientConsentCreateOrConnectWithoutConsentVersionInput[]
    upsert?: PatientConsentUpsertWithWhereUniqueWithoutConsentVersionInput | PatientConsentUpsertWithWhereUniqueWithoutConsentVersionInput[]
    createMany?: PatientConsentCreateManyConsentVersionInputEnvelope
    set?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    disconnect?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    delete?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    connect?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    update?: PatientConsentUpdateWithWhereUniqueWithoutConsentVersionInput | PatientConsentUpdateWithWhereUniqueWithoutConsentVersionInput[]
    updateMany?: PatientConsentUpdateManyWithWhereWithoutConsentVersionInput | PatientConsentUpdateManyWithWhereWithoutConsentVersionInput[]
    deleteMany?: PatientConsentScalarWhereInput | PatientConsentScalarWhereInput[]
  }

  export type PatientConsentUncheckedUpdateManyWithoutConsentVersionNestedInput = {
    create?: XOR<PatientConsentCreateWithoutConsentVersionInput, PatientConsentUncheckedCreateWithoutConsentVersionInput> | PatientConsentCreateWithoutConsentVersionInput[] | PatientConsentUncheckedCreateWithoutConsentVersionInput[]
    connectOrCreate?: PatientConsentCreateOrConnectWithoutConsentVersionInput | PatientConsentCreateOrConnectWithoutConsentVersionInput[]
    upsert?: PatientConsentUpsertWithWhereUniqueWithoutConsentVersionInput | PatientConsentUpsertWithWhereUniqueWithoutConsentVersionInput[]
    createMany?: PatientConsentCreateManyConsentVersionInputEnvelope
    set?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    disconnect?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    delete?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    connect?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    update?: PatientConsentUpdateWithWhereUniqueWithoutConsentVersionInput | PatientConsentUpdateWithWhereUniqueWithoutConsentVersionInput[]
    updateMany?: PatientConsentUpdateManyWithWhereWithoutConsentVersionInput | PatientConsentUpdateManyWithWhereWithoutConsentVersionInput[]
    deleteMany?: PatientConsentScalarWhereInput | PatientConsentScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutConsentsInput = {
    create?: XOR<PatientCreateWithoutConsentsInput, PatientUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConsentsInput
    connect?: PatientWhereUniqueInput
  }

  export type ConsentVersionCreateNestedOneWithoutPatientConsentsInput = {
    create?: XOR<ConsentVersionCreateWithoutPatientConsentsInput, ConsentVersionUncheckedCreateWithoutPatientConsentsInput>
    connectOrCreate?: ConsentVersionCreateOrConnectWithoutPatientConsentsInput
    connect?: ConsentVersionWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type PatientUpdateOneWithoutConsentsNestedInput = {
    create?: XOR<PatientCreateWithoutConsentsInput, PatientUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConsentsInput
    upsert?: PatientUpsertWithoutConsentsInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutConsentsInput, PatientUpdateWithoutConsentsInput>, PatientUncheckedUpdateWithoutConsentsInput>
  }

  export type ConsentVersionUpdateOneWithoutPatientConsentsNestedInput = {
    create?: XOR<ConsentVersionCreateWithoutPatientConsentsInput, ConsentVersionUncheckedCreateWithoutPatientConsentsInput>
    connectOrCreate?: ConsentVersionCreateOrConnectWithoutPatientConsentsInput
    upsert?: ConsentVersionUpsertWithoutPatientConsentsInput
    disconnect?: ConsentVersionWhereInput | boolean
    delete?: ConsentVersionWhereInput | boolean
    connect?: ConsentVersionWhereUniqueInput
    update?: XOR<XOR<ConsentVersionUpdateToOneWithWhereWithoutPatientConsentsInput, ConsentVersionUpdateWithoutPatientConsentsInput>, ConsentVersionUncheckedUpdateWithoutPatientConsentsInput>
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type ClinicCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<ClinicCreateWithoutAuditLogsInput, ClinicUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutAuditLogsInput
    connect?: ClinicWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<AdminCreateWithoutAuditLogsInput, AdminUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuditLogsInput
    connect?: AdminWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<DoctorCreateWithoutAuditLogsInput, DoctorUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAuditLogsInput
    connect?: DoctorWhereUniqueInput
  }

  export type ClinicUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<ClinicCreateWithoutAuditLogsInput, ClinicUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutAuditLogsInput
    upsert?: ClinicUpsertWithoutAuditLogsInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutAuditLogsInput, ClinicUpdateWithoutAuditLogsInput>, ClinicUncheckedUpdateWithoutAuditLogsInput>
  }

  export type AdminUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<AdminCreateWithoutAuditLogsInput, AdminUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuditLogsInput
    upsert?: AdminUpsertWithoutAuditLogsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAuditLogsInput, AdminUpdateWithoutAuditLogsInput>, AdminUncheckedUpdateWithoutAuditLogsInput>
  }

  export type DoctorUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<DoctorCreateWithoutAuditLogsInput, DoctorUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAuditLogsInput
    upsert?: DoctorUpsertWithoutAuditLogsInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutAuditLogsInput, DoctorUpdateWithoutAuditLogsInput>, DoctorUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ClinicCreateNestedOneWithoutDataRequestsInput = {
    create?: XOR<ClinicCreateWithoutDataRequestsInput, ClinicUncheckedCreateWithoutDataRequestsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutDataRequestsInput
    connect?: ClinicWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutDataRequestsInput = {
    create?: XOR<PatientCreateWithoutDataRequestsInput, PatientUncheckedCreateWithoutDataRequestsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDataRequestsInput
    connect?: PatientWhereUniqueInput
  }

  export type NullableEnumDataRequestTypeFieldUpdateOperationsInput = {
    set?: $Enums.DataRequestType | null
  }

  export type NullableEnumDataRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.DataRequestStatus | null
  }

  export type ClinicUpdateOneWithoutDataRequestsNestedInput = {
    create?: XOR<ClinicCreateWithoutDataRequestsInput, ClinicUncheckedCreateWithoutDataRequestsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutDataRequestsInput
    upsert?: ClinicUpsertWithoutDataRequestsInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutDataRequestsInput, ClinicUpdateWithoutDataRequestsInput>, ClinicUncheckedUpdateWithoutDataRequestsInput>
  }

  export type PatientUpdateOneWithoutDataRequestsNestedInput = {
    create?: XOR<PatientCreateWithoutDataRequestsInput, PatientUncheckedCreateWithoutDataRequestsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDataRequestsInput
    upsert?: PatientUpsertWithoutDataRequestsInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutDataRequestsInput, PatientUpdateWithoutDataRequestsInput>, PatientUncheckedUpdateWithoutDataRequestsInput>
  }

  export type ClinicCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ClinicCreateWithoutAppointmentsInput, ClinicUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutAppointmentsInput
    connect?: ClinicWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAppointmentsInput
    connect?: DoctorWhereUniqueInput
  }

  export type NullableEnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus | null
  }

  export type ClinicUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<ClinicCreateWithoutAppointmentsInput, ClinicUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutAppointmentsInput
    upsert?: ClinicUpsertWithoutAppointmentsInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutAppointmentsInput, ClinicUpdateWithoutAppointmentsInput>, ClinicUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    upsert?: PatientUpsertWithoutAppointmentsInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAppointmentsInput, PatientUpdateWithoutAppointmentsInput>, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DoctorUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAppointmentsInput
    upsert?: DoctorUpsertWithoutAppointmentsInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutAppointmentsInput, DoctorUpdateWithoutAppointmentsInput>, DoctorUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ClinicCreateNestedOneWithoutCallsInput = {
    create?: XOR<ClinicCreateWithoutCallsInput, ClinicUncheckedCreateWithoutCallsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutCallsInput
    connect?: ClinicWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutCallsInput = {
    create?: XOR<PatientCreateWithoutCallsInput, PatientUncheckedCreateWithoutCallsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutCallsInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutCallsInput = {
    create?: XOR<DoctorCreateWithoutCallsInput, DoctorUncheckedCreateWithoutCallsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutCallsInput
    connect?: DoctorWhereUniqueInput
  }

  export type NullableEnumCallStatusFieldUpdateOperationsInput = {
    set?: $Enums.CallStatus | null
  }

  export type NullableEnumSentimentFieldUpdateOperationsInput = {
    set?: $Enums.Sentiment | null
  }

  export type ClinicUpdateOneWithoutCallsNestedInput = {
    create?: XOR<ClinicCreateWithoutCallsInput, ClinicUncheckedCreateWithoutCallsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutCallsInput
    upsert?: ClinicUpsertWithoutCallsInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutCallsInput, ClinicUpdateWithoutCallsInput>, ClinicUncheckedUpdateWithoutCallsInput>
  }

  export type PatientUpdateOneWithoutCallsNestedInput = {
    create?: XOR<PatientCreateWithoutCallsInput, PatientUncheckedCreateWithoutCallsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutCallsInput
    upsert?: PatientUpsertWithoutCallsInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutCallsInput, PatientUpdateWithoutCallsInput>, PatientUncheckedUpdateWithoutCallsInput>
  }

  export type DoctorUpdateOneWithoutCallsNestedInput = {
    create?: XOR<DoctorCreateWithoutCallsInput, DoctorUncheckedCreateWithoutCallsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutCallsInput
    upsert?: DoctorUpsertWithoutCallsInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutCallsInput, DoctorUpdateWithoutCallsInput>, DoctorUncheckedUpdateWithoutCallsInput>
  }

  export type PatientCreateNestedOneWithoutDiagnosesInput = {
    create?: XOR<PatientCreateWithoutDiagnosesInput, PatientUncheckedCreateWithoutDiagnosesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDiagnosesInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutDiagnosesInput = {
    create?: XOR<DoctorCreateWithoutDiagnosesInput, DoctorUncheckedCreateWithoutDiagnosesInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutDiagnosesInput
    connect?: DoctorWhereUniqueInput
  }

  export type PatientUpdateOneWithoutDiagnosesNestedInput = {
    create?: XOR<PatientCreateWithoutDiagnosesInput, PatientUncheckedCreateWithoutDiagnosesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDiagnosesInput
    upsert?: PatientUpsertWithoutDiagnosesInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutDiagnosesInput, PatientUpdateWithoutDiagnosesInput>, PatientUncheckedUpdateWithoutDiagnosesInput>
  }

  export type DoctorUpdateOneWithoutDiagnosesNestedInput = {
    create?: XOR<DoctorCreateWithoutDiagnosesInput, DoctorUncheckedCreateWithoutDiagnosesInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutDiagnosesInput
    upsert?: DoctorUpsertWithoutDiagnosesInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutDiagnosesInput, DoctorUpdateWithoutDiagnosesInput>, DoctorUncheckedUpdateWithoutDiagnosesInput>
  }

  export type ClinicCreateNestedOneWithoutLabsInput = {
    create?: XOR<ClinicCreateWithoutLabsInput, ClinicUncheckedCreateWithoutLabsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutLabsInput
    connect?: ClinicWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutLabsInput = {
    create?: XOR<PatientCreateWithoutLabsInput, PatientUncheckedCreateWithoutLabsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLabsInput
    connect?: PatientWhereUniqueInput
  }

  export type LabResultCreateNestedManyWithoutLabInput = {
    create?: XOR<LabResultCreateWithoutLabInput, LabResultUncheckedCreateWithoutLabInput> | LabResultCreateWithoutLabInput[] | LabResultUncheckedCreateWithoutLabInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutLabInput | LabResultCreateOrConnectWithoutLabInput[]
    createMany?: LabResultCreateManyLabInputEnvelope
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
  }

  export type LabResultUncheckedCreateNestedManyWithoutLabInput = {
    create?: XOR<LabResultCreateWithoutLabInput, LabResultUncheckedCreateWithoutLabInput> | LabResultCreateWithoutLabInput[] | LabResultUncheckedCreateWithoutLabInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutLabInput | LabResultCreateOrConnectWithoutLabInput[]
    createMany?: LabResultCreateManyLabInputEnvelope
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
  }

  export type ClinicUpdateOneWithoutLabsNestedInput = {
    create?: XOR<ClinicCreateWithoutLabsInput, ClinicUncheckedCreateWithoutLabsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutLabsInput
    upsert?: ClinicUpsertWithoutLabsInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutLabsInput, ClinicUpdateWithoutLabsInput>, ClinicUncheckedUpdateWithoutLabsInput>
  }

  export type PatientUpdateOneWithoutLabsNestedInput = {
    create?: XOR<PatientCreateWithoutLabsInput, PatientUncheckedCreateWithoutLabsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLabsInput
    upsert?: PatientUpsertWithoutLabsInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutLabsInput, PatientUpdateWithoutLabsInput>, PatientUncheckedUpdateWithoutLabsInput>
  }

  export type LabResultUpdateManyWithoutLabNestedInput = {
    create?: XOR<LabResultCreateWithoutLabInput, LabResultUncheckedCreateWithoutLabInput> | LabResultCreateWithoutLabInput[] | LabResultUncheckedCreateWithoutLabInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutLabInput | LabResultCreateOrConnectWithoutLabInput[]
    upsert?: LabResultUpsertWithWhereUniqueWithoutLabInput | LabResultUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: LabResultCreateManyLabInputEnvelope
    set?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    disconnect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    delete?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    update?: LabResultUpdateWithWhereUniqueWithoutLabInput | LabResultUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: LabResultUpdateManyWithWhereWithoutLabInput | LabResultUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
  }

  export type LabResultUncheckedUpdateManyWithoutLabNestedInput = {
    create?: XOR<LabResultCreateWithoutLabInput, LabResultUncheckedCreateWithoutLabInput> | LabResultCreateWithoutLabInput[] | LabResultUncheckedCreateWithoutLabInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutLabInput | LabResultCreateOrConnectWithoutLabInput[]
    upsert?: LabResultUpsertWithWhereUniqueWithoutLabInput | LabResultUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: LabResultCreateManyLabInputEnvelope
    set?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    disconnect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    delete?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    update?: LabResultUpdateWithWhereUniqueWithoutLabInput | LabResultUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: LabResultUpdateManyWithWhereWithoutLabInput | LabResultUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
  }

  export type LabCreateNestedOneWithoutResultsInput = {
    create?: XOR<LabCreateWithoutResultsInput, LabUncheckedCreateWithoutResultsInput>
    connectOrCreate?: LabCreateOrConnectWithoutResultsInput
    connect?: LabWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumFlagFieldUpdateOperationsInput = {
    set?: $Enums.Flag | null
  }

  export type LabUpdateOneWithoutResultsNestedInput = {
    create?: XOR<LabCreateWithoutResultsInput, LabUncheckedCreateWithoutResultsInput>
    connectOrCreate?: LabCreateOrConnectWithoutResultsInput
    upsert?: LabUpsertWithoutResultsInput
    disconnect?: LabWhereInput | boolean
    delete?: LabWhereInput | boolean
    connect?: LabWhereUniqueInput
    update?: XOR<XOR<LabUpdateToOneWithWhereWithoutResultsInput, LabUpdateWithoutResultsInput>, LabUncheckedUpdateWithoutResultsInput>
  }

  export type ClinicCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<ClinicCreateWithoutPrescriptionsInput, ClinicUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutPrescriptionsInput
    connect?: ClinicWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionsInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<DoctorCreateWithoutPrescriptionsInput, DoctorUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutPrescriptionsInput
    connect?: DoctorWhereUniqueInput
  }

  export type PrescriptionMedicineCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionMedicineCreateWithoutPrescriptionInput, PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput> | PrescriptionMedicineCreateWithoutPrescriptionInput[] | PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput | PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionMedicineCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
  }

  export type PrescriptionMedicineUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionMedicineCreateWithoutPrescriptionInput, PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput> | PrescriptionMedicineCreateWithoutPrescriptionInput[] | PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput | PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionMedicineCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
  }

  export type NullableEnumPrescriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.PrescriptionStatus | null
  }

  export type ClinicUpdateOneWithoutPrescriptionsNestedInput = {
    create?: XOR<ClinicCreateWithoutPrescriptionsInput, ClinicUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutPrescriptionsInput
    upsert?: ClinicUpsertWithoutPrescriptionsInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutPrescriptionsInput, ClinicUpdateWithoutPrescriptionsInput>, ClinicUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PatientUpdateOneWithoutPrescriptionsNestedInput = {
    create?: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionsInput
    upsert?: PatientUpsertWithoutPrescriptionsInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPrescriptionsInput, PatientUpdateWithoutPrescriptionsInput>, PatientUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type DoctorUpdateOneWithoutPrescriptionsNestedInput = {
    create?: XOR<DoctorCreateWithoutPrescriptionsInput, DoctorUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutPrescriptionsInput
    upsert?: DoctorUpsertWithoutPrescriptionsInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutPrescriptionsInput, DoctorUpdateWithoutPrescriptionsInput>, DoctorUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PrescriptionMedicineUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionMedicineCreateWithoutPrescriptionInput, PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput> | PrescriptionMedicineCreateWithoutPrescriptionInput[] | PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput | PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionMedicineUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionMedicineUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionMedicineCreateManyPrescriptionInputEnvelope
    set?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    disconnect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    delete?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    connect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    update?: PrescriptionMedicineUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionMedicineUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionMedicineUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionMedicineUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionMedicineScalarWhereInput | PrescriptionMedicineScalarWhereInput[]
  }

  export type PrescriptionMedicineUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionMedicineCreateWithoutPrescriptionInput, PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput> | PrescriptionMedicineCreateWithoutPrescriptionInput[] | PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput | PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionMedicineUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionMedicineUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionMedicineCreateManyPrescriptionInputEnvelope
    set?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    disconnect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    delete?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    connect?: PrescriptionMedicineWhereUniqueInput | PrescriptionMedicineWhereUniqueInput[]
    update?: PrescriptionMedicineUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionMedicineUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionMedicineUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionMedicineUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionMedicineScalarWhereInput | PrescriptionMedicineScalarWhereInput[]
  }

  export type PrescriptionCreateNestedOneWithoutMedicinesInput = {
    create?: XOR<PrescriptionCreateWithoutMedicinesInput, PrescriptionUncheckedCreateWithoutMedicinesInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutMedicinesInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type PrescriptionUpdateOneWithoutMedicinesNestedInput = {
    create?: XOR<PrescriptionCreateWithoutMedicinesInput, PrescriptionUncheckedCreateWithoutMedicinesInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutMedicinesInput
    upsert?: PrescriptionUpsertWithoutMedicinesInput
    disconnect?: PrescriptionWhereInput | boolean
    delete?: PrescriptionWhereInput | boolean
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutMedicinesInput, PrescriptionUpdateWithoutMedicinesInput>, PrescriptionUncheckedUpdateWithoutMedicinesInput>
  }

  export type ClinicCreateNestedOneWithoutPatientsInput = {
    create?: XOR<ClinicCreateWithoutPatientsInput, ClinicUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutPatientsInput
    connect?: ClinicWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type CallCreateNestedManyWithoutPatientInput = {
    create?: XOR<CallCreateWithoutPatientInput, CallUncheckedCreateWithoutPatientInput> | CallCreateWithoutPatientInput[] | CallUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: CallCreateOrConnectWithoutPatientInput | CallCreateOrConnectWithoutPatientInput[]
    createMany?: CallCreateManyPatientInputEnvelope
    connect?: CallWhereUniqueInput | CallWhereUniqueInput[]
  }

  export type LabCreateNestedManyWithoutPatientInput = {
    create?: XOR<LabCreateWithoutPatientInput, LabUncheckedCreateWithoutPatientInput> | LabCreateWithoutPatientInput[] | LabUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabCreateOrConnectWithoutPatientInput | LabCreateOrConnectWithoutPatientInput[]
    createMany?: LabCreateManyPatientInputEnvelope
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutPatientInput = {
    create?: XOR<TaskCreateWithoutPatientInput, TaskUncheckedCreateWithoutPatientInput> | TaskCreateWithoutPatientInput[] | TaskUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutPatientInput | TaskCreateOrConnectWithoutPatientInput[]
    createMany?: TaskCreateManyPatientInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type DataRequestCreateNestedManyWithoutPatientInput = {
    create?: XOR<DataRequestCreateWithoutPatientInput, DataRequestUncheckedCreateWithoutPatientInput> | DataRequestCreateWithoutPatientInput[] | DataRequestUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DataRequestCreateOrConnectWithoutPatientInput | DataRequestCreateOrConnectWithoutPatientInput[]
    createMany?: DataRequestCreateManyPatientInputEnvelope
    connect?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
  }

  export type EmergencyContactCreateNestedManyWithoutPatientInput = {
    create?: XOR<EmergencyContactCreateWithoutPatientInput, EmergencyContactUncheckedCreateWithoutPatientInput> | EmergencyContactCreateWithoutPatientInput[] | EmergencyContactUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutPatientInput | EmergencyContactCreateOrConnectWithoutPatientInput[]
    createMany?: EmergencyContactCreateManyPatientInputEnvelope
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
  }

  export type DiagnosisCreateNestedManyWithoutPatientInput = {
    create?: XOR<DiagnosisCreateWithoutPatientInput, DiagnosisUncheckedCreateWithoutPatientInput> | DiagnosisCreateWithoutPatientInput[] | DiagnosisUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutPatientInput | DiagnosisCreateOrConnectWithoutPatientInput[]
    createMany?: DiagnosisCreateManyPatientInputEnvelope
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
  }

  export type PatientConsentCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientConsentCreateWithoutPatientInput, PatientConsentUncheckedCreateWithoutPatientInput> | PatientConsentCreateWithoutPatientInput[] | PatientConsentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientConsentCreateOrConnectWithoutPatientInput | PatientConsentCreateOrConnectWithoutPatientInput[]
    createMany?: PatientConsentCreateManyPatientInputEnvelope
    connect?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type CallUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<CallCreateWithoutPatientInput, CallUncheckedCreateWithoutPatientInput> | CallCreateWithoutPatientInput[] | CallUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: CallCreateOrConnectWithoutPatientInput | CallCreateOrConnectWithoutPatientInput[]
    createMany?: CallCreateManyPatientInputEnvelope
    connect?: CallWhereUniqueInput | CallWhereUniqueInput[]
  }

  export type LabUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<LabCreateWithoutPatientInput, LabUncheckedCreateWithoutPatientInput> | LabCreateWithoutPatientInput[] | LabUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabCreateOrConnectWithoutPatientInput | LabCreateOrConnectWithoutPatientInput[]
    createMany?: LabCreateManyPatientInputEnvelope
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<TaskCreateWithoutPatientInput, TaskUncheckedCreateWithoutPatientInput> | TaskCreateWithoutPatientInput[] | TaskUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutPatientInput | TaskCreateOrConnectWithoutPatientInput[]
    createMany?: TaskCreateManyPatientInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type DataRequestUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<DataRequestCreateWithoutPatientInput, DataRequestUncheckedCreateWithoutPatientInput> | DataRequestCreateWithoutPatientInput[] | DataRequestUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DataRequestCreateOrConnectWithoutPatientInput | DataRequestCreateOrConnectWithoutPatientInput[]
    createMany?: DataRequestCreateManyPatientInputEnvelope
    connect?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
  }

  export type EmergencyContactUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<EmergencyContactCreateWithoutPatientInput, EmergencyContactUncheckedCreateWithoutPatientInput> | EmergencyContactCreateWithoutPatientInput[] | EmergencyContactUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutPatientInput | EmergencyContactCreateOrConnectWithoutPatientInput[]
    createMany?: EmergencyContactCreateManyPatientInputEnvelope
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
  }

  export type DiagnosisUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<DiagnosisCreateWithoutPatientInput, DiagnosisUncheckedCreateWithoutPatientInput> | DiagnosisCreateWithoutPatientInput[] | DiagnosisUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutPatientInput | DiagnosisCreateOrConnectWithoutPatientInput[]
    createMany?: DiagnosisCreateManyPatientInputEnvelope
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
  }

  export type PatientConsentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientConsentCreateWithoutPatientInput, PatientConsentUncheckedCreateWithoutPatientInput> | PatientConsentCreateWithoutPatientInput[] | PatientConsentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientConsentCreateOrConnectWithoutPatientInput | PatientConsentCreateOrConnectWithoutPatientInput[]
    createMany?: PatientConsentCreateManyPatientInputEnvelope
    connect?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type ClinicUpdateOneWithoutPatientsNestedInput = {
    create?: XOR<ClinicCreateWithoutPatientsInput, ClinicUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutPatientsInput
    upsert?: ClinicUpsertWithoutPatientsInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutPatientsInput, ClinicUpdateWithoutPatientsInput>, ClinicUncheckedUpdateWithoutPatientsInput>
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type CallUpdateManyWithoutPatientNestedInput = {
    create?: XOR<CallCreateWithoutPatientInput, CallUncheckedCreateWithoutPatientInput> | CallCreateWithoutPatientInput[] | CallUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: CallCreateOrConnectWithoutPatientInput | CallCreateOrConnectWithoutPatientInput[]
    upsert?: CallUpsertWithWhereUniqueWithoutPatientInput | CallUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: CallCreateManyPatientInputEnvelope
    set?: CallWhereUniqueInput | CallWhereUniqueInput[]
    disconnect?: CallWhereUniqueInput | CallWhereUniqueInput[]
    delete?: CallWhereUniqueInput | CallWhereUniqueInput[]
    connect?: CallWhereUniqueInput | CallWhereUniqueInput[]
    update?: CallUpdateWithWhereUniqueWithoutPatientInput | CallUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: CallUpdateManyWithWhereWithoutPatientInput | CallUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: CallScalarWhereInput | CallScalarWhereInput[]
  }

  export type LabUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LabCreateWithoutPatientInput, LabUncheckedCreateWithoutPatientInput> | LabCreateWithoutPatientInput[] | LabUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabCreateOrConnectWithoutPatientInput | LabCreateOrConnectWithoutPatientInput[]
    upsert?: LabUpsertWithWhereUniqueWithoutPatientInput | LabUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LabCreateManyPatientInputEnvelope
    set?: LabWhereUniqueInput | LabWhereUniqueInput[]
    disconnect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    delete?: LabWhereUniqueInput | LabWhereUniqueInput[]
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    update?: LabUpdateWithWhereUniqueWithoutPatientInput | LabUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LabUpdateManyWithWhereWithoutPatientInput | LabUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LabScalarWhereInput | LabScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TaskCreateWithoutPatientInput, TaskUncheckedCreateWithoutPatientInput> | TaskCreateWithoutPatientInput[] | TaskUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutPatientInput | TaskCreateOrConnectWithoutPatientInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutPatientInput | TaskUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TaskCreateManyPatientInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutPatientInput | TaskUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutPatientInput | TaskUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type DataRequestUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DataRequestCreateWithoutPatientInput, DataRequestUncheckedCreateWithoutPatientInput> | DataRequestCreateWithoutPatientInput[] | DataRequestUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DataRequestCreateOrConnectWithoutPatientInput | DataRequestCreateOrConnectWithoutPatientInput[]
    upsert?: DataRequestUpsertWithWhereUniqueWithoutPatientInput | DataRequestUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DataRequestCreateManyPatientInputEnvelope
    set?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    disconnect?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    delete?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    connect?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    update?: DataRequestUpdateWithWhereUniqueWithoutPatientInput | DataRequestUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DataRequestUpdateManyWithWhereWithoutPatientInput | DataRequestUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DataRequestScalarWhereInput | DataRequestScalarWhereInput[]
  }

  export type EmergencyContactUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutPatientInput, EmergencyContactUncheckedCreateWithoutPatientInput> | EmergencyContactCreateWithoutPatientInput[] | EmergencyContactUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutPatientInput | EmergencyContactCreateOrConnectWithoutPatientInput[]
    upsert?: EmergencyContactUpsertWithWhereUniqueWithoutPatientInput | EmergencyContactUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EmergencyContactCreateManyPatientInputEnvelope
    set?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    disconnect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    delete?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    update?: EmergencyContactUpdateWithWhereUniqueWithoutPatientInput | EmergencyContactUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EmergencyContactUpdateManyWithWhereWithoutPatientInput | EmergencyContactUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
  }

  export type DiagnosisUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DiagnosisCreateWithoutPatientInput, DiagnosisUncheckedCreateWithoutPatientInput> | DiagnosisCreateWithoutPatientInput[] | DiagnosisUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutPatientInput | DiagnosisCreateOrConnectWithoutPatientInput[]
    upsert?: DiagnosisUpsertWithWhereUniqueWithoutPatientInput | DiagnosisUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DiagnosisCreateManyPatientInputEnvelope
    set?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    disconnect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    delete?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    update?: DiagnosisUpdateWithWhereUniqueWithoutPatientInput | DiagnosisUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DiagnosisUpdateManyWithWhereWithoutPatientInput | DiagnosisUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
  }

  export type PatientConsentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientConsentCreateWithoutPatientInput, PatientConsentUncheckedCreateWithoutPatientInput> | PatientConsentCreateWithoutPatientInput[] | PatientConsentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientConsentCreateOrConnectWithoutPatientInput | PatientConsentCreateOrConnectWithoutPatientInput[]
    upsert?: PatientConsentUpsertWithWhereUniqueWithoutPatientInput | PatientConsentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientConsentCreateManyPatientInputEnvelope
    set?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    disconnect?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    delete?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    connect?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    update?: PatientConsentUpdateWithWhereUniqueWithoutPatientInput | PatientConsentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientConsentUpdateManyWithWhereWithoutPatientInput | PatientConsentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientConsentScalarWhereInput | PatientConsentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type CallUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<CallCreateWithoutPatientInput, CallUncheckedCreateWithoutPatientInput> | CallCreateWithoutPatientInput[] | CallUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: CallCreateOrConnectWithoutPatientInput | CallCreateOrConnectWithoutPatientInput[]
    upsert?: CallUpsertWithWhereUniqueWithoutPatientInput | CallUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: CallCreateManyPatientInputEnvelope
    set?: CallWhereUniqueInput | CallWhereUniqueInput[]
    disconnect?: CallWhereUniqueInput | CallWhereUniqueInput[]
    delete?: CallWhereUniqueInput | CallWhereUniqueInput[]
    connect?: CallWhereUniqueInput | CallWhereUniqueInput[]
    update?: CallUpdateWithWhereUniqueWithoutPatientInput | CallUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: CallUpdateManyWithWhereWithoutPatientInput | CallUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: CallScalarWhereInput | CallScalarWhereInput[]
  }

  export type LabUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LabCreateWithoutPatientInput, LabUncheckedCreateWithoutPatientInput> | LabCreateWithoutPatientInput[] | LabUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabCreateOrConnectWithoutPatientInput | LabCreateOrConnectWithoutPatientInput[]
    upsert?: LabUpsertWithWhereUniqueWithoutPatientInput | LabUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LabCreateManyPatientInputEnvelope
    set?: LabWhereUniqueInput | LabWhereUniqueInput[]
    disconnect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    delete?: LabWhereUniqueInput | LabWhereUniqueInput[]
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    update?: LabUpdateWithWhereUniqueWithoutPatientInput | LabUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LabUpdateManyWithWhereWithoutPatientInput | LabUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LabScalarWhereInput | LabScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TaskCreateWithoutPatientInput, TaskUncheckedCreateWithoutPatientInput> | TaskCreateWithoutPatientInput[] | TaskUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutPatientInput | TaskCreateOrConnectWithoutPatientInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutPatientInput | TaskUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TaskCreateManyPatientInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutPatientInput | TaskUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutPatientInput | TaskUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type DataRequestUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DataRequestCreateWithoutPatientInput, DataRequestUncheckedCreateWithoutPatientInput> | DataRequestCreateWithoutPatientInput[] | DataRequestUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DataRequestCreateOrConnectWithoutPatientInput | DataRequestCreateOrConnectWithoutPatientInput[]
    upsert?: DataRequestUpsertWithWhereUniqueWithoutPatientInput | DataRequestUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DataRequestCreateManyPatientInputEnvelope
    set?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    disconnect?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    delete?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    connect?: DataRequestWhereUniqueInput | DataRequestWhereUniqueInput[]
    update?: DataRequestUpdateWithWhereUniqueWithoutPatientInput | DataRequestUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DataRequestUpdateManyWithWhereWithoutPatientInput | DataRequestUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DataRequestScalarWhereInput | DataRequestScalarWhereInput[]
  }

  export type EmergencyContactUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutPatientInput, EmergencyContactUncheckedCreateWithoutPatientInput> | EmergencyContactCreateWithoutPatientInput[] | EmergencyContactUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutPatientInput | EmergencyContactCreateOrConnectWithoutPatientInput[]
    upsert?: EmergencyContactUpsertWithWhereUniqueWithoutPatientInput | EmergencyContactUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EmergencyContactCreateManyPatientInputEnvelope
    set?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    disconnect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    delete?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    update?: EmergencyContactUpdateWithWhereUniqueWithoutPatientInput | EmergencyContactUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EmergencyContactUpdateManyWithWhereWithoutPatientInput | EmergencyContactUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
  }

  export type DiagnosisUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DiagnosisCreateWithoutPatientInput, DiagnosisUncheckedCreateWithoutPatientInput> | DiagnosisCreateWithoutPatientInput[] | DiagnosisUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutPatientInput | DiagnosisCreateOrConnectWithoutPatientInput[]
    upsert?: DiagnosisUpsertWithWhereUniqueWithoutPatientInput | DiagnosisUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DiagnosisCreateManyPatientInputEnvelope
    set?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    disconnect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    delete?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    update?: DiagnosisUpdateWithWhereUniqueWithoutPatientInput | DiagnosisUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DiagnosisUpdateManyWithWhereWithoutPatientInput | DiagnosisUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
  }

  export type PatientConsentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientConsentCreateWithoutPatientInput, PatientConsentUncheckedCreateWithoutPatientInput> | PatientConsentCreateWithoutPatientInput[] | PatientConsentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientConsentCreateOrConnectWithoutPatientInput | PatientConsentCreateOrConnectWithoutPatientInput[]
    upsert?: PatientConsentUpsertWithWhereUniqueWithoutPatientInput | PatientConsentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientConsentCreateManyPatientInputEnvelope
    set?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    disconnect?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    delete?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    connect?: PatientConsentWhereUniqueInput | PatientConsentWhereUniqueInput[]
    update?: PatientConsentUpdateWithWhereUniqueWithoutPatientInput | PatientConsentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientConsentUpdateManyWithWhereWithoutPatientInput | PatientConsentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientConsentScalarWhereInput | PatientConsentScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutEmergencyContactsInput = {
    create?: XOR<PatientCreateWithoutEmergencyContactsInput, PatientUncheckedCreateWithoutEmergencyContactsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEmergencyContactsInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneWithoutEmergencyContactsNestedInput = {
    create?: XOR<PatientCreateWithoutEmergencyContactsInput, PatientUncheckedCreateWithoutEmergencyContactsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEmergencyContactsInput
    upsert?: PatientUpsertWithoutEmergencyContactsInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutEmergencyContactsInput, PatientUpdateWithoutEmergencyContactsInput>, PatientUncheckedUpdateWithoutEmergencyContactsInput>
  }

  export type DoctorCreateNestedOneWithoutStaffPersonalInfoInput = {
    create?: XOR<DoctorCreateWithoutStaffPersonalInfoInput, DoctorUncheckedCreateWithoutStaffPersonalInfoInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutStaffPersonalInfoInput
    connect?: DoctorWhereUniqueInput
  }

  export type DoctorUpdateOneWithoutStaffPersonalInfoNestedInput = {
    create?: XOR<DoctorCreateWithoutStaffPersonalInfoInput, DoctorUncheckedCreateWithoutStaffPersonalInfoInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutStaffPersonalInfoInput
    upsert?: DoctorUpsertWithoutStaffPersonalInfoInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutStaffPersonalInfoInput, DoctorUpdateWithoutStaffPersonalInfoInput>, DoctorUncheckedUpdateWithoutStaffPersonalInfoInput>
  }

  export type DoctorCreateNestedOneWithoutStaffEmploymentInfoInput = {
    create?: XOR<DoctorCreateWithoutStaffEmploymentInfoInput, DoctorUncheckedCreateWithoutStaffEmploymentInfoInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutStaffEmploymentInfoInput
    connect?: DoctorWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutSubordinatesInput = {
    create?: XOR<DoctorCreateWithoutSubordinatesInput, DoctorUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutSubordinatesInput
    connect?: DoctorWhereUniqueInput
  }

  export type NullableEnumDepartmentFieldUpdateOperationsInput = {
    set?: $Enums.Department | null
  }

  export type NullableEnumEmploymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.EmploymentType | null
  }

  export type DoctorUpdateOneWithoutStaffEmploymentInfoNestedInput = {
    create?: XOR<DoctorCreateWithoutStaffEmploymentInfoInput, DoctorUncheckedCreateWithoutStaffEmploymentInfoInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutStaffEmploymentInfoInput
    upsert?: DoctorUpsertWithoutStaffEmploymentInfoInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutStaffEmploymentInfoInput, DoctorUpdateWithoutStaffEmploymentInfoInput>, DoctorUncheckedUpdateWithoutStaffEmploymentInfoInput>
  }

  export type DoctorUpdateOneWithoutSubordinatesNestedInput = {
    create?: XOR<DoctorCreateWithoutSubordinatesInput, DoctorUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutSubordinatesInput
    upsert?: DoctorUpsertWithoutSubordinatesInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutSubordinatesInput, DoctorUpdateWithoutSubordinatesInput>, DoctorUncheckedUpdateWithoutSubordinatesInput>
  }

  export type ClinicCreateNestedOneWithoutTasksInput = {
    create?: XOR<ClinicCreateWithoutTasksInput, ClinicUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutTasksInput
    connect?: ClinicWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutAssignedTasksInput = {
    create?: XOR<DoctorCreateWithoutAssignedTasksInput, DoctorUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAssignedTasksInput
    connect?: DoctorWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutAssignedTasksInput = {
    create?: XOR<AdminCreateWithoutAssignedTasksInput, AdminUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAssignedTasksInput
    connect?: AdminWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutTasksInput = {
    create?: XOR<PatientCreateWithoutTasksInput, PatientUncheckedCreateWithoutTasksInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTasksInput
    connect?: PatientWhereUniqueInput
  }

  export type NullableEnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus | null
  }

  export type NullableEnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority | null
  }

  export type ClinicUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ClinicCreateWithoutTasksInput, ClinicUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutTasksInput
    upsert?: ClinicUpsertWithoutTasksInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutTasksInput, ClinicUpdateWithoutTasksInput>, ClinicUncheckedUpdateWithoutTasksInput>
  }

  export type DoctorUpdateOneWithoutAssignedTasksNestedInput = {
    create?: XOR<DoctorCreateWithoutAssignedTasksInput, DoctorUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAssignedTasksInput
    upsert?: DoctorUpsertWithoutAssignedTasksInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutAssignedTasksInput, DoctorUpdateWithoutAssignedTasksInput>, DoctorUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type AdminUpdateOneWithoutAssignedTasksNestedInput = {
    create?: XOR<AdminCreateWithoutAssignedTasksInput, AdminUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAssignedTasksInput
    upsert?: AdminUpsertWithoutAssignedTasksInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAssignedTasksInput, AdminUpdateWithoutAssignedTasksInput>, AdminUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type PatientUpdateOneWithoutTasksNestedInput = {
    create?: XOR<PatientCreateWithoutTasksInput, PatientUncheckedCreateWithoutTasksInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTasksInput
    upsert?: PatientUpsertWithoutTasksInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutTasksInput, PatientUpdateWithoutTasksInput>, PatientUncheckedUpdateWithoutTasksInput>
  }

  export type NullableEnumServiceNameFieldUpdateOperationsInput = {
    set?: $Enums.ServiceName | null
  }

  export type NullableEnumMetricTypeFieldUpdateOperationsInput = {
    set?: $Enums.MetricType | null
  }

  export type ClinicCreateNestedOneWithoutAdminsInput = {
    create?: XOR<ClinicCreateWithoutAdminsInput, ClinicUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutAdminsInput
    connect?: ClinicWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutAdminInput = {
    create?: XOR<SessionCreateWithoutAdminInput, SessionUncheckedCreateWithoutAdminInput> | SessionCreateWithoutAdminInput[] | SessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutAdminInput | SessionCreateOrConnectWithoutAdminInput[]
    createMany?: SessionCreateManyAdminInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<AuditLogCreateWithoutAdminInput, AuditLogUncheckedCreateWithoutAdminInput> | AuditLogCreateWithoutAdminInput[] | AuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminInput | AuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AuditLogCreateManyAdminInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutAssignedAdminInput = {
    create?: XOR<TaskCreateWithoutAssignedAdminInput, TaskUncheckedCreateWithoutAssignedAdminInput> | TaskCreateWithoutAssignedAdminInput[] | TaskUncheckedCreateWithoutAssignedAdminInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedAdminInput | TaskCreateOrConnectWithoutAssignedAdminInput[]
    createMany?: TaskCreateManyAssignedAdminInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<SessionCreateWithoutAdminInput, SessionUncheckedCreateWithoutAdminInput> | SessionCreateWithoutAdminInput[] | SessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutAdminInput | SessionCreateOrConnectWithoutAdminInput[]
    createMany?: SessionCreateManyAdminInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AuditLogCreateWithoutAdminInput, AuditLogUncheckedCreateWithoutAdminInput> | AuditLogCreateWithoutAdminInput[] | AuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminInput | AuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AuditLogCreateManyAdminInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAssignedAdminInput = {
    create?: XOR<TaskCreateWithoutAssignedAdminInput, TaskUncheckedCreateWithoutAssignedAdminInput> | TaskCreateWithoutAssignedAdminInput[] | TaskUncheckedCreateWithoutAssignedAdminInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedAdminInput | TaskCreateOrConnectWithoutAssignedAdminInput[]
    createMany?: TaskCreateManyAssignedAdminInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ClinicUpdateOneWithoutAdminsNestedInput = {
    create?: XOR<ClinicCreateWithoutAdminsInput, ClinicUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutAdminsInput
    upsert?: ClinicUpsertWithoutAdminsInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutAdminsInput, ClinicUpdateWithoutAdminsInput>, ClinicUncheckedUpdateWithoutAdminsInput>
  }

  export type SessionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<SessionCreateWithoutAdminInput, SessionUncheckedCreateWithoutAdminInput> | SessionCreateWithoutAdminInput[] | SessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutAdminInput | SessionCreateOrConnectWithoutAdminInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutAdminInput | SessionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: SessionCreateManyAdminInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutAdminInput | SessionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutAdminInput | SessionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AuditLogCreateWithoutAdminInput, AuditLogUncheckedCreateWithoutAdminInput> | AuditLogCreateWithoutAdminInput[] | AuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminInput | AuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutAdminInput | AuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AuditLogCreateManyAdminInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutAdminInput | AuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutAdminInput | AuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutAssignedAdminNestedInput = {
    create?: XOR<TaskCreateWithoutAssignedAdminInput, TaskUncheckedCreateWithoutAssignedAdminInput> | TaskCreateWithoutAssignedAdminInput[] | TaskUncheckedCreateWithoutAssignedAdminInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedAdminInput | TaskCreateOrConnectWithoutAssignedAdminInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssignedAdminInput | TaskUpsertWithWhereUniqueWithoutAssignedAdminInput[]
    createMany?: TaskCreateManyAssignedAdminInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssignedAdminInput | TaskUpdateWithWhereUniqueWithoutAssignedAdminInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssignedAdminInput | TaskUpdateManyWithWhereWithoutAssignedAdminInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<SessionCreateWithoutAdminInput, SessionUncheckedCreateWithoutAdminInput> | SessionCreateWithoutAdminInput[] | SessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutAdminInput | SessionCreateOrConnectWithoutAdminInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutAdminInput | SessionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: SessionCreateManyAdminInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutAdminInput | SessionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutAdminInput | SessionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AuditLogCreateWithoutAdminInput, AuditLogUncheckedCreateWithoutAdminInput> | AuditLogCreateWithoutAdminInput[] | AuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminInput | AuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutAdminInput | AuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AuditLogCreateManyAdminInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutAdminInput | AuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutAdminInput | AuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAssignedAdminNestedInput = {
    create?: XOR<TaskCreateWithoutAssignedAdminInput, TaskUncheckedCreateWithoutAssignedAdminInput> | TaskCreateWithoutAssignedAdminInput[] | TaskUncheckedCreateWithoutAssignedAdminInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedAdminInput | TaskCreateOrConnectWithoutAssignedAdminInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssignedAdminInput | TaskUpsertWithWhereUniqueWithoutAssignedAdminInput[]
    createMany?: TaskCreateManyAssignedAdminInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssignedAdminInput | TaskUpdateWithWhereUniqueWithoutAssignedAdminInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssignedAdminInput | TaskUpdateManyWithWhereWithoutAssignedAdminInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type DoctorCreatespecialitiesInput = {
    set: string[]
  }

  export type ClinicCreateNestedOneWithoutDoctorsInput = {
    create?: XOR<ClinicCreateWithoutDoctorsInput, ClinicUncheckedCreateWithoutDoctorsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutDoctorsInput
    connect?: ClinicWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutDoctorInput = {
    create?: XOR<SessionCreateWithoutDoctorInput, SessionUncheckedCreateWithoutDoctorInput> | SessionCreateWithoutDoctorInput[] | SessionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutDoctorInput | SessionCreateOrConnectWithoutDoctorInput[]
    createMany?: SessionCreateManyDoctorInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type CallCreateNestedManyWithoutDoctorInput = {
    create?: XOR<CallCreateWithoutDoctorInput, CallUncheckedCreateWithoutDoctorInput> | CallCreateWithoutDoctorInput[] | CallUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: CallCreateOrConnectWithoutDoctorInput | CallCreateOrConnectWithoutDoctorInput[]
    createMany?: CallCreateManyDoctorInputEnvelope
    connect?: CallWhereUniqueInput | CallWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type DiagnosisCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput> | DiagnosisCreateWithoutDoctorInput[] | DiagnosisUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutDoctorInput | DiagnosisCreateOrConnectWithoutDoctorInput[]
    createMany?: DiagnosisCreateManyDoctorInputEnvelope
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutAssignedDoctorInput = {
    create?: XOR<TaskCreateWithoutAssignedDoctorInput, TaskUncheckedCreateWithoutAssignedDoctorInput> | TaskCreateWithoutAssignedDoctorInput[] | TaskUncheckedCreateWithoutAssignedDoctorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedDoctorInput | TaskCreateOrConnectWithoutAssignedDoctorInput[]
    createMany?: TaskCreateManyAssignedDoctorInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AuditLogCreateWithoutDoctorInput, AuditLogUncheckedCreateWithoutDoctorInput> | AuditLogCreateWithoutDoctorInput[] | AuditLogUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutDoctorInput | AuditLogCreateOrConnectWithoutDoctorInput[]
    createMany?: AuditLogCreateManyDoctorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StaffPersonalInfoCreateNestedOneWithoutDoctorInput = {
    create?: XOR<StaffPersonalInfoCreateWithoutDoctorInput, StaffPersonalInfoUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: StaffPersonalInfoCreateOrConnectWithoutDoctorInput
    connect?: StaffPersonalInfoWhereUniqueInput
  }

  export type StaffEmploymentInfoCreateNestedOneWithoutDoctorInput = {
    create?: XOR<StaffEmploymentInfoCreateWithoutDoctorInput, StaffEmploymentInfoUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: StaffEmploymentInfoCreateOrConnectWithoutDoctorInput
    connect?: StaffEmploymentInfoWhereUniqueInput
  }

  export type StaffEmploymentInfoCreateNestedManyWithoutReportingToInput = {
    create?: XOR<StaffEmploymentInfoCreateWithoutReportingToInput, StaffEmploymentInfoUncheckedCreateWithoutReportingToInput> | StaffEmploymentInfoCreateWithoutReportingToInput[] | StaffEmploymentInfoUncheckedCreateWithoutReportingToInput[]
    connectOrCreate?: StaffEmploymentInfoCreateOrConnectWithoutReportingToInput | StaffEmploymentInfoCreateOrConnectWithoutReportingToInput[]
    createMany?: StaffEmploymentInfoCreateManyReportingToInputEnvelope
    connect?: StaffEmploymentInfoWhereUniqueInput | StaffEmploymentInfoWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<SessionCreateWithoutDoctorInput, SessionUncheckedCreateWithoutDoctorInput> | SessionCreateWithoutDoctorInput[] | SessionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutDoctorInput | SessionCreateOrConnectWithoutDoctorInput[]
    createMany?: SessionCreateManyDoctorInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type CallUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<CallCreateWithoutDoctorInput, CallUncheckedCreateWithoutDoctorInput> | CallCreateWithoutDoctorInput[] | CallUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: CallCreateOrConnectWithoutDoctorInput | CallCreateOrConnectWithoutDoctorInput[]
    createMany?: CallCreateManyDoctorInputEnvelope
    connect?: CallWhereUniqueInput | CallWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type DiagnosisUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput> | DiagnosisCreateWithoutDoctorInput[] | DiagnosisUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutDoctorInput | DiagnosisCreateOrConnectWithoutDoctorInput[]
    createMany?: DiagnosisCreateManyDoctorInputEnvelope
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAssignedDoctorInput = {
    create?: XOR<TaskCreateWithoutAssignedDoctorInput, TaskUncheckedCreateWithoutAssignedDoctorInput> | TaskCreateWithoutAssignedDoctorInput[] | TaskUncheckedCreateWithoutAssignedDoctorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedDoctorInput | TaskCreateOrConnectWithoutAssignedDoctorInput[]
    createMany?: TaskCreateManyAssignedDoctorInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AuditLogCreateWithoutDoctorInput, AuditLogUncheckedCreateWithoutDoctorInput> | AuditLogCreateWithoutDoctorInput[] | AuditLogUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutDoctorInput | AuditLogCreateOrConnectWithoutDoctorInput[]
    createMany?: AuditLogCreateManyDoctorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StaffPersonalInfoUncheckedCreateNestedOneWithoutDoctorInput = {
    create?: XOR<StaffPersonalInfoCreateWithoutDoctorInput, StaffPersonalInfoUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: StaffPersonalInfoCreateOrConnectWithoutDoctorInput
    connect?: StaffPersonalInfoWhereUniqueInput
  }

  export type StaffEmploymentInfoUncheckedCreateNestedOneWithoutDoctorInput = {
    create?: XOR<StaffEmploymentInfoCreateWithoutDoctorInput, StaffEmploymentInfoUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: StaffEmploymentInfoCreateOrConnectWithoutDoctorInput
    connect?: StaffEmploymentInfoWhereUniqueInput
  }

  export type StaffEmploymentInfoUncheckedCreateNestedManyWithoutReportingToInput = {
    create?: XOR<StaffEmploymentInfoCreateWithoutReportingToInput, StaffEmploymentInfoUncheckedCreateWithoutReportingToInput> | StaffEmploymentInfoCreateWithoutReportingToInput[] | StaffEmploymentInfoUncheckedCreateWithoutReportingToInput[]
    connectOrCreate?: StaffEmploymentInfoCreateOrConnectWithoutReportingToInput | StaffEmploymentInfoCreateOrConnectWithoutReportingToInput[]
    createMany?: StaffEmploymentInfoCreateManyReportingToInputEnvelope
    connect?: StaffEmploymentInfoWhereUniqueInput | StaffEmploymentInfoWhereUniqueInput[]
  }

  export type DoctorUpdatespecialitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClinicUpdateOneWithoutDoctorsNestedInput = {
    create?: XOR<ClinicCreateWithoutDoctorsInput, ClinicUncheckedCreateWithoutDoctorsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutDoctorsInput
    upsert?: ClinicUpsertWithoutDoctorsInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutDoctorsInput, ClinicUpdateWithoutDoctorsInput>, ClinicUncheckedUpdateWithoutDoctorsInput>
  }

  export type SessionUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<SessionCreateWithoutDoctorInput, SessionUncheckedCreateWithoutDoctorInput> | SessionCreateWithoutDoctorInput[] | SessionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutDoctorInput | SessionCreateOrConnectWithoutDoctorInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutDoctorInput | SessionUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: SessionCreateManyDoctorInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutDoctorInput | SessionUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutDoctorInput | SessionUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type CallUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<CallCreateWithoutDoctorInput, CallUncheckedCreateWithoutDoctorInput> | CallCreateWithoutDoctorInput[] | CallUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: CallCreateOrConnectWithoutDoctorInput | CallCreateOrConnectWithoutDoctorInput[]
    upsert?: CallUpsertWithWhereUniqueWithoutDoctorInput | CallUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: CallCreateManyDoctorInputEnvelope
    set?: CallWhereUniqueInput | CallWhereUniqueInput[]
    disconnect?: CallWhereUniqueInput | CallWhereUniqueInput[]
    delete?: CallWhereUniqueInput | CallWhereUniqueInput[]
    connect?: CallWhereUniqueInput | CallWhereUniqueInput[]
    update?: CallUpdateWithWhereUniqueWithoutDoctorInput | CallUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: CallUpdateManyWithWhereWithoutDoctorInput | CallUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: CallScalarWhereInput | CallScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutDoctorInput | PrescriptionUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutDoctorInput | PrescriptionUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutDoctorInput | PrescriptionUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type DiagnosisUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput> | DiagnosisCreateWithoutDoctorInput[] | DiagnosisUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutDoctorInput | DiagnosisCreateOrConnectWithoutDoctorInput[]
    upsert?: DiagnosisUpsertWithWhereUniqueWithoutDoctorInput | DiagnosisUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DiagnosisCreateManyDoctorInputEnvelope
    set?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    disconnect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    delete?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    update?: DiagnosisUpdateWithWhereUniqueWithoutDoctorInput | DiagnosisUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DiagnosisUpdateManyWithWhereWithoutDoctorInput | DiagnosisUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutAssignedDoctorNestedInput = {
    create?: XOR<TaskCreateWithoutAssignedDoctorInput, TaskUncheckedCreateWithoutAssignedDoctorInput> | TaskCreateWithoutAssignedDoctorInput[] | TaskUncheckedCreateWithoutAssignedDoctorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedDoctorInput | TaskCreateOrConnectWithoutAssignedDoctorInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssignedDoctorInput | TaskUpsertWithWhereUniqueWithoutAssignedDoctorInput[]
    createMany?: TaskCreateManyAssignedDoctorInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssignedDoctorInput | TaskUpdateWithWhereUniqueWithoutAssignedDoctorInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssignedDoctorInput | TaskUpdateManyWithWhereWithoutAssignedDoctorInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AuditLogCreateWithoutDoctorInput, AuditLogUncheckedCreateWithoutDoctorInput> | AuditLogCreateWithoutDoctorInput[] | AuditLogUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutDoctorInput | AuditLogCreateOrConnectWithoutDoctorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutDoctorInput | AuditLogUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AuditLogCreateManyDoctorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutDoctorInput | AuditLogUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutDoctorInput | AuditLogUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type StaffPersonalInfoUpdateOneWithoutDoctorNestedInput = {
    create?: XOR<StaffPersonalInfoCreateWithoutDoctorInput, StaffPersonalInfoUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: StaffPersonalInfoCreateOrConnectWithoutDoctorInput
    upsert?: StaffPersonalInfoUpsertWithoutDoctorInput
    disconnect?: StaffPersonalInfoWhereInput | boolean
    delete?: StaffPersonalInfoWhereInput | boolean
    connect?: StaffPersonalInfoWhereUniqueInput
    update?: XOR<XOR<StaffPersonalInfoUpdateToOneWithWhereWithoutDoctorInput, StaffPersonalInfoUpdateWithoutDoctorInput>, StaffPersonalInfoUncheckedUpdateWithoutDoctorInput>
  }

  export type StaffEmploymentInfoUpdateOneWithoutDoctorNestedInput = {
    create?: XOR<StaffEmploymentInfoCreateWithoutDoctorInput, StaffEmploymentInfoUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: StaffEmploymentInfoCreateOrConnectWithoutDoctorInput
    upsert?: StaffEmploymentInfoUpsertWithoutDoctorInput
    disconnect?: StaffEmploymentInfoWhereInput | boolean
    delete?: StaffEmploymentInfoWhereInput | boolean
    connect?: StaffEmploymentInfoWhereUniqueInput
    update?: XOR<XOR<StaffEmploymentInfoUpdateToOneWithWhereWithoutDoctorInput, StaffEmploymentInfoUpdateWithoutDoctorInput>, StaffEmploymentInfoUncheckedUpdateWithoutDoctorInput>
  }

  export type StaffEmploymentInfoUpdateManyWithoutReportingToNestedInput = {
    create?: XOR<StaffEmploymentInfoCreateWithoutReportingToInput, StaffEmploymentInfoUncheckedCreateWithoutReportingToInput> | StaffEmploymentInfoCreateWithoutReportingToInput[] | StaffEmploymentInfoUncheckedCreateWithoutReportingToInput[]
    connectOrCreate?: StaffEmploymentInfoCreateOrConnectWithoutReportingToInput | StaffEmploymentInfoCreateOrConnectWithoutReportingToInput[]
    upsert?: StaffEmploymentInfoUpsertWithWhereUniqueWithoutReportingToInput | StaffEmploymentInfoUpsertWithWhereUniqueWithoutReportingToInput[]
    createMany?: StaffEmploymentInfoCreateManyReportingToInputEnvelope
    set?: StaffEmploymentInfoWhereUniqueInput | StaffEmploymentInfoWhereUniqueInput[]
    disconnect?: StaffEmploymentInfoWhereUniqueInput | StaffEmploymentInfoWhereUniqueInput[]
    delete?: StaffEmploymentInfoWhereUniqueInput | StaffEmploymentInfoWhereUniqueInput[]
    connect?: StaffEmploymentInfoWhereUniqueInput | StaffEmploymentInfoWhereUniqueInput[]
    update?: StaffEmploymentInfoUpdateWithWhereUniqueWithoutReportingToInput | StaffEmploymentInfoUpdateWithWhereUniqueWithoutReportingToInput[]
    updateMany?: StaffEmploymentInfoUpdateManyWithWhereWithoutReportingToInput | StaffEmploymentInfoUpdateManyWithWhereWithoutReportingToInput[]
    deleteMany?: StaffEmploymentInfoScalarWhereInput | StaffEmploymentInfoScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<SessionCreateWithoutDoctorInput, SessionUncheckedCreateWithoutDoctorInput> | SessionCreateWithoutDoctorInput[] | SessionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutDoctorInput | SessionCreateOrConnectWithoutDoctorInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutDoctorInput | SessionUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: SessionCreateManyDoctorInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutDoctorInput | SessionUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutDoctorInput | SessionUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type CallUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<CallCreateWithoutDoctorInput, CallUncheckedCreateWithoutDoctorInput> | CallCreateWithoutDoctorInput[] | CallUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: CallCreateOrConnectWithoutDoctorInput | CallCreateOrConnectWithoutDoctorInput[]
    upsert?: CallUpsertWithWhereUniqueWithoutDoctorInput | CallUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: CallCreateManyDoctorInputEnvelope
    set?: CallWhereUniqueInput | CallWhereUniqueInput[]
    disconnect?: CallWhereUniqueInput | CallWhereUniqueInput[]
    delete?: CallWhereUniqueInput | CallWhereUniqueInput[]
    connect?: CallWhereUniqueInput | CallWhereUniqueInput[]
    update?: CallUpdateWithWhereUniqueWithoutDoctorInput | CallUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: CallUpdateManyWithWhereWithoutDoctorInput | CallUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: CallScalarWhereInput | CallScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutDoctorInput | PrescriptionUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutDoctorInput | PrescriptionUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutDoctorInput | PrescriptionUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput> | DiagnosisCreateWithoutDoctorInput[] | DiagnosisUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutDoctorInput | DiagnosisCreateOrConnectWithoutDoctorInput[]
    upsert?: DiagnosisUpsertWithWhereUniqueWithoutDoctorInput | DiagnosisUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DiagnosisCreateManyDoctorInputEnvelope
    set?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    disconnect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    delete?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    update?: DiagnosisUpdateWithWhereUniqueWithoutDoctorInput | DiagnosisUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DiagnosisUpdateManyWithWhereWithoutDoctorInput | DiagnosisUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAssignedDoctorNestedInput = {
    create?: XOR<TaskCreateWithoutAssignedDoctorInput, TaskUncheckedCreateWithoutAssignedDoctorInput> | TaskCreateWithoutAssignedDoctorInput[] | TaskUncheckedCreateWithoutAssignedDoctorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedDoctorInput | TaskCreateOrConnectWithoutAssignedDoctorInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssignedDoctorInput | TaskUpsertWithWhereUniqueWithoutAssignedDoctorInput[]
    createMany?: TaskCreateManyAssignedDoctorInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssignedDoctorInput | TaskUpdateWithWhereUniqueWithoutAssignedDoctorInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssignedDoctorInput | TaskUpdateManyWithWhereWithoutAssignedDoctorInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AuditLogCreateWithoutDoctorInput, AuditLogUncheckedCreateWithoutDoctorInput> | AuditLogCreateWithoutDoctorInput[] | AuditLogUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutDoctorInput | AuditLogCreateOrConnectWithoutDoctorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutDoctorInput | AuditLogUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AuditLogCreateManyDoctorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutDoctorInput | AuditLogUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutDoctorInput | AuditLogUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type StaffPersonalInfoUncheckedUpdateOneWithoutDoctorNestedInput = {
    create?: XOR<StaffPersonalInfoCreateWithoutDoctorInput, StaffPersonalInfoUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: StaffPersonalInfoCreateOrConnectWithoutDoctorInput
    upsert?: StaffPersonalInfoUpsertWithoutDoctorInput
    disconnect?: StaffPersonalInfoWhereInput | boolean
    delete?: StaffPersonalInfoWhereInput | boolean
    connect?: StaffPersonalInfoWhereUniqueInput
    update?: XOR<XOR<StaffPersonalInfoUpdateToOneWithWhereWithoutDoctorInput, StaffPersonalInfoUpdateWithoutDoctorInput>, StaffPersonalInfoUncheckedUpdateWithoutDoctorInput>
  }

  export type StaffEmploymentInfoUncheckedUpdateOneWithoutDoctorNestedInput = {
    create?: XOR<StaffEmploymentInfoCreateWithoutDoctorInput, StaffEmploymentInfoUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: StaffEmploymentInfoCreateOrConnectWithoutDoctorInput
    upsert?: StaffEmploymentInfoUpsertWithoutDoctorInput
    disconnect?: StaffEmploymentInfoWhereInput | boolean
    delete?: StaffEmploymentInfoWhereInput | boolean
    connect?: StaffEmploymentInfoWhereUniqueInput
    update?: XOR<XOR<StaffEmploymentInfoUpdateToOneWithWhereWithoutDoctorInput, StaffEmploymentInfoUpdateWithoutDoctorInput>, StaffEmploymentInfoUncheckedUpdateWithoutDoctorInput>
  }

  export type StaffEmploymentInfoUncheckedUpdateManyWithoutReportingToNestedInput = {
    create?: XOR<StaffEmploymentInfoCreateWithoutReportingToInput, StaffEmploymentInfoUncheckedCreateWithoutReportingToInput> | StaffEmploymentInfoCreateWithoutReportingToInput[] | StaffEmploymentInfoUncheckedCreateWithoutReportingToInput[]
    connectOrCreate?: StaffEmploymentInfoCreateOrConnectWithoutReportingToInput | StaffEmploymentInfoCreateOrConnectWithoutReportingToInput[]
    upsert?: StaffEmploymentInfoUpsertWithWhereUniqueWithoutReportingToInput | StaffEmploymentInfoUpsertWithWhereUniqueWithoutReportingToInput[]
    createMany?: StaffEmploymentInfoCreateManyReportingToInputEnvelope
    set?: StaffEmploymentInfoWhereUniqueInput | StaffEmploymentInfoWhereUniqueInput[]
    disconnect?: StaffEmploymentInfoWhereUniqueInput | StaffEmploymentInfoWhereUniqueInput[]
    delete?: StaffEmploymentInfoWhereUniqueInput | StaffEmploymentInfoWhereUniqueInput[]
    connect?: StaffEmploymentInfoWhereUniqueInput | StaffEmploymentInfoWhereUniqueInput[]
    update?: StaffEmploymentInfoUpdateWithWhereUniqueWithoutReportingToInput | StaffEmploymentInfoUpdateWithWhereUniqueWithoutReportingToInput[]
    updateMany?: StaffEmploymentInfoUpdateManyWithWhereWithoutReportingToInput | StaffEmploymentInfoUpdateManyWithWhereWithoutReportingToInput[]
    deleteMany?: StaffEmploymentInfoScalarWhereInput | StaffEmploymentInfoScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutSessionsInput = {
    create?: XOR<AdminCreateWithoutSessionsInput, AdminUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSessionsInput
    connect?: AdminWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutSessionsInput = {
    create?: XOR<DoctorCreateWithoutSessionsInput, DoctorUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutSessionsInput
    connect?: DoctorWhereUniqueInput
  }

  export type AdminUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<AdminCreateWithoutSessionsInput, AdminUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSessionsInput
    upsert?: AdminUpsertWithoutSessionsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutSessionsInput, AdminUpdateWithoutSessionsInput>, AdminUncheckedUpdateWithoutSessionsInput>
  }

  export type DoctorUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<DoctorCreateWithoutSessionsInput, DoctorUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutSessionsInput
    upsert?: DoctorUpsertWithoutSessionsInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutSessionsInput, DoctorUpdateWithoutSessionsInput>, DoctorUncheckedUpdateWithoutSessionsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumPlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanNullableFilter<$PrismaModel> | $Enums.Plan | null
  }

  export type NestedEnumSubscriptionStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumPlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.Plan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlanNullableFilter<$PrismaModel>
    _max?: NestedEnumPlanNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumNotificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationTypeNullableFilter<$PrismaModel> | $Enums.NotificationType | null
  }

  export type NestedEnumNotificationStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationStatusNullableFilter<$PrismaModel> | $Enums.NotificationStatus | null
  }

  export type NestedEnumNotificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumNotificationStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumConsentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentType | EnumConsentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConsentTypeNullableFilter<$PrismaModel> | $Enums.ConsentType | null
  }

  export type NestedEnumConsentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentType | EnumConsentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConsentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ConsentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumConsentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumConsentTypeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedEnumDataRequestTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestType | EnumDataRequestTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDataRequestTypeNullableFilter<$PrismaModel> | $Enums.DataRequestType | null
  }

  export type NestedEnumDataRequestStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestStatus | EnumDataRequestStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDataRequestStatusNullableFilter<$PrismaModel> | $Enums.DataRequestStatus | null
  }

  export type NestedEnumDataRequestTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestType | EnumDataRequestTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DataRequestType[] | ListEnumDataRequestTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDataRequestTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DataRequestType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDataRequestTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDataRequestTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumDataRequestStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRequestStatus | EnumDataRequestStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DataRequestStatus[] | ListEnumDataRequestStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDataRequestStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.DataRequestStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDataRequestStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumDataRequestStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAppointmentStatusNullableFilter<$PrismaModel> | $Enums.AppointmentStatus | null
  }

  export type NestedEnumAppointmentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAppointmentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumCallStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CallStatus | EnumCallStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCallStatusNullableFilter<$PrismaModel> | $Enums.CallStatus | null
  }

  export type NestedEnumSentimentNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sentiment | EnumSentimentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSentimentNullableFilter<$PrismaModel> | $Enums.Sentiment | null
  }

  export type NestedEnumCallStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallStatus | EnumCallStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCallStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.CallStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCallStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumCallStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumSentimentNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sentiment | EnumSentimentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSentimentNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sentiment | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSentimentNullableFilter<$PrismaModel>
    _max?: NestedEnumSentimentNullableFilter<$PrismaModel>
  }

  export type NestedEnumFlagNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Flag | EnumFlagFieldRefInput<$PrismaModel> | null
    in?: $Enums.Flag[] | ListEnumFlagFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Flag[] | ListEnumFlagFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFlagNullableFilter<$PrismaModel> | $Enums.Flag | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumFlagNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Flag | EnumFlagFieldRefInput<$PrismaModel> | null
    in?: $Enums.Flag[] | ListEnumFlagFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Flag[] | ListEnumFlagFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFlagNullableWithAggregatesFilter<$PrismaModel> | $Enums.Flag | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFlagNullableFilter<$PrismaModel>
    _max?: NestedEnumFlagNullableFilter<$PrismaModel>
  }

  export type NestedEnumPrescriptionStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PrescriptionStatus | EnumPrescriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPrescriptionStatusNullableFilter<$PrismaModel> | $Enums.PrescriptionStatus | null
  }

  export type NestedEnumPrescriptionStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrescriptionStatus | EnumPrescriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPrescriptionStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.PrescriptionStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPrescriptionStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumPrescriptionStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumDepartmentNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Department | EnumDepartmentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDepartmentNullableFilter<$PrismaModel> | $Enums.Department | null
  }

  export type NestedEnumEmploymentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEmploymentTypeNullableFilter<$PrismaModel> | $Enums.EmploymentType | null
  }

  export type NestedEnumDepartmentNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Department | EnumDepartmentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDepartmentNullableWithAggregatesFilter<$PrismaModel> | $Enums.Department | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDepartmentNullableFilter<$PrismaModel>
    _max?: NestedEnumDepartmentNullableFilter<$PrismaModel>
  }

  export type NestedEnumEmploymentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEmploymentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEmploymentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEmploymentTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskStatusNullableFilter<$PrismaModel> | $Enums.TaskStatus | null
  }

  export type NestedEnumPriorityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableFilter<$PrismaModel> | $Enums.Priority | null
  }

  export type NestedEnumTaskStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumPriorityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Priority | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPriorityNullableFilter<$PrismaModel>
    _max?: NestedEnumPriorityNullableFilter<$PrismaModel>
  }

  export type NestedEnumServiceNameNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceName | EnumServiceNameFieldRefInput<$PrismaModel> | null
    in?: $Enums.ServiceName[] | ListEnumServiceNameFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ServiceName[] | ListEnumServiceNameFieldRefInput<$PrismaModel> | null
    not?: NestedEnumServiceNameNullableFilter<$PrismaModel> | $Enums.ServiceName | null
  }

  export type NestedEnumMetricTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MetricType | EnumMetricTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMetricTypeNullableFilter<$PrismaModel> | $Enums.MetricType | null
  }

  export type NestedEnumServiceNameNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceName | EnumServiceNameFieldRefInput<$PrismaModel> | null
    in?: $Enums.ServiceName[] | ListEnumServiceNameFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ServiceName[] | ListEnumServiceNameFieldRefInput<$PrismaModel> | null
    not?: NestedEnumServiceNameNullableWithAggregatesFilter<$PrismaModel> | $Enums.ServiceName | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumServiceNameNullableFilter<$PrismaModel>
    _max?: NestedEnumServiceNameNullableFilter<$PrismaModel>
  }

  export type NestedEnumMetricTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetricType | EnumMetricTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMetricTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.MetricType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMetricTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumMetricTypeNullableFilter<$PrismaModel>
  }

  export type ClinicCreateWithoutSubscriptionInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminCreateNestedManyWithoutClinicInput
    doctors?: DoctorCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    calls?: CallCreateNestedManyWithoutClinicInput
    labs?: LabCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionCreateNestedManyWithoutClinicInput
    tasks?: TaskCreateNestedManyWithoutClinicInput
    invoices?: InvoiceCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutClinicInput
    doctors?: DoctorUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    calls?: CallUncheckedCreateNestedManyWithoutClinicInput
    labs?: LabUncheckedCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutClinicInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutSubscriptionInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutSubscriptionInput, ClinicUncheckedCreateWithoutSubscriptionInput>
  }

  export type ClinicUpsertWithoutSubscriptionInput = {
    update: XOR<ClinicUpdateWithoutSubscriptionInput, ClinicUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<ClinicCreateWithoutSubscriptionInput, ClinicUncheckedCreateWithoutSubscriptionInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutSubscriptionInput, ClinicUncheckedUpdateWithoutSubscriptionInput>
  }

  export type ClinicUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    calls?: CallUpdateManyWithoutClinicNestedInput
    labs?: LabUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutClinicNestedInput
    tasks?: TaskUpdateManyWithoutClinicNestedInput
    invoices?: InvoiceUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    calls?: CallUncheckedUpdateManyWithoutClinicNestedInput
    labs?: LabUncheckedUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutClinicNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ClinicCreateWithoutInvoicesInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminCreateNestedManyWithoutClinicInput
    doctors?: DoctorCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    calls?: CallCreateNestedManyWithoutClinicInput
    labs?: LabCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionCreateNestedManyWithoutClinicInput
    tasks?: TaskCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    notificationQueues?: NotificationQueueCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutClinicInput
    doctors?: DoctorUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    calls?: CallUncheckedCreateNestedManyWithoutClinicInput
    labs?: LabUncheckedCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutClinicInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    notificationQueues?: NotificationQueueUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutInvoicesInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutInvoicesInput, ClinicUncheckedCreateWithoutInvoicesInput>
  }

  export type ClinicUpsertWithoutInvoicesInput = {
    update: XOR<ClinicUpdateWithoutInvoicesInput, ClinicUncheckedUpdateWithoutInvoicesInput>
    create: XOR<ClinicCreateWithoutInvoicesInput, ClinicUncheckedCreateWithoutInvoicesInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutInvoicesInput, ClinicUncheckedUpdateWithoutInvoicesInput>
  }

  export type ClinicUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    calls?: CallUpdateManyWithoutClinicNestedInput
    labs?: LabUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutClinicNestedInput
    tasks?: TaskUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    calls?: CallUncheckedUpdateManyWithoutClinicNestedInput
    labs?: LabUncheckedUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutClinicNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ClinicCreateWithoutNotificationQueuesInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminCreateNestedManyWithoutClinicInput
    doctors?: DoctorCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    calls?: CallCreateNestedManyWithoutClinicInput
    labs?: LabCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionCreateNestedManyWithoutClinicInput
    tasks?: TaskCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    invoices?: InvoiceCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutNotificationQueuesInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutClinicInput
    doctors?: DoctorUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    calls?: CallUncheckedCreateNestedManyWithoutClinicInput
    labs?: LabUncheckedCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutClinicInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutNotificationQueuesInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutNotificationQueuesInput, ClinicUncheckedCreateWithoutNotificationQueuesInput>
  }

  export type ClinicUpsertWithoutNotificationQueuesInput = {
    update: XOR<ClinicUpdateWithoutNotificationQueuesInput, ClinicUncheckedUpdateWithoutNotificationQueuesInput>
    create: XOR<ClinicCreateWithoutNotificationQueuesInput, ClinicUncheckedCreateWithoutNotificationQueuesInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutNotificationQueuesInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutNotificationQueuesInput, ClinicUncheckedUpdateWithoutNotificationQueuesInput>
  }

  export type ClinicUpdateWithoutNotificationQueuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    calls?: CallUpdateManyWithoutClinicNestedInput
    labs?: LabUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutClinicNestedInput
    tasks?: TaskUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutNotificationQueuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    calls?: CallUncheckedUpdateManyWithoutClinicNestedInput
    labs?: LabUncheckedUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutClinicNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type AdminCreateWithoutClinicInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutAdminInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedAdminInput
  }

  export type AdminUncheckedCreateWithoutClinicInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedAdminInput
  }

  export type AdminCreateOrConnectWithoutClinicInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutClinicInput, AdminUncheckedCreateWithoutClinicInput>
  }

  export type AdminCreateManyClinicInputEnvelope = {
    data: AdminCreateManyClinicInput | AdminCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type DoctorCreateWithoutClinicInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    calls?: CallCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoCreateNestedManyWithoutReportingToInput
  }

  export type DoctorUncheckedCreateWithoutClinicInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    calls?: CallUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoUncheckedCreateNestedManyWithoutReportingToInput
  }

  export type DoctorCreateOrConnectWithoutClinicInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutClinicInput, DoctorUncheckedCreateWithoutClinicInput>
  }

  export type DoctorCreateManyClinicInputEnvelope = {
    data: DoctorCreateManyClinicInput | DoctorCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutClinicInput = {
    id?: string
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    calls?: CallCreateNestedManyWithoutPatientInput
    labs?: LabCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    tasks?: TaskCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisCreateNestedManyWithoutPatientInput
    consents?: PatientConsentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutClinicInput = {
    id?: string
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    calls?: CallUncheckedCreateNestedManyWithoutPatientInput
    labs?: LabUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    consents?: PatientConsentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutClinicInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput>
  }

  export type PatientCreateManyClinicInputEnvelope = {
    data: PatientCreateManyClinicInput | PatientCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutClinicInput = {
    id?: string
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.AppointmentStatus | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    patient?: PatientCreateNestedOneWithoutAppointmentsInput
    doctor?: DoctorCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutClinicInput = {
    id?: string
    patientId?: string | null
    doctorId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.AppointmentStatus | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type AppointmentCreateOrConnectWithoutClinicInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutClinicInput, AppointmentUncheckedCreateWithoutClinicInput>
  }

  export type AppointmentCreateManyClinicInputEnvelope = {
    data: AppointmentCreateManyClinicInput | AppointmentCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type CallCreateWithoutClinicInput = {
    id?: string
    startAt?: Date | string | null
    endAt?: Date | string | null
    durationSeconds?: number | null
    status?: $Enums.CallStatus | null
    recordingUrlCipher?: string | null
    transcript?: string | null
    aiSummary?: string | null
    sentiment?: $Enums.Sentiment | null
    escalated?: boolean | null
    minutesUsed?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    aiModelId?: string | null
    aiDecision?: string | null
    patient?: PatientCreateNestedOneWithoutCallsInput
    doctor?: DoctorCreateNestedOneWithoutCallsInput
  }

  export type CallUncheckedCreateWithoutClinicInput = {
    id?: string
    patientId?: string | null
    doctorId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    durationSeconds?: number | null
    status?: $Enums.CallStatus | null
    recordingUrlCipher?: string | null
    transcript?: string | null
    aiSummary?: string | null
    sentiment?: $Enums.Sentiment | null
    escalated?: boolean | null
    minutesUsed?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    aiModelId?: string | null
    aiDecision?: string | null
  }

  export type CallCreateOrConnectWithoutClinicInput = {
    where: CallWhereUniqueInput
    create: XOR<CallCreateWithoutClinicInput, CallUncheckedCreateWithoutClinicInput>
  }

  export type CallCreateManyClinicInputEnvelope = {
    data: CallCreateManyClinicInput | CallCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type LabCreateWithoutClinicInput = {
    id?: string
    testDate?: Date | string | null
    pdfKeyCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    patient?: PatientCreateNestedOneWithoutLabsInput
    results?: LabResultCreateNestedManyWithoutLabInput
  }

  export type LabUncheckedCreateWithoutClinicInput = {
    id?: string
    patientId?: string | null
    testDate?: Date | string | null
    pdfKeyCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    results?: LabResultUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabCreateOrConnectWithoutClinicInput = {
    where: LabWhereUniqueInput
    create: XOR<LabCreateWithoutClinicInput, LabUncheckedCreateWithoutClinicInput>
  }

  export type LabCreateManyClinicInputEnvelope = {
    data: LabCreateManyClinicInput | LabCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutClinicInput = {
    id?: string
    prescriptionNo?: number | null
    status?: $Enums.PrescriptionStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    patient?: PatientCreateNestedOneWithoutPrescriptionsInput
    doctor?: DoctorCreateNestedOneWithoutPrescriptionsInput
    medicines?: PrescriptionMedicineCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutClinicInput = {
    id?: string
    patientId?: string | null
    doctorId?: string | null
    prescriptionNo?: number | null
    status?: $Enums.PrescriptionStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    medicines?: PrescriptionMedicineUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutClinicInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutClinicInput, PrescriptionUncheckedCreateWithoutClinicInput>
  }

  export type PrescriptionCreateManyClinicInputEnvelope = {
    data: PrescriptionCreateManyClinicInput | PrescriptionCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutClinicInput = {
    id?: string
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    assignedDoctor?: DoctorCreateNestedOneWithoutAssignedTasksInput
    assignedAdmin?: AdminCreateNestedOneWithoutAssignedTasksInput
    patient?: PatientCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutClinicInput = {
    id?: string
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assigneeDoctorId?: string | null
    assigneeAdminId?: string | null
    patientId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type TaskCreateOrConnectWithoutClinicInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutClinicInput, TaskUncheckedCreateWithoutClinicInput>
  }

  export type TaskCreateManyClinicInputEnvelope = {
    data: TaskCreateManyClinicInput | TaskCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutClinicInput = {
    id?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    plan?: $Enums.Plan | null
    status?: $Enums.SubscriptionStatus | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubscriptionUncheckedCreateWithoutClinicInput = {
    id?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    plan?: $Enums.Plan | null
    status?: $Enums.SubscriptionStatus | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubscriptionCreateOrConnectWithoutClinicInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutClinicInput, SubscriptionUncheckedCreateWithoutClinicInput>
  }

  export type InvoiceCreateWithoutClinicInput = {
    id?: string
    stripeInvoiceId?: string | null
    invoiceNo?: string | null
    amountDue?: number | null
    amountPaid?: number | null
    currency?: string | null
    status?: string | null
    invoicePdfUrl?: string | null
    createdAt?: Date | string | null
  }

  export type InvoiceUncheckedCreateWithoutClinicInput = {
    id?: string
    stripeInvoiceId?: string | null
    invoiceNo?: string | null
    amountDue?: number | null
    amountPaid?: number | null
    currency?: string | null
    status?: string | null
    invoicePdfUrl?: string | null
    createdAt?: Date | string | null
  }

  export type InvoiceCreateOrConnectWithoutClinicInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutClinicInput, InvoiceUncheckedCreateWithoutClinicInput>
  }

  export type InvoiceCreateManyClinicInputEnvelope = {
    data: InvoiceCreateManyClinicInput | InvoiceCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type NotificationQueueCreateWithoutClinicInput = {
    id?: string
    type?: $Enums.NotificationType | null
    recipient?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.NotificationStatus | null
    sentAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type NotificationQueueUncheckedCreateWithoutClinicInput = {
    id?: string
    type?: $Enums.NotificationType | null
    recipient?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.NotificationStatus | null
    sentAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type NotificationQueueCreateOrConnectWithoutClinicInput = {
    where: NotificationQueueWhereUniqueInput
    create: XOR<NotificationQueueCreateWithoutClinicInput, NotificationQueueUncheckedCreateWithoutClinicInput>
  }

  export type NotificationQueueCreateManyClinicInputEnvelope = {
    data: NotificationQueueCreateManyClinicInput | NotificationQueueCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutClinicInput = {
    id?: string
    table?: string | null
    rowId?: string | null
    action?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    occurredAt?: Date | string | null
    admin?: AdminCreateNestedOneWithoutAuditLogsInput
    doctor?: DoctorCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutClinicInput = {
    id?: string
    table?: string | null
    rowId?: string | null
    action?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    adminId?: string | null
    doctorId?: string | null
    ip?: string | null
    userAgent?: string | null
    occurredAt?: Date | string | null
  }

  export type AuditLogCreateOrConnectWithoutClinicInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutClinicInput, AuditLogUncheckedCreateWithoutClinicInput>
  }

  export type AuditLogCreateManyClinicInputEnvelope = {
    data: AuditLogCreateManyClinicInput | AuditLogCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type DataRequestCreateWithoutClinicInput = {
    id?: string
    type?: $Enums.DataRequestType | null
    status?: $Enums.DataRequestStatus | null
    requestReason?: string | null
    requestedAt?: Date | string | null
    completedAt?: Date | string | null
    downloadUrl?: string | null
    downloadExpiresAt?: Date | string | null
    patient?: PatientCreateNestedOneWithoutDataRequestsInput
  }

  export type DataRequestUncheckedCreateWithoutClinicInput = {
    id?: string
    patientId?: string | null
    type?: $Enums.DataRequestType | null
    status?: $Enums.DataRequestStatus | null
    requestReason?: string | null
    requestedAt?: Date | string | null
    completedAt?: Date | string | null
    downloadUrl?: string | null
    downloadExpiresAt?: Date | string | null
  }

  export type DataRequestCreateOrConnectWithoutClinicInput = {
    where: DataRequestWhereUniqueInput
    create: XOR<DataRequestCreateWithoutClinicInput, DataRequestUncheckedCreateWithoutClinicInput>
  }

  export type DataRequestCreateManyClinicInputEnvelope = {
    data: DataRequestCreateManyClinicInput | DataRequestCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type ConsentVersionCreateWithoutClinicInput = {
    id?: string
    type?: $Enums.ConsentType | null
    version?: string | null
    title?: string | null
    body?: string | null
    effectiveDate?: Date | string | null
    createdAt?: Date | string | null
    patientConsents?: PatientConsentCreateNestedManyWithoutConsentVersionInput
  }

  export type ConsentVersionUncheckedCreateWithoutClinicInput = {
    id?: string
    type?: $Enums.ConsentType | null
    version?: string | null
    title?: string | null
    body?: string | null
    effectiveDate?: Date | string | null
    createdAt?: Date | string | null
    patientConsents?: PatientConsentUncheckedCreateNestedManyWithoutConsentVersionInput
  }

  export type ConsentVersionCreateOrConnectWithoutClinicInput = {
    where: ConsentVersionWhereUniqueInput
    create: XOR<ConsentVersionCreateWithoutClinicInput, ConsentVersionUncheckedCreateWithoutClinicInput>
  }

  export type ConsentVersionCreateManyClinicInputEnvelope = {
    data: ConsentVersionCreateManyClinicInput | ConsentVersionCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithWhereUniqueWithoutClinicInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutClinicInput, AdminUncheckedUpdateWithoutClinicInput>
    create: XOR<AdminCreateWithoutClinicInput, AdminUncheckedCreateWithoutClinicInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutClinicInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutClinicInput, AdminUncheckedUpdateWithoutClinicInput>
  }

  export type AdminUpdateManyWithWhereWithoutClinicInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutClinicInput>
  }

  export type AdminScalarWhereInput = {
    AND?: AdminScalarWhereInput | AdminScalarWhereInput[]
    OR?: AdminScalarWhereInput[]
    NOT?: AdminScalarWhereInput | AdminScalarWhereInput[]
    id?: UuidFilter<"Admin"> | string
    clinicId?: UuidNullableFilter<"Admin"> | string | null
    email?: StringNullableFilter<"Admin"> | string | null
    passwordHash?: StringNullableFilter<"Admin"> | string | null
    firstName?: StringNullableFilter<"Admin"> | string | null
    lastName?: StringNullableFilter<"Admin"> | string | null
    otp?: StringNullableFilter<"Admin"> | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"Admin"> | string | null
    twoFactorEnabled?: BoolNullableFilter<"Admin"> | boolean | null
    lastLoginAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
  }

  export type DoctorUpsertWithWhereUniqueWithoutClinicInput = {
    where: DoctorWhereUniqueInput
    update: XOR<DoctorUpdateWithoutClinicInput, DoctorUncheckedUpdateWithoutClinicInput>
    create: XOR<DoctorCreateWithoutClinicInput, DoctorUncheckedCreateWithoutClinicInput>
  }

  export type DoctorUpdateWithWhereUniqueWithoutClinicInput = {
    where: DoctorWhereUniqueInput
    data: XOR<DoctorUpdateWithoutClinicInput, DoctorUncheckedUpdateWithoutClinicInput>
  }

  export type DoctorUpdateManyWithWhereWithoutClinicInput = {
    where: DoctorScalarWhereInput
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyWithoutClinicInput>
  }

  export type DoctorScalarWhereInput = {
    AND?: DoctorScalarWhereInput | DoctorScalarWhereInput[]
    OR?: DoctorScalarWhereInput[]
    NOT?: DoctorScalarWhereInput | DoctorScalarWhereInput[]
    id?: UuidFilter<"Doctor"> | string
    clinicId?: UuidNullableFilter<"Doctor"> | string | null
    email?: StringNullableFilter<"Doctor"> | string | null
    passwordHash?: StringNullableFilter<"Doctor"> | string | null
    firstName?: StringNullableFilter<"Doctor"> | string | null
    lastName?: StringNullableFilter<"Doctor"> | string | null
    otp?: StringNullableFilter<"Doctor"> | string | null
    licenceNo?: StringNullableFilter<"Doctor"> | string | null
    specialities?: StringNullableListFilter<"Doctor">
    emailVerifiedAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"Doctor"> | string | null
    twoFactorEnabled?: BoolNullableFilter<"Doctor"> | boolean | null
    lastLoginAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Doctor"> | Date | string | null
  }

  export type PatientUpsertWithWhereUniqueWithoutClinicInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutClinicInput, PatientUncheckedUpdateWithoutClinicInput>
    create: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutClinicInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutClinicInput, PatientUncheckedUpdateWithoutClinicInput>
  }

  export type PatientUpdateManyWithWhereWithoutClinicInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutClinicInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: UuidFilter<"Patient"> | string
    clinicId?: UuidNullableFilter<"Patient"> | string | null
    firstNameCipher?: StringNullableFilter<"Patient"> | string | null
    lastNameCipher?: StringNullableFilter<"Patient"> | string | null
    phoneCipher?: StringNullableFilter<"Patient"> | string | null
    emailCipher?: StringNullableFilter<"Patient"> | string | null
    insuranceIdCipher?: StringNullableFilter<"Patient"> | string | null
    addressCipher?: StringNullableFilter<"Patient"> | string | null
    emergencyContactCipher?: StringNullableFilter<"Patient"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Patient"> | Date | string | null
    gender?: EnumGenderNullableFilter<"Patient"> | $Enums.Gender | null
    bloodGroup?: StringNullableFilter<"Patient"> | string | null
    conditionName?: StringNullableFilter<"Patient"> | string | null
    diagnosedDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    severity?: StringNullableFilter<"Patient"> | string | null
    status?: StringNullableFilter<"Patient"> | string | null
    retentionExpiresAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    firstNameBlind?: StringNullableFilter<"Patient"> | string | null
    lastNameBlind?: StringNullableFilter<"Patient"> | string | null
    insuranceIdBlind?: StringNullableFilter<"Patient"> | string | null
  }

  export type AppointmentUpsertWithWhereUniqueWithoutClinicInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutClinicInput, AppointmentUncheckedUpdateWithoutClinicInput>
    create: XOR<AppointmentCreateWithoutClinicInput, AppointmentUncheckedCreateWithoutClinicInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutClinicInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutClinicInput, AppointmentUncheckedUpdateWithoutClinicInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutClinicInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutClinicInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: UuidFilter<"Appointment"> | string
    clinicId?: UuidNullableFilter<"Appointment"> | string | null
    patientId?: UuidNullableFilter<"Appointment"> | string | null
    doctorId?: UuidNullableFilter<"Appointment"> | string | null
    startAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    endAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    status?: EnumAppointmentStatusNullableFilter<"Appointment"> | $Enums.AppointmentStatus | null
    note?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
  }

  export type CallUpsertWithWhereUniqueWithoutClinicInput = {
    where: CallWhereUniqueInput
    update: XOR<CallUpdateWithoutClinicInput, CallUncheckedUpdateWithoutClinicInput>
    create: XOR<CallCreateWithoutClinicInput, CallUncheckedCreateWithoutClinicInput>
  }

  export type CallUpdateWithWhereUniqueWithoutClinicInput = {
    where: CallWhereUniqueInput
    data: XOR<CallUpdateWithoutClinicInput, CallUncheckedUpdateWithoutClinicInput>
  }

  export type CallUpdateManyWithWhereWithoutClinicInput = {
    where: CallScalarWhereInput
    data: XOR<CallUpdateManyMutationInput, CallUncheckedUpdateManyWithoutClinicInput>
  }

  export type CallScalarWhereInput = {
    AND?: CallScalarWhereInput | CallScalarWhereInput[]
    OR?: CallScalarWhereInput[]
    NOT?: CallScalarWhereInput | CallScalarWhereInput[]
    id?: UuidFilter<"Call"> | string
    clinicId?: UuidNullableFilter<"Call"> | string | null
    patientId?: UuidNullableFilter<"Call"> | string | null
    doctorId?: UuidNullableFilter<"Call"> | string | null
    startAt?: DateTimeNullableFilter<"Call"> | Date | string | null
    endAt?: DateTimeNullableFilter<"Call"> | Date | string | null
    durationSeconds?: IntNullableFilter<"Call"> | number | null
    status?: EnumCallStatusNullableFilter<"Call"> | $Enums.CallStatus | null
    recordingUrlCipher?: StringNullableFilter<"Call"> | string | null
    transcript?: StringNullableFilter<"Call"> | string | null
    aiSummary?: StringNullableFilter<"Call"> | string | null
    sentiment?: EnumSentimentNullableFilter<"Call"> | $Enums.Sentiment | null
    escalated?: BoolNullableFilter<"Call"> | boolean | null
    minutesUsed?: IntNullableFilter<"Call"> | number | null
    createdAt?: DateTimeNullableFilter<"Call"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Call"> | Date | string | null
    aiModelId?: UuidNullableFilter<"Call"> | string | null
    aiDecision?: StringNullableFilter<"Call"> | string | null
  }

  export type LabUpsertWithWhereUniqueWithoutClinicInput = {
    where: LabWhereUniqueInput
    update: XOR<LabUpdateWithoutClinicInput, LabUncheckedUpdateWithoutClinicInput>
    create: XOR<LabCreateWithoutClinicInput, LabUncheckedCreateWithoutClinicInput>
  }

  export type LabUpdateWithWhereUniqueWithoutClinicInput = {
    where: LabWhereUniqueInput
    data: XOR<LabUpdateWithoutClinicInput, LabUncheckedUpdateWithoutClinicInput>
  }

  export type LabUpdateManyWithWhereWithoutClinicInput = {
    where: LabScalarWhereInput
    data: XOR<LabUpdateManyMutationInput, LabUncheckedUpdateManyWithoutClinicInput>
  }

  export type LabScalarWhereInput = {
    AND?: LabScalarWhereInput | LabScalarWhereInput[]
    OR?: LabScalarWhereInput[]
    NOT?: LabScalarWhereInput | LabScalarWhereInput[]
    id?: UuidFilter<"Lab"> | string
    clinicId?: UuidNullableFilter<"Lab"> | string | null
    patientId?: UuidNullableFilter<"Lab"> | string | null
    testDate?: DateTimeNullableFilter<"Lab"> | Date | string | null
    pdfKeyCipher?: StringNullableFilter<"Lab"> | string | null
    createdAt?: DateTimeNullableFilter<"Lab"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Lab"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Lab"> | Date | string | null
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutClinicInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutClinicInput, PrescriptionUncheckedUpdateWithoutClinicInput>
    create: XOR<PrescriptionCreateWithoutClinicInput, PrescriptionUncheckedCreateWithoutClinicInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutClinicInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutClinicInput, PrescriptionUncheckedUpdateWithoutClinicInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutClinicInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutClinicInput>
  }

  export type PrescriptionScalarWhereInput = {
    AND?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    OR?: PrescriptionScalarWhereInput[]
    NOT?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    id?: UuidFilter<"Prescription"> | string
    clinicId?: UuidNullableFilter<"Prescription"> | string | null
    patientId?: UuidNullableFilter<"Prescription"> | string | null
    doctorId?: UuidNullableFilter<"Prescription"> | string | null
    prescriptionNo?: IntNullableFilter<"Prescription"> | number | null
    status?: EnumPrescriptionStatusNullableFilter<"Prescription"> | $Enums.PrescriptionStatus | null
    createdAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
  }

  export type TaskUpsertWithWhereUniqueWithoutClinicInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutClinicInput, TaskUncheckedUpdateWithoutClinicInput>
    create: XOR<TaskCreateWithoutClinicInput, TaskUncheckedCreateWithoutClinicInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutClinicInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutClinicInput, TaskUncheckedUpdateWithoutClinicInput>
  }

  export type TaskUpdateManyWithWhereWithoutClinicInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutClinicInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: UuidFilter<"Task"> | string
    clinicId?: UuidNullableFilter<"Task"> | string | null
    title?: StringNullableFilter<"Task"> | string | null
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusNullableFilter<"Task"> | $Enums.TaskStatus | null
    priority?: EnumPriorityNullableFilter<"Task"> | $Enums.Priority | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    assigneeDoctorId?: UuidNullableFilter<"Task"> | string | null
    assigneeAdminId?: UuidNullableFilter<"Task"> | string | null
    patientId?: UuidNullableFilter<"Task"> | string | null
    createdAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
  }

  export type SubscriptionUpsertWithoutClinicInput = {
    update: XOR<SubscriptionUpdateWithoutClinicInput, SubscriptionUncheckedUpdateWithoutClinicInput>
    create: XOR<SubscriptionCreateWithoutClinicInput, SubscriptionUncheckedCreateWithoutClinicInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutClinicInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutClinicInput, SubscriptionUncheckedUpdateWithoutClinicInput>
  }

  export type SubscriptionUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    status?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    status?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUpsertWithWhereUniqueWithoutClinicInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutClinicInput, InvoiceUncheckedUpdateWithoutClinicInput>
    create: XOR<InvoiceCreateWithoutClinicInput, InvoiceUncheckedCreateWithoutClinicInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutClinicInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutClinicInput, InvoiceUncheckedUpdateWithoutClinicInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutClinicInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutClinicInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    clinicId?: UuidNullableFilter<"Invoice"> | string | null
    stripeInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    invoiceNo?: StringNullableFilter<"Invoice"> | string | null
    amountDue?: IntNullableFilter<"Invoice"> | number | null
    amountPaid?: IntNullableFilter<"Invoice"> | number | null
    currency?: StringNullableFilter<"Invoice"> | string | null
    status?: StringNullableFilter<"Invoice"> | string | null
    invoicePdfUrl?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
  }

  export type NotificationQueueUpsertWithWhereUniqueWithoutClinicInput = {
    where: NotificationQueueWhereUniqueInput
    update: XOR<NotificationQueueUpdateWithoutClinicInput, NotificationQueueUncheckedUpdateWithoutClinicInput>
    create: XOR<NotificationQueueCreateWithoutClinicInput, NotificationQueueUncheckedCreateWithoutClinicInput>
  }

  export type NotificationQueueUpdateWithWhereUniqueWithoutClinicInput = {
    where: NotificationQueueWhereUniqueInput
    data: XOR<NotificationQueueUpdateWithoutClinicInput, NotificationQueueUncheckedUpdateWithoutClinicInput>
  }

  export type NotificationQueueUpdateManyWithWhereWithoutClinicInput = {
    where: NotificationQueueScalarWhereInput
    data: XOR<NotificationQueueUpdateManyMutationInput, NotificationQueueUncheckedUpdateManyWithoutClinicInput>
  }

  export type NotificationQueueScalarWhereInput = {
    AND?: NotificationQueueScalarWhereInput | NotificationQueueScalarWhereInput[]
    OR?: NotificationQueueScalarWhereInput[]
    NOT?: NotificationQueueScalarWhereInput | NotificationQueueScalarWhereInput[]
    id?: UuidFilter<"NotificationQueue"> | string
    clinicId?: UuidNullableFilter<"NotificationQueue"> | string | null
    type?: EnumNotificationTypeNullableFilter<"NotificationQueue"> | $Enums.NotificationType | null
    recipient?: StringNullableFilter<"NotificationQueue"> | string | null
    payload?: JsonNullableFilter<"NotificationQueue">
    status?: EnumNotificationStatusNullableFilter<"NotificationQueue"> | $Enums.NotificationStatus | null
    sentAt?: DateTimeNullableFilter<"NotificationQueue"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"NotificationQueue"> | Date | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutClinicInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutClinicInput, AuditLogUncheckedUpdateWithoutClinicInput>
    create: XOR<AuditLogCreateWithoutClinicInput, AuditLogUncheckedCreateWithoutClinicInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutClinicInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutClinicInput, AuditLogUncheckedUpdateWithoutClinicInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutClinicInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutClinicInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    table?: StringNullableFilter<"AuditLog"> | string | null
    rowId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    adminId?: UuidNullableFilter<"AuditLog"> | string | null
    doctorId?: UuidNullableFilter<"AuditLog"> | string | null
    clinicId?: UuidNullableFilter<"AuditLog"> | string | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    occurredAt?: DateTimeNullableFilter<"AuditLog"> | Date | string | null
  }

  export type DataRequestUpsertWithWhereUniqueWithoutClinicInput = {
    where: DataRequestWhereUniqueInput
    update: XOR<DataRequestUpdateWithoutClinicInput, DataRequestUncheckedUpdateWithoutClinicInput>
    create: XOR<DataRequestCreateWithoutClinicInput, DataRequestUncheckedCreateWithoutClinicInput>
  }

  export type DataRequestUpdateWithWhereUniqueWithoutClinicInput = {
    where: DataRequestWhereUniqueInput
    data: XOR<DataRequestUpdateWithoutClinicInput, DataRequestUncheckedUpdateWithoutClinicInput>
  }

  export type DataRequestUpdateManyWithWhereWithoutClinicInput = {
    where: DataRequestScalarWhereInput
    data: XOR<DataRequestUpdateManyMutationInput, DataRequestUncheckedUpdateManyWithoutClinicInput>
  }

  export type DataRequestScalarWhereInput = {
    AND?: DataRequestScalarWhereInput | DataRequestScalarWhereInput[]
    OR?: DataRequestScalarWhereInput[]
    NOT?: DataRequestScalarWhereInput | DataRequestScalarWhereInput[]
    id?: UuidFilter<"DataRequest"> | string
    clinicId?: UuidNullableFilter<"DataRequest"> | string | null
    patientId?: UuidNullableFilter<"DataRequest"> | string | null
    type?: EnumDataRequestTypeNullableFilter<"DataRequest"> | $Enums.DataRequestType | null
    status?: EnumDataRequestStatusNullableFilter<"DataRequest"> | $Enums.DataRequestStatus | null
    requestReason?: StringNullableFilter<"DataRequest"> | string | null
    requestedAt?: DateTimeNullableFilter<"DataRequest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DataRequest"> | Date | string | null
    downloadUrl?: StringNullableFilter<"DataRequest"> | string | null
    downloadExpiresAt?: DateTimeNullableFilter<"DataRequest"> | Date | string | null
  }

  export type ConsentVersionUpsertWithWhereUniqueWithoutClinicInput = {
    where: ConsentVersionWhereUniqueInput
    update: XOR<ConsentVersionUpdateWithoutClinicInput, ConsentVersionUncheckedUpdateWithoutClinicInput>
    create: XOR<ConsentVersionCreateWithoutClinicInput, ConsentVersionUncheckedCreateWithoutClinicInput>
  }

  export type ConsentVersionUpdateWithWhereUniqueWithoutClinicInput = {
    where: ConsentVersionWhereUniqueInput
    data: XOR<ConsentVersionUpdateWithoutClinicInput, ConsentVersionUncheckedUpdateWithoutClinicInput>
  }

  export type ConsentVersionUpdateManyWithWhereWithoutClinicInput = {
    where: ConsentVersionScalarWhereInput
    data: XOR<ConsentVersionUpdateManyMutationInput, ConsentVersionUncheckedUpdateManyWithoutClinicInput>
  }

  export type ConsentVersionScalarWhereInput = {
    AND?: ConsentVersionScalarWhereInput | ConsentVersionScalarWhereInput[]
    OR?: ConsentVersionScalarWhereInput[]
    NOT?: ConsentVersionScalarWhereInput | ConsentVersionScalarWhereInput[]
    id?: UuidFilter<"ConsentVersion"> | string
    clinicId?: UuidNullableFilter<"ConsentVersion"> | string | null
    type?: EnumConsentTypeNullableFilter<"ConsentVersion"> | $Enums.ConsentType | null
    version?: StringNullableFilter<"ConsentVersion"> | string | null
    title?: StringNullableFilter<"ConsentVersion"> | string | null
    body?: StringNullableFilter<"ConsentVersion"> | string | null
    effectiveDate?: DateTimeNullableFilter<"ConsentVersion"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"ConsentVersion"> | Date | string | null
  }

  export type ClinicCreateWithoutConsentVersionsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminCreateNestedManyWithoutClinicInput
    doctors?: DoctorCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    calls?: CallCreateNestedManyWithoutClinicInput
    labs?: LabCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionCreateNestedManyWithoutClinicInput
    tasks?: TaskCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    invoices?: InvoiceCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutConsentVersionsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutClinicInput
    doctors?: DoctorUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    calls?: CallUncheckedCreateNestedManyWithoutClinicInput
    labs?: LabUncheckedCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutClinicInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutConsentVersionsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutConsentVersionsInput, ClinicUncheckedCreateWithoutConsentVersionsInput>
  }

  export type PatientConsentCreateWithoutConsentVersionInput = {
    id?: string
    type?: $Enums.ConsentType | null
    given?: boolean | null
    givenAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    patient?: PatientCreateNestedOneWithoutConsentsInput
  }

  export type PatientConsentUncheckedCreateWithoutConsentVersionInput = {
    id?: string
    patientId?: string | null
    type?: $Enums.ConsentType | null
    given?: boolean | null
    givenAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PatientConsentCreateOrConnectWithoutConsentVersionInput = {
    where: PatientConsentWhereUniqueInput
    create: XOR<PatientConsentCreateWithoutConsentVersionInput, PatientConsentUncheckedCreateWithoutConsentVersionInput>
  }

  export type PatientConsentCreateManyConsentVersionInputEnvelope = {
    data: PatientConsentCreateManyConsentVersionInput | PatientConsentCreateManyConsentVersionInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutConsentVersionsInput = {
    update: XOR<ClinicUpdateWithoutConsentVersionsInput, ClinicUncheckedUpdateWithoutConsentVersionsInput>
    create: XOR<ClinicCreateWithoutConsentVersionsInput, ClinicUncheckedCreateWithoutConsentVersionsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutConsentVersionsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutConsentVersionsInput, ClinicUncheckedUpdateWithoutConsentVersionsInput>
  }

  export type ClinicUpdateWithoutConsentVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    calls?: CallUpdateManyWithoutClinicNestedInput
    labs?: LabUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutClinicNestedInput
    tasks?: TaskUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutConsentVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    calls?: CallUncheckedUpdateManyWithoutClinicNestedInput
    labs?: LabUncheckedUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutClinicNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type PatientConsentUpsertWithWhereUniqueWithoutConsentVersionInput = {
    where: PatientConsentWhereUniqueInput
    update: XOR<PatientConsentUpdateWithoutConsentVersionInput, PatientConsentUncheckedUpdateWithoutConsentVersionInput>
    create: XOR<PatientConsentCreateWithoutConsentVersionInput, PatientConsentUncheckedCreateWithoutConsentVersionInput>
  }

  export type PatientConsentUpdateWithWhereUniqueWithoutConsentVersionInput = {
    where: PatientConsentWhereUniqueInput
    data: XOR<PatientConsentUpdateWithoutConsentVersionInput, PatientConsentUncheckedUpdateWithoutConsentVersionInput>
  }

  export type PatientConsentUpdateManyWithWhereWithoutConsentVersionInput = {
    where: PatientConsentScalarWhereInput
    data: XOR<PatientConsentUpdateManyMutationInput, PatientConsentUncheckedUpdateManyWithoutConsentVersionInput>
  }

  export type PatientConsentScalarWhereInput = {
    AND?: PatientConsentScalarWhereInput | PatientConsentScalarWhereInput[]
    OR?: PatientConsentScalarWhereInput[]
    NOT?: PatientConsentScalarWhereInput | PatientConsentScalarWhereInput[]
    id?: UuidFilter<"PatientConsent"> | string
    patientId?: UuidNullableFilter<"PatientConsent"> | string | null
    consentVersionId?: UuidNullableFilter<"PatientConsent"> | string | null
    type?: EnumConsentTypeNullableFilter<"PatientConsent"> | $Enums.ConsentType | null
    given?: BoolNullableFilter<"PatientConsent"> | boolean | null
    givenAt?: DateTimeNullableFilter<"PatientConsent"> | Date | string | null
    withdrawnAt?: DateTimeNullableFilter<"PatientConsent"> | Date | string | null
    ip?: StringNullableFilter<"PatientConsent"> | string | null
    userAgent?: StringNullableFilter<"PatientConsent"> | string | null
    createdAt?: DateTimeNullableFilter<"PatientConsent"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"PatientConsent"> | Date | string | null
  }

  export type PatientCreateWithoutConsentsInput = {
    id?: string
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    clinic?: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    calls?: CallCreateNestedManyWithoutPatientInput
    labs?: LabCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    tasks?: TaskCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutConsentsInput = {
    id?: string
    clinicId?: string | null
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    calls?: CallUncheckedCreateNestedManyWithoutPatientInput
    labs?: LabUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutConsentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutConsentsInput, PatientUncheckedCreateWithoutConsentsInput>
  }

  export type ConsentVersionCreateWithoutPatientConsentsInput = {
    id?: string
    type?: $Enums.ConsentType | null
    version?: string | null
    title?: string | null
    body?: string | null
    effectiveDate?: Date | string | null
    createdAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutConsentVersionsInput
  }

  export type ConsentVersionUncheckedCreateWithoutPatientConsentsInput = {
    id?: string
    clinicId?: string | null
    type?: $Enums.ConsentType | null
    version?: string | null
    title?: string | null
    body?: string | null
    effectiveDate?: Date | string | null
    createdAt?: Date | string | null
  }

  export type ConsentVersionCreateOrConnectWithoutPatientConsentsInput = {
    where: ConsentVersionWhereUniqueInput
    create: XOR<ConsentVersionCreateWithoutPatientConsentsInput, ConsentVersionUncheckedCreateWithoutPatientConsentsInput>
  }

  export type PatientUpsertWithoutConsentsInput = {
    update: XOR<PatientUpdateWithoutConsentsInput, PatientUncheckedUpdateWithoutConsentsInput>
    create: XOR<PatientCreateWithoutConsentsInput, PatientUncheckedCreateWithoutConsentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutConsentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutConsentsInput, PatientUncheckedUpdateWithoutConsentsInput>
  }

  export type PatientUpdateWithoutConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClinicUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    calls?: CallUpdateManyWithoutPatientNestedInput
    labs?: LabUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    tasks?: TaskUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    calls?: CallUncheckedUpdateManyWithoutPatientNestedInput
    labs?: LabUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ConsentVersionUpsertWithoutPatientConsentsInput = {
    update: XOR<ConsentVersionUpdateWithoutPatientConsentsInput, ConsentVersionUncheckedUpdateWithoutPatientConsentsInput>
    create: XOR<ConsentVersionCreateWithoutPatientConsentsInput, ConsentVersionUncheckedCreateWithoutPatientConsentsInput>
    where?: ConsentVersionWhereInput
  }

  export type ConsentVersionUpdateToOneWithWhereWithoutPatientConsentsInput = {
    where?: ConsentVersionWhereInput
    data: XOR<ConsentVersionUpdateWithoutPatientConsentsInput, ConsentVersionUncheckedUpdateWithoutPatientConsentsInput>
  }

  export type ConsentVersionUpdateWithoutPatientConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutConsentVersionsNestedInput
  }

  export type ConsentVersionUncheckedUpdateWithoutPatientConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClinicCreateWithoutAuditLogsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminCreateNestedManyWithoutClinicInput
    doctors?: DoctorCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    calls?: CallCreateNestedManyWithoutClinicInput
    labs?: LabCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionCreateNestedManyWithoutClinicInput
    tasks?: TaskCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    invoices?: InvoiceCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutClinicInput
    doctors?: DoctorUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    calls?: CallUncheckedCreateNestedManyWithoutClinicInput
    labs?: LabUncheckedCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutClinicInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueUncheckedCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutAuditLogsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutAuditLogsInput, ClinicUncheckedCreateWithoutAuditLogsInput>
  }

  export type AdminCreateWithoutAuditLogsInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutAdminsInput
    sessions?: SessionCreateNestedManyWithoutAdminInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedAdminInput
  }

  export type AdminUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutAdminInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedAdminInput
  }

  export type AdminCreateOrConnectWithoutAuditLogsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAuditLogsInput, AdminUncheckedCreateWithoutAuditLogsInput>
  }

  export type DoctorCreateWithoutAuditLogsInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutDoctorsInput
    sessions?: SessionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    calls?: CallCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedDoctorInput
    staffPersonalInfo?: StaffPersonalInfoCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoCreateNestedManyWithoutReportingToInput
  }

  export type DoctorUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    calls?: CallUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedDoctorInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoUncheckedCreateNestedManyWithoutReportingToInput
  }

  export type DoctorCreateOrConnectWithoutAuditLogsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutAuditLogsInput, DoctorUncheckedCreateWithoutAuditLogsInput>
  }

  export type ClinicUpsertWithoutAuditLogsInput = {
    update: XOR<ClinicUpdateWithoutAuditLogsInput, ClinicUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<ClinicCreateWithoutAuditLogsInput, ClinicUncheckedCreateWithoutAuditLogsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutAuditLogsInput, ClinicUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ClinicUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    calls?: CallUpdateManyWithoutClinicNestedInput
    labs?: LabUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutClinicNestedInput
    tasks?: TaskUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    calls?: CallUncheckedUpdateManyWithoutClinicNestedInput
    labs?: LabUncheckedUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutClinicNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type AdminUpsertWithoutAuditLogsInput = {
    update: XOR<AdminUpdateWithoutAuditLogsInput, AdminUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<AdminCreateWithoutAuditLogsInput, AdminUncheckedCreateWithoutAuditLogsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAuditLogsInput, AdminUncheckedUpdateWithoutAuditLogsInput>
  }

  export type AdminUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutAdminsNestedInput
    sessions?: SessionUpdateManyWithoutAdminNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutAdminNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedAdminNestedInput
  }

  export type DoctorUpsertWithoutAuditLogsInput = {
    update: XOR<DoctorUpdateWithoutAuditLogsInput, DoctorUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<DoctorCreateWithoutAuditLogsInput, DoctorUncheckedCreateWithoutAuditLogsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutAuditLogsInput, DoctorUncheckedUpdateWithoutAuditLogsInput>
  }

  export type DoctorUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutDoctorsNestedInput
    sessions?: SessionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    calls?: CallUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    calls?: CallUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUncheckedUpdateManyWithoutReportingToNestedInput
  }

  export type ClinicCreateWithoutDataRequestsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminCreateNestedManyWithoutClinicInput
    doctors?: DoctorCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    calls?: CallCreateNestedManyWithoutClinicInput
    labs?: LabCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionCreateNestedManyWithoutClinicInput
    tasks?: TaskCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    invoices?: InvoiceCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutDataRequestsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutClinicInput
    doctors?: DoctorUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    calls?: CallUncheckedCreateNestedManyWithoutClinicInput
    labs?: LabUncheckedCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutClinicInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutDataRequestsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutDataRequestsInput, ClinicUncheckedCreateWithoutDataRequestsInput>
  }

  export type PatientCreateWithoutDataRequestsInput = {
    id?: string
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    clinic?: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    calls?: CallCreateNestedManyWithoutPatientInput
    labs?: LabCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    tasks?: TaskCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisCreateNestedManyWithoutPatientInput
    consents?: PatientConsentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutDataRequestsInput = {
    id?: string
    clinicId?: string | null
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    calls?: CallUncheckedCreateNestedManyWithoutPatientInput
    labs?: LabUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    consents?: PatientConsentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutDataRequestsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutDataRequestsInput, PatientUncheckedCreateWithoutDataRequestsInput>
  }

  export type ClinicUpsertWithoutDataRequestsInput = {
    update: XOR<ClinicUpdateWithoutDataRequestsInput, ClinicUncheckedUpdateWithoutDataRequestsInput>
    create: XOR<ClinicCreateWithoutDataRequestsInput, ClinicUncheckedCreateWithoutDataRequestsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutDataRequestsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutDataRequestsInput, ClinicUncheckedUpdateWithoutDataRequestsInput>
  }

  export type ClinicUpdateWithoutDataRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    calls?: CallUpdateManyWithoutClinicNestedInput
    labs?: LabUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutClinicNestedInput
    tasks?: TaskUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutDataRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    calls?: CallUncheckedUpdateManyWithoutClinicNestedInput
    labs?: LabUncheckedUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutClinicNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type PatientUpsertWithoutDataRequestsInput = {
    update: XOR<PatientUpdateWithoutDataRequestsInput, PatientUncheckedUpdateWithoutDataRequestsInput>
    create: XOR<PatientCreateWithoutDataRequestsInput, PatientUncheckedCreateWithoutDataRequestsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutDataRequestsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutDataRequestsInput, PatientUncheckedUpdateWithoutDataRequestsInput>
  }

  export type PatientUpdateWithoutDataRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClinicUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    calls?: CallUpdateManyWithoutPatientNestedInput
    labs?: LabUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    tasks?: TaskUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutDataRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    calls?: CallUncheckedUpdateManyWithoutPatientNestedInput
    labs?: LabUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ClinicCreateWithoutAppointmentsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminCreateNestedManyWithoutClinicInput
    doctors?: DoctorCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    calls?: CallCreateNestedManyWithoutClinicInput
    labs?: LabCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionCreateNestedManyWithoutClinicInput
    tasks?: TaskCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    invoices?: InvoiceCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutClinicInput
    doctors?: DoctorUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    calls?: CallUncheckedCreateNestedManyWithoutClinicInput
    labs?: LabUncheckedCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutClinicInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutAppointmentsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutAppointmentsInput, ClinicUncheckedCreateWithoutAppointmentsInput>
  }

  export type PatientCreateWithoutAppointmentsInput = {
    id?: string
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    clinic?: ClinicCreateNestedOneWithoutPatientsInput
    calls?: CallCreateNestedManyWithoutPatientInput
    labs?: LabCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    tasks?: TaskCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisCreateNestedManyWithoutPatientInput
    consents?: PatientConsentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    clinicId?: string | null
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    calls?: CallUncheckedCreateNestedManyWithoutPatientInput
    labs?: LabUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    consents?: PatientConsentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAppointmentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
  }

  export type DoctorCreateWithoutAppointmentsInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutDoctorsInput
    sessions?: SessionCreateNestedManyWithoutDoctorInput
    calls?: CallCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoCreateNestedManyWithoutReportingToInput
  }

  export type DoctorUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutDoctorInput
    calls?: CallUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoUncheckedCreateNestedManyWithoutReportingToInput
  }

  export type DoctorCreateOrConnectWithoutAppointmentsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
  }

  export type ClinicUpsertWithoutAppointmentsInput = {
    update: XOR<ClinicUpdateWithoutAppointmentsInput, ClinicUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ClinicCreateWithoutAppointmentsInput, ClinicUncheckedCreateWithoutAppointmentsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutAppointmentsInput, ClinicUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ClinicUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    calls?: CallUpdateManyWithoutClinicNestedInput
    labs?: LabUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutClinicNestedInput
    tasks?: TaskUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    calls?: CallUncheckedUpdateManyWithoutClinicNestedInput
    labs?: LabUncheckedUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutClinicNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type PatientUpsertWithoutAppointmentsInput = {
    update: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClinicUpdateOneWithoutPatientsNestedInput
    calls?: CallUpdateManyWithoutPatientNestedInput
    labs?: LabUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    tasks?: TaskUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    calls?: CallUncheckedUpdateManyWithoutPatientNestedInput
    labs?: LabUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorUpsertWithoutAppointmentsInput = {
    update: XOR<DoctorUpdateWithoutAppointmentsInput, DoctorUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutAppointmentsInput, DoctorUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DoctorUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutDoctorsNestedInput
    sessions?: SessionUpdateManyWithoutDoctorNestedInput
    calls?: CallUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutDoctorNestedInput
    calls?: CallUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUncheckedUpdateManyWithoutReportingToNestedInput
  }

  export type ClinicCreateWithoutCallsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminCreateNestedManyWithoutClinicInput
    doctors?: DoctorCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    labs?: LabCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionCreateNestedManyWithoutClinicInput
    tasks?: TaskCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    invoices?: InvoiceCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutCallsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutClinicInput
    doctors?: DoctorUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    labs?: LabUncheckedCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutClinicInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutCallsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutCallsInput, ClinicUncheckedCreateWithoutCallsInput>
  }

  export type PatientCreateWithoutCallsInput = {
    id?: string
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    clinic?: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    labs?: LabCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    tasks?: TaskCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisCreateNestedManyWithoutPatientInput
    consents?: PatientConsentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutCallsInput = {
    id?: string
    clinicId?: string | null
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    labs?: LabUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    consents?: PatientConsentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutCallsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutCallsInput, PatientUncheckedCreateWithoutCallsInput>
  }

  export type DoctorCreateWithoutCallsInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutDoctorsInput
    sessions?: SessionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoCreateNestedManyWithoutReportingToInput
  }

  export type DoctorUncheckedCreateWithoutCallsInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoUncheckedCreateNestedManyWithoutReportingToInput
  }

  export type DoctorCreateOrConnectWithoutCallsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutCallsInput, DoctorUncheckedCreateWithoutCallsInput>
  }

  export type ClinicUpsertWithoutCallsInput = {
    update: XOR<ClinicUpdateWithoutCallsInput, ClinicUncheckedUpdateWithoutCallsInput>
    create: XOR<ClinicCreateWithoutCallsInput, ClinicUncheckedCreateWithoutCallsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutCallsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutCallsInput, ClinicUncheckedUpdateWithoutCallsInput>
  }

  export type ClinicUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    labs?: LabUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutClinicNestedInput
    tasks?: TaskUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    labs?: LabUncheckedUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutClinicNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type PatientUpsertWithoutCallsInput = {
    update: XOR<PatientUpdateWithoutCallsInput, PatientUncheckedUpdateWithoutCallsInput>
    create: XOR<PatientCreateWithoutCallsInput, PatientUncheckedCreateWithoutCallsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutCallsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutCallsInput, PatientUncheckedUpdateWithoutCallsInput>
  }

  export type PatientUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClinicUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    labs?: LabUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    tasks?: TaskUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    labs?: LabUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorUpsertWithoutCallsInput = {
    update: XOR<DoctorUpdateWithoutCallsInput, DoctorUncheckedUpdateWithoutCallsInput>
    create: XOR<DoctorCreateWithoutCallsInput, DoctorUncheckedCreateWithoutCallsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutCallsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutCallsInput, DoctorUncheckedUpdateWithoutCallsInput>
  }

  export type DoctorUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutDoctorsNestedInput
    sessions?: SessionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorUncheckedUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUncheckedUpdateManyWithoutReportingToNestedInput
  }

  export type PatientCreateWithoutDiagnosesInput = {
    id?: string
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    clinic?: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    calls?: CallCreateNestedManyWithoutPatientInput
    labs?: LabCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    tasks?: TaskCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutPatientInput
    consents?: PatientConsentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutDiagnosesInput = {
    id?: string
    clinicId?: string | null
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    calls?: CallUncheckedCreateNestedManyWithoutPatientInput
    labs?: LabUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutPatientInput
    consents?: PatientConsentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutDiagnosesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutDiagnosesInput, PatientUncheckedCreateWithoutDiagnosesInput>
  }

  export type DoctorCreateWithoutDiagnosesInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutDoctorsInput
    sessions?: SessionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    calls?: CallCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoCreateNestedManyWithoutReportingToInput
  }

  export type DoctorUncheckedCreateWithoutDiagnosesInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    calls?: CallUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoUncheckedCreateNestedManyWithoutReportingToInput
  }

  export type DoctorCreateOrConnectWithoutDiagnosesInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutDiagnosesInput, DoctorUncheckedCreateWithoutDiagnosesInput>
  }

  export type PatientUpsertWithoutDiagnosesInput = {
    update: XOR<PatientUpdateWithoutDiagnosesInput, PatientUncheckedUpdateWithoutDiagnosesInput>
    create: XOR<PatientCreateWithoutDiagnosesInput, PatientUncheckedCreateWithoutDiagnosesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutDiagnosesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutDiagnosesInput, PatientUncheckedUpdateWithoutDiagnosesInput>
  }

  export type PatientUpdateWithoutDiagnosesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClinicUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    calls?: CallUpdateManyWithoutPatientNestedInput
    labs?: LabUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    tasks?: TaskUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutDiagnosesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    calls?: CallUncheckedUpdateManyWithoutPatientNestedInput
    labs?: LabUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorUpsertWithoutDiagnosesInput = {
    update: XOR<DoctorUpdateWithoutDiagnosesInput, DoctorUncheckedUpdateWithoutDiagnosesInput>
    create: XOR<DoctorCreateWithoutDiagnosesInput, DoctorUncheckedCreateWithoutDiagnosesInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutDiagnosesInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutDiagnosesInput, DoctorUncheckedUpdateWithoutDiagnosesInput>
  }

  export type DoctorUpdateWithoutDiagnosesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutDoctorsNestedInput
    sessions?: SessionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    calls?: CallUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorUncheckedUpdateWithoutDiagnosesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    calls?: CallUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUncheckedUpdateManyWithoutReportingToNestedInput
  }

  export type ClinicCreateWithoutLabsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminCreateNestedManyWithoutClinicInput
    doctors?: DoctorCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    calls?: CallCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionCreateNestedManyWithoutClinicInput
    tasks?: TaskCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    invoices?: InvoiceCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutLabsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutClinicInput
    doctors?: DoctorUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    calls?: CallUncheckedCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutClinicInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutLabsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutLabsInput, ClinicUncheckedCreateWithoutLabsInput>
  }

  export type PatientCreateWithoutLabsInput = {
    id?: string
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    clinic?: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    calls?: CallCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    tasks?: TaskCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisCreateNestedManyWithoutPatientInput
    consents?: PatientConsentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutLabsInput = {
    id?: string
    clinicId?: string | null
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    calls?: CallUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    consents?: PatientConsentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutLabsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutLabsInput, PatientUncheckedCreateWithoutLabsInput>
  }

  export type LabResultCreateWithoutLabInput = {
    id?: string
    testName?: string | null
    result?: string | null
    unit?: string | null
    normalMin?: number | null
    normalMax?: number | null
    flag?: $Enums.Flag | null
  }

  export type LabResultUncheckedCreateWithoutLabInput = {
    id?: string
    testName?: string | null
    result?: string | null
    unit?: string | null
    normalMin?: number | null
    normalMax?: number | null
    flag?: $Enums.Flag | null
  }

  export type LabResultCreateOrConnectWithoutLabInput = {
    where: LabResultWhereUniqueInput
    create: XOR<LabResultCreateWithoutLabInput, LabResultUncheckedCreateWithoutLabInput>
  }

  export type LabResultCreateManyLabInputEnvelope = {
    data: LabResultCreateManyLabInput | LabResultCreateManyLabInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutLabsInput = {
    update: XOR<ClinicUpdateWithoutLabsInput, ClinicUncheckedUpdateWithoutLabsInput>
    create: XOR<ClinicCreateWithoutLabsInput, ClinicUncheckedCreateWithoutLabsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutLabsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutLabsInput, ClinicUncheckedUpdateWithoutLabsInput>
  }

  export type ClinicUpdateWithoutLabsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    calls?: CallUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutClinicNestedInput
    tasks?: TaskUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutLabsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    calls?: CallUncheckedUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutClinicNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type PatientUpsertWithoutLabsInput = {
    update: XOR<PatientUpdateWithoutLabsInput, PatientUncheckedUpdateWithoutLabsInput>
    create: XOR<PatientCreateWithoutLabsInput, PatientUncheckedCreateWithoutLabsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutLabsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutLabsInput, PatientUncheckedUpdateWithoutLabsInput>
  }

  export type PatientUpdateWithoutLabsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClinicUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    calls?: CallUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    tasks?: TaskUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutLabsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    calls?: CallUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type LabResultUpsertWithWhereUniqueWithoutLabInput = {
    where: LabResultWhereUniqueInput
    update: XOR<LabResultUpdateWithoutLabInput, LabResultUncheckedUpdateWithoutLabInput>
    create: XOR<LabResultCreateWithoutLabInput, LabResultUncheckedCreateWithoutLabInput>
  }

  export type LabResultUpdateWithWhereUniqueWithoutLabInput = {
    where: LabResultWhereUniqueInput
    data: XOR<LabResultUpdateWithoutLabInput, LabResultUncheckedUpdateWithoutLabInput>
  }

  export type LabResultUpdateManyWithWhereWithoutLabInput = {
    where: LabResultScalarWhereInput
    data: XOR<LabResultUpdateManyMutationInput, LabResultUncheckedUpdateManyWithoutLabInput>
  }

  export type LabResultScalarWhereInput = {
    AND?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
    OR?: LabResultScalarWhereInput[]
    NOT?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
    id?: UuidFilter<"LabResult"> | string
    labId?: UuidNullableFilter<"LabResult"> | string | null
    testName?: StringNullableFilter<"LabResult"> | string | null
    result?: StringNullableFilter<"LabResult"> | string | null
    unit?: StringNullableFilter<"LabResult"> | string | null
    normalMin?: FloatNullableFilter<"LabResult"> | number | null
    normalMax?: FloatNullableFilter<"LabResult"> | number | null
    flag?: EnumFlagNullableFilter<"LabResult"> | $Enums.Flag | null
  }

  export type LabCreateWithoutResultsInput = {
    id?: string
    testDate?: Date | string | null
    pdfKeyCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutLabsInput
    patient?: PatientCreateNestedOneWithoutLabsInput
  }

  export type LabUncheckedCreateWithoutResultsInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    testDate?: Date | string | null
    pdfKeyCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LabCreateOrConnectWithoutResultsInput = {
    where: LabWhereUniqueInput
    create: XOR<LabCreateWithoutResultsInput, LabUncheckedCreateWithoutResultsInput>
  }

  export type LabUpsertWithoutResultsInput = {
    update: XOR<LabUpdateWithoutResultsInput, LabUncheckedUpdateWithoutResultsInput>
    create: XOR<LabCreateWithoutResultsInput, LabUncheckedCreateWithoutResultsInput>
    where?: LabWhereInput
  }

  export type LabUpdateToOneWithWhereWithoutResultsInput = {
    where?: LabWhereInput
    data: XOR<LabUpdateWithoutResultsInput, LabUncheckedUpdateWithoutResultsInput>
  }

  export type LabUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    testDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfKeyCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutLabsNestedInput
    patient?: PatientUpdateOneWithoutLabsNestedInput
  }

  export type LabUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    testDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfKeyCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClinicCreateWithoutPrescriptionsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminCreateNestedManyWithoutClinicInput
    doctors?: DoctorCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    calls?: CallCreateNestedManyWithoutClinicInput
    labs?: LabCreateNestedManyWithoutClinicInput
    tasks?: TaskCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    invoices?: InvoiceCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutClinicInput
    doctors?: DoctorUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    calls?: CallUncheckedCreateNestedManyWithoutClinicInput
    labs?: LabUncheckedCreateNestedManyWithoutClinicInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutPrescriptionsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutPrescriptionsInput, ClinicUncheckedCreateWithoutPrescriptionsInput>
  }

  export type PatientCreateWithoutPrescriptionsInput = {
    id?: string
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    clinic?: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    calls?: CallCreateNestedManyWithoutPatientInput
    labs?: LabCreateNestedManyWithoutPatientInput
    tasks?: TaskCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisCreateNestedManyWithoutPatientInput
    consents?: PatientConsentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    clinicId?: string | null
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    calls?: CallUncheckedCreateNestedManyWithoutPatientInput
    labs?: LabUncheckedCreateNestedManyWithoutPatientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    consents?: PatientConsentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPrescriptionsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
  }

  export type DoctorCreateWithoutPrescriptionsInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutDoctorsInput
    sessions?: SessionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    calls?: CallCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoCreateNestedManyWithoutReportingToInput
  }

  export type DoctorUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    calls?: CallUncheckedCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoUncheckedCreateNestedManyWithoutReportingToInput
  }

  export type DoctorCreateOrConnectWithoutPrescriptionsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutPrescriptionsInput, DoctorUncheckedCreateWithoutPrescriptionsInput>
  }

  export type PrescriptionMedicineCreateWithoutPrescriptionInput = {
    id?: string
    medicine?: string | null
    strength?: string | null
    dose?: string | null
    frequency?: string | null
    route?: string | null
    duration?: string | null
    refill?: number | null
  }

  export type PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput = {
    id?: string
    medicine?: string | null
    strength?: string | null
    dose?: string | null
    frequency?: string | null
    route?: string | null
    duration?: string | null
    refill?: number | null
  }

  export type PrescriptionMedicineCreateOrConnectWithoutPrescriptionInput = {
    where: PrescriptionMedicineWhereUniqueInput
    create: XOR<PrescriptionMedicineCreateWithoutPrescriptionInput, PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionMedicineCreateManyPrescriptionInputEnvelope = {
    data: PrescriptionMedicineCreateManyPrescriptionInput | PrescriptionMedicineCreateManyPrescriptionInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutPrescriptionsInput = {
    update: XOR<ClinicUpdateWithoutPrescriptionsInput, ClinicUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<ClinicCreateWithoutPrescriptionsInput, ClinicUncheckedCreateWithoutPrescriptionsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutPrescriptionsInput, ClinicUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type ClinicUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    calls?: CallUpdateManyWithoutClinicNestedInput
    labs?: LabUpdateManyWithoutClinicNestedInput
    tasks?: TaskUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    calls?: CallUncheckedUpdateManyWithoutClinicNestedInput
    labs?: LabUncheckedUpdateManyWithoutClinicNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type PatientUpsertWithoutPrescriptionsInput = {
    update: XOR<PatientUpdateWithoutPrescriptionsInput, PatientUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPrescriptionsInput, PatientUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PatientUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClinicUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    calls?: CallUpdateManyWithoutPatientNestedInput
    labs?: LabUpdateManyWithoutPatientNestedInput
    tasks?: TaskUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    calls?: CallUncheckedUpdateManyWithoutPatientNestedInput
    labs?: LabUncheckedUpdateManyWithoutPatientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorUpsertWithoutPrescriptionsInput = {
    update: XOR<DoctorUpdateWithoutPrescriptionsInput, DoctorUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<DoctorCreateWithoutPrescriptionsInput, DoctorUncheckedCreateWithoutPrescriptionsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutPrescriptionsInput, DoctorUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type DoctorUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutDoctorsNestedInput
    sessions?: SessionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    calls?: CallUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    calls?: CallUncheckedUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUncheckedUpdateManyWithoutReportingToNestedInput
  }

  export type PrescriptionMedicineUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionMedicineWhereUniqueInput
    update: XOR<PrescriptionMedicineUpdateWithoutPrescriptionInput, PrescriptionMedicineUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<PrescriptionMedicineCreateWithoutPrescriptionInput, PrescriptionMedicineUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionMedicineUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionMedicineWhereUniqueInput
    data: XOR<PrescriptionMedicineUpdateWithoutPrescriptionInput, PrescriptionMedicineUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PrescriptionMedicineUpdateManyWithWhereWithoutPrescriptionInput = {
    where: PrescriptionMedicineScalarWhereInput
    data: XOR<PrescriptionMedicineUpdateManyMutationInput, PrescriptionMedicineUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type PrescriptionMedicineScalarWhereInput = {
    AND?: PrescriptionMedicineScalarWhereInput | PrescriptionMedicineScalarWhereInput[]
    OR?: PrescriptionMedicineScalarWhereInput[]
    NOT?: PrescriptionMedicineScalarWhereInput | PrescriptionMedicineScalarWhereInput[]
    id?: UuidFilter<"PrescriptionMedicine"> | string
    prescriptionId?: UuidNullableFilter<"PrescriptionMedicine"> | string | null
    medicine?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    strength?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    dose?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    frequency?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    route?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    duration?: StringNullableFilter<"PrescriptionMedicine"> | string | null
    refill?: IntNullableFilter<"PrescriptionMedicine"> | number | null
  }

  export type PrescriptionCreateWithoutMedicinesInput = {
    id?: string
    prescriptionNo?: number | null
    status?: $Enums.PrescriptionStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutPrescriptionsInput
    patient?: PatientCreateNestedOneWithoutPrescriptionsInput
    doctor?: DoctorCreateNestedOneWithoutPrescriptionsInput
  }

  export type PrescriptionUncheckedCreateWithoutMedicinesInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    doctorId?: string | null
    prescriptionNo?: number | null
    status?: $Enums.PrescriptionStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type PrescriptionCreateOrConnectWithoutMedicinesInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutMedicinesInput, PrescriptionUncheckedCreateWithoutMedicinesInput>
  }

  export type PrescriptionUpsertWithoutMedicinesInput = {
    update: XOR<PrescriptionUpdateWithoutMedicinesInput, PrescriptionUncheckedUpdateWithoutMedicinesInput>
    create: XOR<PrescriptionCreateWithoutMedicinesInput, PrescriptionUncheckedCreateWithoutMedicinesInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutMedicinesInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutMedicinesInput, PrescriptionUncheckedUpdateWithoutMedicinesInput>
  }

  export type PrescriptionUpdateWithoutMedicinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutPrescriptionsNestedInput
    patient?: PatientUpdateOneWithoutPrescriptionsNestedInput
    doctor?: DoctorUpdateOneWithoutPrescriptionsNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutMedicinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClinicCreateWithoutPatientsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminCreateNestedManyWithoutClinicInput
    doctors?: DoctorCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    calls?: CallCreateNestedManyWithoutClinicInput
    labs?: LabCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionCreateNestedManyWithoutClinicInput
    tasks?: TaskCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    invoices?: InvoiceCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutPatientsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutClinicInput
    doctors?: DoctorUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    calls?: CallUncheckedCreateNestedManyWithoutClinicInput
    labs?: LabUncheckedCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutClinicInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutPatientsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutPatientsInput, ClinicUncheckedCreateWithoutPatientsInput>
  }

  export type AppointmentCreateWithoutPatientInput = {
    id?: string
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.AppointmentStatus | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutAppointmentsInput
    doctor?: DoctorCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: string
    clinicId?: string | null
    doctorId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.AppointmentStatus | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: AppointmentCreateManyPatientInput | AppointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type CallCreateWithoutPatientInput = {
    id?: string
    startAt?: Date | string | null
    endAt?: Date | string | null
    durationSeconds?: number | null
    status?: $Enums.CallStatus | null
    recordingUrlCipher?: string | null
    transcript?: string | null
    aiSummary?: string | null
    sentiment?: $Enums.Sentiment | null
    escalated?: boolean | null
    minutesUsed?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    aiModelId?: string | null
    aiDecision?: string | null
    clinic?: ClinicCreateNestedOneWithoutCallsInput
    doctor?: DoctorCreateNestedOneWithoutCallsInput
  }

  export type CallUncheckedCreateWithoutPatientInput = {
    id?: string
    clinicId?: string | null
    doctorId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    durationSeconds?: number | null
    status?: $Enums.CallStatus | null
    recordingUrlCipher?: string | null
    transcript?: string | null
    aiSummary?: string | null
    sentiment?: $Enums.Sentiment | null
    escalated?: boolean | null
    minutesUsed?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    aiModelId?: string | null
    aiDecision?: string | null
  }

  export type CallCreateOrConnectWithoutPatientInput = {
    where: CallWhereUniqueInput
    create: XOR<CallCreateWithoutPatientInput, CallUncheckedCreateWithoutPatientInput>
  }

  export type CallCreateManyPatientInputEnvelope = {
    data: CallCreateManyPatientInput | CallCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type LabCreateWithoutPatientInput = {
    id?: string
    testDate?: Date | string | null
    pdfKeyCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutLabsInput
    results?: LabResultCreateNestedManyWithoutLabInput
  }

  export type LabUncheckedCreateWithoutPatientInput = {
    id?: string
    clinicId?: string | null
    testDate?: Date | string | null
    pdfKeyCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    results?: LabResultUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabCreateOrConnectWithoutPatientInput = {
    where: LabWhereUniqueInput
    create: XOR<LabCreateWithoutPatientInput, LabUncheckedCreateWithoutPatientInput>
  }

  export type LabCreateManyPatientInputEnvelope = {
    data: LabCreateManyPatientInput | LabCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutPatientInput = {
    id?: string
    prescriptionNo?: number | null
    status?: $Enums.PrescriptionStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutPrescriptionsInput
    doctor?: DoctorCreateNestedOneWithoutPrescriptionsInput
    medicines?: PrescriptionMedicineCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutPatientInput = {
    id?: string
    clinicId?: string | null
    doctorId?: string | null
    prescriptionNo?: number | null
    status?: $Enums.PrescriptionStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    medicines?: PrescriptionMedicineUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionCreateManyPatientInputEnvelope = {
    data: PrescriptionCreateManyPatientInput | PrescriptionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutPatientInput = {
    id?: string
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutTasksInput
    assignedDoctor?: DoctorCreateNestedOneWithoutAssignedTasksInput
    assignedAdmin?: AdminCreateNestedOneWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateWithoutPatientInput = {
    id?: string
    clinicId?: string | null
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assigneeDoctorId?: string | null
    assigneeAdminId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type TaskCreateOrConnectWithoutPatientInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutPatientInput, TaskUncheckedCreateWithoutPatientInput>
  }

  export type TaskCreateManyPatientInputEnvelope = {
    data: TaskCreateManyPatientInput | TaskCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type DataRequestCreateWithoutPatientInput = {
    id?: string
    type?: $Enums.DataRequestType | null
    status?: $Enums.DataRequestStatus | null
    requestReason?: string | null
    requestedAt?: Date | string | null
    completedAt?: Date | string | null
    downloadUrl?: string | null
    downloadExpiresAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutDataRequestsInput
  }

  export type DataRequestUncheckedCreateWithoutPatientInput = {
    id?: string
    clinicId?: string | null
    type?: $Enums.DataRequestType | null
    status?: $Enums.DataRequestStatus | null
    requestReason?: string | null
    requestedAt?: Date | string | null
    completedAt?: Date | string | null
    downloadUrl?: string | null
    downloadExpiresAt?: Date | string | null
  }

  export type DataRequestCreateOrConnectWithoutPatientInput = {
    where: DataRequestWhereUniqueInput
    create: XOR<DataRequestCreateWithoutPatientInput, DataRequestUncheckedCreateWithoutPatientInput>
  }

  export type DataRequestCreateManyPatientInputEnvelope = {
    data: DataRequestCreateManyPatientInput | DataRequestCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type EmergencyContactCreateWithoutPatientInput = {
    id?: string
    nameCipher?: string | null
    relationship?: string | null
    phoneCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type EmergencyContactUncheckedCreateWithoutPatientInput = {
    id?: string
    nameCipher?: string | null
    relationship?: string | null
    phoneCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type EmergencyContactCreateOrConnectWithoutPatientInput = {
    where: EmergencyContactWhereUniqueInput
    create: XOR<EmergencyContactCreateWithoutPatientInput, EmergencyContactUncheckedCreateWithoutPatientInput>
  }

  export type EmergencyContactCreateManyPatientInputEnvelope = {
    data: EmergencyContactCreateManyPatientInput | EmergencyContactCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type DiagnosisCreateWithoutPatientInput = {
    id?: string
    diagnosisCode?: string | null
    diagnosisName?: string | null
    description?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    resolvedDate?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    doctor?: DoctorCreateNestedOneWithoutDiagnosesInput
  }

  export type DiagnosisUncheckedCreateWithoutPatientInput = {
    id?: string
    doctorId?: string | null
    diagnosisCode?: string | null
    diagnosisName?: string | null
    description?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    resolvedDate?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DiagnosisCreateOrConnectWithoutPatientInput = {
    where: DiagnosisWhereUniqueInput
    create: XOR<DiagnosisCreateWithoutPatientInput, DiagnosisUncheckedCreateWithoutPatientInput>
  }

  export type DiagnosisCreateManyPatientInputEnvelope = {
    data: DiagnosisCreateManyPatientInput | DiagnosisCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PatientConsentCreateWithoutPatientInput = {
    id?: string
    type?: $Enums.ConsentType | null
    given?: boolean | null
    givenAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    consentVersion?: ConsentVersionCreateNestedOneWithoutPatientConsentsInput
  }

  export type PatientConsentUncheckedCreateWithoutPatientInput = {
    id?: string
    consentVersionId?: string | null
    type?: $Enums.ConsentType | null
    given?: boolean | null
    givenAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PatientConsentCreateOrConnectWithoutPatientInput = {
    where: PatientConsentWhereUniqueInput
    create: XOR<PatientConsentCreateWithoutPatientInput, PatientConsentUncheckedCreateWithoutPatientInput>
  }

  export type PatientConsentCreateManyPatientInputEnvelope = {
    data: PatientConsentCreateManyPatientInput | PatientConsentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutPatientsInput = {
    update: XOR<ClinicUpdateWithoutPatientsInput, ClinicUncheckedUpdateWithoutPatientsInput>
    create: XOR<ClinicCreateWithoutPatientsInput, ClinicUncheckedCreateWithoutPatientsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutPatientsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutPatientsInput, ClinicUncheckedUpdateWithoutPatientsInput>
  }

  export type ClinicUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    calls?: CallUpdateManyWithoutClinicNestedInput
    labs?: LabUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutClinicNestedInput
    tasks?: TaskUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    calls?: CallUncheckedUpdateManyWithoutClinicNestedInput
    labs?: LabUncheckedUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutClinicNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type CallUpsertWithWhereUniqueWithoutPatientInput = {
    where: CallWhereUniqueInput
    update: XOR<CallUpdateWithoutPatientInput, CallUncheckedUpdateWithoutPatientInput>
    create: XOR<CallCreateWithoutPatientInput, CallUncheckedCreateWithoutPatientInput>
  }

  export type CallUpdateWithWhereUniqueWithoutPatientInput = {
    where: CallWhereUniqueInput
    data: XOR<CallUpdateWithoutPatientInput, CallUncheckedUpdateWithoutPatientInput>
  }

  export type CallUpdateManyWithWhereWithoutPatientInput = {
    where: CallScalarWhereInput
    data: XOR<CallUpdateManyMutationInput, CallUncheckedUpdateManyWithoutPatientInput>
  }

  export type LabUpsertWithWhereUniqueWithoutPatientInput = {
    where: LabWhereUniqueInput
    update: XOR<LabUpdateWithoutPatientInput, LabUncheckedUpdateWithoutPatientInput>
    create: XOR<LabCreateWithoutPatientInput, LabUncheckedCreateWithoutPatientInput>
  }

  export type LabUpdateWithWhereUniqueWithoutPatientInput = {
    where: LabWhereUniqueInput
    data: XOR<LabUpdateWithoutPatientInput, LabUncheckedUpdateWithoutPatientInput>
  }

  export type LabUpdateManyWithWhereWithoutPatientInput = {
    where: LabScalarWhereInput
    data: XOR<LabUpdateManyMutationInput, LabUncheckedUpdateManyWithoutPatientInput>
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutPatientInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutPatientInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutPatientInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutPatientInput, TaskUncheckedUpdateWithoutPatientInput>
    create: XOR<TaskCreateWithoutPatientInput, TaskUncheckedCreateWithoutPatientInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutPatientInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutPatientInput, TaskUncheckedUpdateWithoutPatientInput>
  }

  export type TaskUpdateManyWithWhereWithoutPatientInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutPatientInput>
  }

  export type DataRequestUpsertWithWhereUniqueWithoutPatientInput = {
    where: DataRequestWhereUniqueInput
    update: XOR<DataRequestUpdateWithoutPatientInput, DataRequestUncheckedUpdateWithoutPatientInput>
    create: XOR<DataRequestCreateWithoutPatientInput, DataRequestUncheckedCreateWithoutPatientInput>
  }

  export type DataRequestUpdateWithWhereUniqueWithoutPatientInput = {
    where: DataRequestWhereUniqueInput
    data: XOR<DataRequestUpdateWithoutPatientInput, DataRequestUncheckedUpdateWithoutPatientInput>
  }

  export type DataRequestUpdateManyWithWhereWithoutPatientInput = {
    where: DataRequestScalarWhereInput
    data: XOR<DataRequestUpdateManyMutationInput, DataRequestUncheckedUpdateManyWithoutPatientInput>
  }

  export type EmergencyContactUpsertWithWhereUniqueWithoutPatientInput = {
    where: EmergencyContactWhereUniqueInput
    update: XOR<EmergencyContactUpdateWithoutPatientInput, EmergencyContactUncheckedUpdateWithoutPatientInput>
    create: XOR<EmergencyContactCreateWithoutPatientInput, EmergencyContactUncheckedCreateWithoutPatientInput>
  }

  export type EmergencyContactUpdateWithWhereUniqueWithoutPatientInput = {
    where: EmergencyContactWhereUniqueInput
    data: XOR<EmergencyContactUpdateWithoutPatientInput, EmergencyContactUncheckedUpdateWithoutPatientInput>
  }

  export type EmergencyContactUpdateManyWithWhereWithoutPatientInput = {
    where: EmergencyContactScalarWhereInput
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyWithoutPatientInput>
  }

  export type EmergencyContactScalarWhereInput = {
    AND?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
    OR?: EmergencyContactScalarWhereInput[]
    NOT?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
    id?: UuidFilter<"EmergencyContact"> | string
    patientId?: UuidNullableFilter<"EmergencyContact"> | string | null
    nameCipher?: StringNullableFilter<"EmergencyContact"> | string | null
    relationship?: StringNullableFilter<"EmergencyContact"> | string | null
    phoneCipher?: StringNullableFilter<"EmergencyContact"> | string | null
    createdAt?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
  }

  export type DiagnosisUpsertWithWhereUniqueWithoutPatientInput = {
    where: DiagnosisWhereUniqueInput
    update: XOR<DiagnosisUpdateWithoutPatientInput, DiagnosisUncheckedUpdateWithoutPatientInput>
    create: XOR<DiagnosisCreateWithoutPatientInput, DiagnosisUncheckedCreateWithoutPatientInput>
  }

  export type DiagnosisUpdateWithWhereUniqueWithoutPatientInput = {
    where: DiagnosisWhereUniqueInput
    data: XOR<DiagnosisUpdateWithoutPatientInput, DiagnosisUncheckedUpdateWithoutPatientInput>
  }

  export type DiagnosisUpdateManyWithWhereWithoutPatientInput = {
    where: DiagnosisScalarWhereInput
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyWithoutPatientInput>
  }

  export type DiagnosisScalarWhereInput = {
    AND?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
    OR?: DiagnosisScalarWhereInput[]
    NOT?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
    id?: UuidFilter<"Diagnosis"> | string
    patientId?: UuidNullableFilter<"Diagnosis"> | string | null
    doctorId?: UuidNullableFilter<"Diagnosis"> | string | null
    diagnosisCode?: StringNullableFilter<"Diagnosis"> | string | null
    diagnosisName?: StringNullableFilter<"Diagnosis"> | string | null
    description?: StringNullableFilter<"Diagnosis"> | string | null
    status?: StringNullableFilter<"Diagnosis"> | string | null
    diagnosedDate?: DateTimeNullableFilter<"Diagnosis"> | Date | string | null
    resolvedDate?: DateTimeNullableFilter<"Diagnosis"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Diagnosis"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Diagnosis"> | Date | string | null
  }

  export type PatientConsentUpsertWithWhereUniqueWithoutPatientInput = {
    where: PatientConsentWhereUniqueInput
    update: XOR<PatientConsentUpdateWithoutPatientInput, PatientConsentUncheckedUpdateWithoutPatientInput>
    create: XOR<PatientConsentCreateWithoutPatientInput, PatientConsentUncheckedCreateWithoutPatientInput>
  }

  export type PatientConsentUpdateWithWhereUniqueWithoutPatientInput = {
    where: PatientConsentWhereUniqueInput
    data: XOR<PatientConsentUpdateWithoutPatientInput, PatientConsentUncheckedUpdateWithoutPatientInput>
  }

  export type PatientConsentUpdateManyWithWhereWithoutPatientInput = {
    where: PatientConsentScalarWhereInput
    data: XOR<PatientConsentUpdateManyMutationInput, PatientConsentUncheckedUpdateManyWithoutPatientInput>
  }

  export type PatientCreateWithoutEmergencyContactsInput = {
    id?: string
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    clinic?: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    calls?: CallCreateNestedManyWithoutPatientInput
    labs?: LabCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    tasks?: TaskCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisCreateNestedManyWithoutPatientInput
    consents?: PatientConsentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutEmergencyContactsInput = {
    id?: string
    clinicId?: string | null
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    calls?: CallUncheckedCreateNestedManyWithoutPatientInput
    labs?: LabUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    consents?: PatientConsentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutEmergencyContactsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutEmergencyContactsInput, PatientUncheckedCreateWithoutEmergencyContactsInput>
  }

  export type PatientUpsertWithoutEmergencyContactsInput = {
    update: XOR<PatientUpdateWithoutEmergencyContactsInput, PatientUncheckedUpdateWithoutEmergencyContactsInput>
    create: XOR<PatientCreateWithoutEmergencyContactsInput, PatientUncheckedCreateWithoutEmergencyContactsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutEmergencyContactsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutEmergencyContactsInput, PatientUncheckedUpdateWithoutEmergencyContactsInput>
  }

  export type PatientUpdateWithoutEmergencyContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClinicUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    calls?: CallUpdateManyWithoutPatientNestedInput
    labs?: LabUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    tasks?: TaskUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutEmergencyContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    calls?: CallUncheckedUpdateManyWithoutPatientNestedInput
    labs?: LabUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorCreateWithoutStaffPersonalInfoInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutDoctorsInput
    sessions?: SessionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    calls?: CallCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogCreateNestedManyWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoCreateNestedManyWithoutReportingToInput
  }

  export type DoctorUncheckedCreateWithoutStaffPersonalInfoInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    calls?: CallUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoUncheckedCreateNestedManyWithoutReportingToInput
  }

  export type DoctorCreateOrConnectWithoutStaffPersonalInfoInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutStaffPersonalInfoInput, DoctorUncheckedCreateWithoutStaffPersonalInfoInput>
  }

  export type DoctorUpsertWithoutStaffPersonalInfoInput = {
    update: XOR<DoctorUpdateWithoutStaffPersonalInfoInput, DoctorUncheckedUpdateWithoutStaffPersonalInfoInput>
    create: XOR<DoctorCreateWithoutStaffPersonalInfoInput, DoctorUncheckedCreateWithoutStaffPersonalInfoInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutStaffPersonalInfoInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutStaffPersonalInfoInput, DoctorUncheckedUpdateWithoutStaffPersonalInfoInput>
  }

  export type DoctorUpdateWithoutStaffPersonalInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutDoctorsNestedInput
    sessions?: SessionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    calls?: CallUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorUncheckedUpdateWithoutStaffPersonalInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    calls?: CallUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUncheckedUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorCreateWithoutStaffEmploymentInfoInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutDoctorsInput
    sessions?: SessionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    calls?: CallCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoCreateNestedManyWithoutReportingToInput
  }

  export type DoctorUncheckedCreateWithoutStaffEmploymentInfoInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    calls?: CallUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoUncheckedCreateNestedManyWithoutReportingToInput
  }

  export type DoctorCreateOrConnectWithoutStaffEmploymentInfoInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutStaffEmploymentInfoInput, DoctorUncheckedCreateWithoutStaffEmploymentInfoInput>
  }

  export type DoctorCreateWithoutSubordinatesInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutDoctorsInput
    sessions?: SessionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    calls?: CallCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoCreateNestedOneWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutSubordinatesInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    calls?: CallUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedCreateNestedOneWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutSubordinatesInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutSubordinatesInput, DoctorUncheckedCreateWithoutSubordinatesInput>
  }

  export type DoctorUpsertWithoutStaffEmploymentInfoInput = {
    update: XOR<DoctorUpdateWithoutStaffEmploymentInfoInput, DoctorUncheckedUpdateWithoutStaffEmploymentInfoInput>
    create: XOR<DoctorCreateWithoutStaffEmploymentInfoInput, DoctorUncheckedCreateWithoutStaffEmploymentInfoInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutStaffEmploymentInfoInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutStaffEmploymentInfoInput, DoctorUncheckedUpdateWithoutStaffEmploymentInfoInput>
  }

  export type DoctorUpdateWithoutStaffEmploymentInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutDoctorsNestedInput
    sessions?: SessionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    calls?: CallUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorUncheckedUpdateWithoutStaffEmploymentInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    calls?: CallUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUncheckedUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorUpsertWithoutSubordinatesInput = {
    update: XOR<DoctorUpdateWithoutSubordinatesInput, DoctorUncheckedUpdateWithoutSubordinatesInput>
    create: XOR<DoctorCreateWithoutSubordinatesInput, DoctorUncheckedCreateWithoutSubordinatesInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutSubordinatesInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutSubordinatesInput, DoctorUncheckedUpdateWithoutSubordinatesInput>
  }

  export type DoctorUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutDoctorsNestedInput
    sessions?: SessionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    calls?: CallUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUpdateOneWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    calls?: CallUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedUpdateOneWithoutDoctorNestedInput
  }

  export type ClinicCreateWithoutTasksInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminCreateNestedManyWithoutClinicInput
    doctors?: DoctorCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    calls?: CallCreateNestedManyWithoutClinicInput
    labs?: LabCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    invoices?: InvoiceCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutTasksInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutClinicInput
    doctors?: DoctorUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    calls?: CallUncheckedCreateNestedManyWithoutClinicInput
    labs?: LabUncheckedCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutTasksInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutTasksInput, ClinicUncheckedCreateWithoutTasksInput>
  }

  export type DoctorCreateWithoutAssignedTasksInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutDoctorsInput
    sessions?: SessionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    calls?: CallCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisCreateNestedManyWithoutDoctorInput
    auditLogs?: AuditLogCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoCreateNestedManyWithoutReportingToInput
  }

  export type DoctorUncheckedCreateWithoutAssignedTasksInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    calls?: CallUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoUncheckedCreateNestedManyWithoutReportingToInput
  }

  export type DoctorCreateOrConnectWithoutAssignedTasksInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutAssignedTasksInput, DoctorUncheckedCreateWithoutAssignedTasksInput>
  }

  export type AdminCreateWithoutAssignedTasksInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutAdminsInput
    sessions?: SessionCreateNestedManyWithoutAdminInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutAssignedTasksInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutAssignedTasksInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAssignedTasksInput, AdminUncheckedCreateWithoutAssignedTasksInput>
  }

  export type PatientCreateWithoutTasksInput = {
    id?: string
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    clinic?: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    calls?: CallCreateNestedManyWithoutPatientInput
    labs?: LabCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisCreateNestedManyWithoutPatientInput
    consents?: PatientConsentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutTasksInput = {
    id?: string
    clinicId?: string | null
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    calls?: CallUncheckedCreateNestedManyWithoutPatientInput
    labs?: LabUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutPatientInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutPatientInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    consents?: PatientConsentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutTasksInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutTasksInput, PatientUncheckedCreateWithoutTasksInput>
  }

  export type ClinicUpsertWithoutTasksInput = {
    update: XOR<ClinicUpdateWithoutTasksInput, ClinicUncheckedUpdateWithoutTasksInput>
    create: XOR<ClinicCreateWithoutTasksInput, ClinicUncheckedCreateWithoutTasksInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutTasksInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutTasksInput, ClinicUncheckedUpdateWithoutTasksInput>
  }

  export type ClinicUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    calls?: CallUpdateManyWithoutClinicNestedInput
    labs?: LabUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutClinicNestedInput
    doctors?: DoctorUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    calls?: CallUncheckedUpdateManyWithoutClinicNestedInput
    labs?: LabUncheckedUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type DoctorUpsertWithoutAssignedTasksInput = {
    update: XOR<DoctorUpdateWithoutAssignedTasksInput, DoctorUncheckedUpdateWithoutAssignedTasksInput>
    create: XOR<DoctorCreateWithoutAssignedTasksInput, DoctorUncheckedCreateWithoutAssignedTasksInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutAssignedTasksInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutAssignedTasksInput, DoctorUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type DoctorUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutDoctorsNestedInput
    sessions?: SessionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    calls?: CallUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutDoctorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorUncheckedUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    calls?: CallUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUncheckedUpdateManyWithoutReportingToNestedInput
  }

  export type AdminUpsertWithoutAssignedTasksInput = {
    update: XOR<AdminUpdateWithoutAssignedTasksInput, AdminUncheckedUpdateWithoutAssignedTasksInput>
    create: XOR<AdminCreateWithoutAssignedTasksInput, AdminUncheckedCreateWithoutAssignedTasksInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAssignedTasksInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAssignedTasksInput, AdminUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type AdminUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutAdminsNestedInput
    sessions?: SessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type PatientUpsertWithoutTasksInput = {
    update: XOR<PatientUpdateWithoutTasksInput, PatientUncheckedUpdateWithoutTasksInput>
    create: XOR<PatientCreateWithoutTasksInput, PatientUncheckedCreateWithoutTasksInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutTasksInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutTasksInput, PatientUncheckedUpdateWithoutTasksInput>
  }

  export type PatientUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClinicUpdateOneWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    calls?: CallUpdateManyWithoutPatientNestedInput
    labs?: LabUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    calls?: CallUncheckedUpdateManyWithoutPatientNestedInput
    labs?: LabUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ClinicCreateWithoutAdminsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    doctors?: DoctorCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    calls?: CallCreateNestedManyWithoutClinicInput
    labs?: LabCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionCreateNestedManyWithoutClinicInput
    tasks?: TaskCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    invoices?: InvoiceCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutAdminsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    doctors?: DoctorUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    calls?: CallUncheckedCreateNestedManyWithoutClinicInput
    labs?: LabUncheckedCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutClinicInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutAdminsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutAdminsInput, ClinicUncheckedCreateWithoutAdminsInput>
  }

  export type SessionCreateWithoutAdminInput = {
    id?: string
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
    doctor?: DoctorCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutAdminInput = {
    id?: string
    doctorId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
  }

  export type SessionCreateOrConnectWithoutAdminInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutAdminInput, SessionUncheckedCreateWithoutAdminInput>
  }

  export type SessionCreateManyAdminInputEnvelope = {
    data: SessionCreateManyAdminInput | SessionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutAdminInput = {
    id?: string
    table?: string | null
    rowId?: string | null
    action?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    occurredAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutAuditLogsInput
    doctor?: DoctorCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutAdminInput = {
    id?: string
    table?: string | null
    rowId?: string | null
    action?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: string | null
    clinicId?: string | null
    ip?: string | null
    userAgent?: string | null
    occurredAt?: Date | string | null
  }

  export type AuditLogCreateOrConnectWithoutAdminInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutAdminInput, AuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AuditLogCreateManyAdminInputEnvelope = {
    data: AuditLogCreateManyAdminInput | AuditLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutAssignedAdminInput = {
    id?: string
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutTasksInput
    assignedDoctor?: DoctorCreateNestedOneWithoutAssignedTasksInput
    patient?: PatientCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutAssignedAdminInput = {
    id?: string
    clinicId?: string | null
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assigneeDoctorId?: string | null
    patientId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type TaskCreateOrConnectWithoutAssignedAdminInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssignedAdminInput, TaskUncheckedCreateWithoutAssignedAdminInput>
  }

  export type TaskCreateManyAssignedAdminInputEnvelope = {
    data: TaskCreateManyAssignedAdminInput | TaskCreateManyAssignedAdminInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutAdminsInput = {
    update: XOR<ClinicUpdateWithoutAdminsInput, ClinicUncheckedUpdateWithoutAdminsInput>
    create: XOR<ClinicCreateWithoutAdminsInput, ClinicUncheckedCreateWithoutAdminsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutAdminsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutAdminsInput, ClinicUncheckedUpdateWithoutAdminsInput>
  }

  export type ClinicUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctors?: DoctorUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    calls?: CallUpdateManyWithoutClinicNestedInput
    labs?: LabUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutClinicNestedInput
    tasks?: TaskUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctors?: DoctorUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    calls?: CallUncheckedUpdateManyWithoutClinicNestedInput
    labs?: LabUncheckedUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutClinicNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutAdminInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutAdminInput, SessionUncheckedUpdateWithoutAdminInput>
    create: XOR<SessionCreateWithoutAdminInput, SessionUncheckedCreateWithoutAdminInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutAdminInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutAdminInput, SessionUncheckedUpdateWithoutAdminInput>
  }

  export type SessionUpdateManyWithWhereWithoutAdminInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutAdminInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: UuidFilter<"Session"> | string
    adminId?: UuidNullableFilter<"Session"> | string | null
    doctorId?: UuidNullableFilter<"Session"> | string | null
    ip?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeNullableFilter<"Session"> | Date | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutAdminInput, AuditLogUncheckedUpdateWithoutAdminInput>
    create: XOR<AuditLogCreateWithoutAdminInput, AuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutAdminInput, AuditLogUncheckedUpdateWithoutAdminInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutAdminInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutAssignedAdminInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAssignedAdminInput, TaskUncheckedUpdateWithoutAssignedAdminInput>
    create: XOR<TaskCreateWithoutAssignedAdminInput, TaskUncheckedCreateWithoutAssignedAdminInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAssignedAdminInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAssignedAdminInput, TaskUncheckedUpdateWithoutAssignedAdminInput>
  }

  export type TaskUpdateManyWithWhereWithoutAssignedAdminInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAssignedAdminInput>
  }

  export type ClinicCreateWithoutDoctorsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    calls?: CallCreateNestedManyWithoutClinicInput
    labs?: LabCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionCreateNestedManyWithoutClinicInput
    tasks?: TaskCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    invoices?: InvoiceCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutDoctorsInput = {
    id?: string
    name?: string | null
    address?: string | null
    vatId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    calls?: CallUncheckedCreateNestedManyWithoutClinicInput
    labs?: LabUncheckedCreateNestedManyWithoutClinicInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutClinicInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClinicInput
    notificationQueues?: NotificationQueueUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    dataRequests?: DataRequestUncheckedCreateNestedManyWithoutClinicInput
    consentVersions?: ConsentVersionUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutDoctorsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutDoctorsInput, ClinicUncheckedCreateWithoutDoctorsInput>
  }

  export type SessionCreateWithoutDoctorInput = {
    id?: string
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
    admin?: AdminCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutDoctorInput = {
    id?: string
    adminId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
  }

  export type SessionCreateOrConnectWithoutDoctorInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutDoctorInput, SessionUncheckedCreateWithoutDoctorInput>
  }

  export type SessionCreateManyDoctorInputEnvelope = {
    data: SessionCreateManyDoctorInput | SessionCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutDoctorInput = {
    id?: string
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.AppointmentStatus | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutAppointmentsInput
    patient?: PatientCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutDoctorInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.AppointmentStatus | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type AppointmentCreateOrConnectWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentCreateManyDoctorInputEnvelope = {
    data: AppointmentCreateManyDoctorInput | AppointmentCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type CallCreateWithoutDoctorInput = {
    id?: string
    startAt?: Date | string | null
    endAt?: Date | string | null
    durationSeconds?: number | null
    status?: $Enums.CallStatus | null
    recordingUrlCipher?: string | null
    transcript?: string | null
    aiSummary?: string | null
    sentiment?: $Enums.Sentiment | null
    escalated?: boolean | null
    minutesUsed?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    aiModelId?: string | null
    aiDecision?: string | null
    clinic?: ClinicCreateNestedOneWithoutCallsInput
    patient?: PatientCreateNestedOneWithoutCallsInput
  }

  export type CallUncheckedCreateWithoutDoctorInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    durationSeconds?: number | null
    status?: $Enums.CallStatus | null
    recordingUrlCipher?: string | null
    transcript?: string | null
    aiSummary?: string | null
    sentiment?: $Enums.Sentiment | null
    escalated?: boolean | null
    minutesUsed?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    aiModelId?: string | null
    aiDecision?: string | null
  }

  export type CallCreateOrConnectWithoutDoctorInput = {
    where: CallWhereUniqueInput
    create: XOR<CallCreateWithoutDoctorInput, CallUncheckedCreateWithoutDoctorInput>
  }

  export type CallCreateManyDoctorInputEnvelope = {
    data: CallCreateManyDoctorInput | CallCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutDoctorInput = {
    id?: string
    prescriptionNo?: number | null
    status?: $Enums.PrescriptionStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutPrescriptionsInput
    patient?: PatientCreateNestedOneWithoutPrescriptionsInput
    medicines?: PrescriptionMedicineCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutDoctorInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    prescriptionNo?: number | null
    status?: $Enums.PrescriptionStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    medicines?: PrescriptionMedicineUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput>
  }

  export type PrescriptionCreateManyDoctorInputEnvelope = {
    data: PrescriptionCreateManyDoctorInput | PrescriptionCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type DiagnosisCreateWithoutDoctorInput = {
    id?: string
    diagnosisCode?: string | null
    diagnosisName?: string | null
    description?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    resolvedDate?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    patient?: PatientCreateNestedOneWithoutDiagnosesInput
  }

  export type DiagnosisUncheckedCreateWithoutDoctorInput = {
    id?: string
    patientId?: string | null
    diagnosisCode?: string | null
    diagnosisName?: string | null
    description?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    resolvedDate?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DiagnosisCreateOrConnectWithoutDoctorInput = {
    where: DiagnosisWhereUniqueInput
    create: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput>
  }

  export type DiagnosisCreateManyDoctorInputEnvelope = {
    data: DiagnosisCreateManyDoctorInput | DiagnosisCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutAssignedDoctorInput = {
    id?: string
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutTasksInput
    assignedAdmin?: AdminCreateNestedOneWithoutAssignedTasksInput
    patient?: PatientCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutAssignedDoctorInput = {
    id?: string
    clinicId?: string | null
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assigneeAdminId?: string | null
    patientId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type TaskCreateOrConnectWithoutAssignedDoctorInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssignedDoctorInput, TaskUncheckedCreateWithoutAssignedDoctorInput>
  }

  export type TaskCreateManyAssignedDoctorInputEnvelope = {
    data: TaskCreateManyAssignedDoctorInput | TaskCreateManyAssignedDoctorInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutDoctorInput = {
    id?: string
    table?: string | null
    rowId?: string | null
    action?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    occurredAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutAuditLogsInput
    admin?: AdminCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutDoctorInput = {
    id?: string
    table?: string | null
    rowId?: string | null
    action?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    adminId?: string | null
    clinicId?: string | null
    ip?: string | null
    userAgent?: string | null
    occurredAt?: Date | string | null
  }

  export type AuditLogCreateOrConnectWithoutDoctorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutDoctorInput, AuditLogUncheckedCreateWithoutDoctorInput>
  }

  export type AuditLogCreateManyDoctorInputEnvelope = {
    data: AuditLogCreateManyDoctorInput | AuditLogCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type StaffPersonalInfoCreateWithoutDoctorInput = {
    id?: string
    dateOfBirth?: Date | string | null
    phoneCipher?: string | null
    addressCipher?: string | null
    stateProvince?: string | null
    postalCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelationship?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type StaffPersonalInfoUncheckedCreateWithoutDoctorInput = {
    id?: string
    dateOfBirth?: Date | string | null
    phoneCipher?: string | null
    addressCipher?: string | null
    stateProvince?: string | null
    postalCode?: string | null
    country?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelationship?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type StaffPersonalInfoCreateOrConnectWithoutDoctorInput = {
    where: StaffPersonalInfoWhereUniqueInput
    create: XOR<StaffPersonalInfoCreateWithoutDoctorInput, StaffPersonalInfoUncheckedCreateWithoutDoctorInput>
  }

  export type StaffEmploymentInfoCreateWithoutDoctorInput = {
    id?: string
    employeeId?: string | null
    department?: $Enums.Department | null
    position?: string | null
    joinDate?: Date | string | null
    employmentType?: $Enums.EmploymentType | null
    workSchedule?: string | null
    weeklyHours?: number | null
    salaryCipher?: string | null
    employmentStatus?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    reportingTo?: DoctorCreateNestedOneWithoutSubordinatesInput
  }

  export type StaffEmploymentInfoUncheckedCreateWithoutDoctorInput = {
    id?: string
    employeeId?: string | null
    department?: $Enums.Department | null
    position?: string | null
    reportingToId?: string | null
    joinDate?: Date | string | null
    employmentType?: $Enums.EmploymentType | null
    workSchedule?: string | null
    weeklyHours?: number | null
    salaryCipher?: string | null
    employmentStatus?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type StaffEmploymentInfoCreateOrConnectWithoutDoctorInput = {
    where: StaffEmploymentInfoWhereUniqueInput
    create: XOR<StaffEmploymentInfoCreateWithoutDoctorInput, StaffEmploymentInfoUncheckedCreateWithoutDoctorInput>
  }

  export type StaffEmploymentInfoCreateWithoutReportingToInput = {
    id?: string
    employeeId?: string | null
    department?: $Enums.Department | null
    position?: string | null
    joinDate?: Date | string | null
    employmentType?: $Enums.EmploymentType | null
    workSchedule?: string | null
    weeklyHours?: number | null
    salaryCipher?: string | null
    employmentStatus?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    doctor?: DoctorCreateNestedOneWithoutStaffEmploymentInfoInput
  }

  export type StaffEmploymentInfoUncheckedCreateWithoutReportingToInput = {
    id?: string
    doctorId?: string | null
    employeeId?: string | null
    department?: $Enums.Department | null
    position?: string | null
    joinDate?: Date | string | null
    employmentType?: $Enums.EmploymentType | null
    workSchedule?: string | null
    weeklyHours?: number | null
    salaryCipher?: string | null
    employmentStatus?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type StaffEmploymentInfoCreateOrConnectWithoutReportingToInput = {
    where: StaffEmploymentInfoWhereUniqueInput
    create: XOR<StaffEmploymentInfoCreateWithoutReportingToInput, StaffEmploymentInfoUncheckedCreateWithoutReportingToInput>
  }

  export type StaffEmploymentInfoCreateManyReportingToInputEnvelope = {
    data: StaffEmploymentInfoCreateManyReportingToInput | StaffEmploymentInfoCreateManyReportingToInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutDoctorsInput = {
    update: XOR<ClinicUpdateWithoutDoctorsInput, ClinicUncheckedUpdateWithoutDoctorsInput>
    create: XOR<ClinicCreateWithoutDoctorsInput, ClinicUncheckedCreateWithoutDoctorsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutDoctorsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutDoctorsInput, ClinicUncheckedUpdateWithoutDoctorsInput>
  }

  export type ClinicUpdateWithoutDoctorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    calls?: CallUpdateManyWithoutClinicNestedInput
    labs?: LabUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutClinicNestedInput
    tasks?: TaskUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutDoctorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    calls?: CallUncheckedUpdateManyWithoutClinicNestedInput
    labs?: LabUncheckedUpdateManyWithoutClinicNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutClinicNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClinicNestedInput
    notificationQueues?: NotificationQueueUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutClinicNestedInput
    consentVersions?: ConsentVersionUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutDoctorInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutDoctorInput, SessionUncheckedUpdateWithoutDoctorInput>
    create: XOR<SessionCreateWithoutDoctorInput, SessionUncheckedCreateWithoutDoctorInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutDoctorInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutDoctorInput, SessionUncheckedUpdateWithoutDoctorInput>
  }

  export type SessionUpdateManyWithWhereWithoutDoctorInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutDoctorInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDoctorInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDoctorInput>
  }

  export type CallUpsertWithWhereUniqueWithoutDoctorInput = {
    where: CallWhereUniqueInput
    update: XOR<CallUpdateWithoutDoctorInput, CallUncheckedUpdateWithoutDoctorInput>
    create: XOR<CallCreateWithoutDoctorInput, CallUncheckedCreateWithoutDoctorInput>
  }

  export type CallUpdateWithWhereUniqueWithoutDoctorInput = {
    where: CallWhereUniqueInput
    data: XOR<CallUpdateWithoutDoctorInput, CallUncheckedUpdateWithoutDoctorInput>
  }

  export type CallUpdateManyWithWhereWithoutDoctorInput = {
    where: CallScalarWhereInput
    data: XOR<CallUpdateManyMutationInput, CallUncheckedUpdateManyWithoutDoctorInput>
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutDoctorInput, PrescriptionUncheckedUpdateWithoutDoctorInput>
    create: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutDoctorInput, PrescriptionUncheckedUpdateWithoutDoctorInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutDoctorInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutDoctorInput>
  }

  export type DiagnosisUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DiagnosisWhereUniqueInput
    update: XOR<DiagnosisUpdateWithoutDoctorInput, DiagnosisUncheckedUpdateWithoutDoctorInput>
    create: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput>
  }

  export type DiagnosisUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DiagnosisWhereUniqueInput
    data: XOR<DiagnosisUpdateWithoutDoctorInput, DiagnosisUncheckedUpdateWithoutDoctorInput>
  }

  export type DiagnosisUpdateManyWithWhereWithoutDoctorInput = {
    where: DiagnosisScalarWhereInput
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyWithoutDoctorInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutAssignedDoctorInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAssignedDoctorInput, TaskUncheckedUpdateWithoutAssignedDoctorInput>
    create: XOR<TaskCreateWithoutAssignedDoctorInput, TaskUncheckedCreateWithoutAssignedDoctorInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAssignedDoctorInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAssignedDoctorInput, TaskUncheckedUpdateWithoutAssignedDoctorInput>
  }

  export type TaskUpdateManyWithWhereWithoutAssignedDoctorInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAssignedDoctorInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutDoctorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutDoctorInput, AuditLogUncheckedUpdateWithoutDoctorInput>
    create: XOR<AuditLogCreateWithoutDoctorInput, AuditLogUncheckedCreateWithoutDoctorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutDoctorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutDoctorInput, AuditLogUncheckedUpdateWithoutDoctorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutDoctorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutDoctorInput>
  }

  export type StaffPersonalInfoUpsertWithoutDoctorInput = {
    update: XOR<StaffPersonalInfoUpdateWithoutDoctorInput, StaffPersonalInfoUncheckedUpdateWithoutDoctorInput>
    create: XOR<StaffPersonalInfoCreateWithoutDoctorInput, StaffPersonalInfoUncheckedCreateWithoutDoctorInput>
    where?: StaffPersonalInfoWhereInput
  }

  export type StaffPersonalInfoUpdateToOneWithWhereWithoutDoctorInput = {
    where?: StaffPersonalInfoWhereInput
    data: XOR<StaffPersonalInfoUpdateWithoutDoctorInput, StaffPersonalInfoUncheckedUpdateWithoutDoctorInput>
  }

  export type StaffPersonalInfoUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    stateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StaffPersonalInfoUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    stateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StaffEmploymentInfoUpsertWithoutDoctorInput = {
    update: XOR<StaffEmploymentInfoUpdateWithoutDoctorInput, StaffEmploymentInfoUncheckedUpdateWithoutDoctorInput>
    create: XOR<StaffEmploymentInfoCreateWithoutDoctorInput, StaffEmploymentInfoUncheckedCreateWithoutDoctorInput>
    where?: StaffEmploymentInfoWhereInput
  }

  export type StaffEmploymentInfoUpdateToOneWithWhereWithoutDoctorInput = {
    where?: StaffEmploymentInfoWhereInput
    data: XOR<StaffEmploymentInfoUpdateWithoutDoctorInput, StaffEmploymentInfoUncheckedUpdateWithoutDoctorInput>
  }

  export type StaffEmploymentInfoUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableEnumDepartmentFieldUpdateOperationsInput | $Enums.Department | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null
    workSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    salaryCipher?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportingTo?: DoctorUpdateOneWithoutSubordinatesNestedInput
  }

  export type StaffEmploymentInfoUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableEnumDepartmentFieldUpdateOperationsInput | $Enums.Department | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    reportingToId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null
    workSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    salaryCipher?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StaffEmploymentInfoUpsertWithWhereUniqueWithoutReportingToInput = {
    where: StaffEmploymentInfoWhereUniqueInput
    update: XOR<StaffEmploymentInfoUpdateWithoutReportingToInput, StaffEmploymentInfoUncheckedUpdateWithoutReportingToInput>
    create: XOR<StaffEmploymentInfoCreateWithoutReportingToInput, StaffEmploymentInfoUncheckedCreateWithoutReportingToInput>
  }

  export type StaffEmploymentInfoUpdateWithWhereUniqueWithoutReportingToInput = {
    where: StaffEmploymentInfoWhereUniqueInput
    data: XOR<StaffEmploymentInfoUpdateWithoutReportingToInput, StaffEmploymentInfoUncheckedUpdateWithoutReportingToInput>
  }

  export type StaffEmploymentInfoUpdateManyWithWhereWithoutReportingToInput = {
    where: StaffEmploymentInfoScalarWhereInput
    data: XOR<StaffEmploymentInfoUpdateManyMutationInput, StaffEmploymentInfoUncheckedUpdateManyWithoutReportingToInput>
  }

  export type StaffEmploymentInfoScalarWhereInput = {
    AND?: StaffEmploymentInfoScalarWhereInput | StaffEmploymentInfoScalarWhereInput[]
    OR?: StaffEmploymentInfoScalarWhereInput[]
    NOT?: StaffEmploymentInfoScalarWhereInput | StaffEmploymentInfoScalarWhereInput[]
    id?: UuidFilter<"StaffEmploymentInfo"> | string
    doctorId?: UuidNullableFilter<"StaffEmploymentInfo"> | string | null
    employeeId?: StringNullableFilter<"StaffEmploymentInfo"> | string | null
    department?: EnumDepartmentNullableFilter<"StaffEmploymentInfo"> | $Enums.Department | null
    position?: StringNullableFilter<"StaffEmploymentInfo"> | string | null
    reportingToId?: UuidNullableFilter<"StaffEmploymentInfo"> | string | null
    joinDate?: DateTimeNullableFilter<"StaffEmploymentInfo"> | Date | string | null
    employmentType?: EnumEmploymentTypeNullableFilter<"StaffEmploymentInfo"> | $Enums.EmploymentType | null
    workSchedule?: StringNullableFilter<"StaffEmploymentInfo"> | string | null
    weeklyHours?: IntNullableFilter<"StaffEmploymentInfo"> | number | null
    salaryCipher?: StringNullableFilter<"StaffEmploymentInfo"> | string | null
    employmentStatus?: StringNullableFilter<"StaffEmploymentInfo"> | string | null
    createdAt?: DateTimeNullableFilter<"StaffEmploymentInfo"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"StaffEmploymentInfo"> | Date | string | null
  }

  export type AdminCreateWithoutSessionsInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutAdminsInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedAdminInput
  }

  export type AdminUncheckedCreateWithoutSessionsInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedAdminInput
  }

  export type AdminCreateOrConnectWithoutSessionsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutSessionsInput, AdminUncheckedCreateWithoutSessionsInput>
  }

  export type DoctorCreateWithoutSessionsInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    clinic?: ClinicCreateNestedOneWithoutDoctorsInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    calls?: CallCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoCreateNestedManyWithoutReportingToInput
  }

  export type DoctorUncheckedCreateWithoutSessionsInput = {
    id?: string
    clinicId?: string | null
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    calls?: CallUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    diagnoses?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedDoctorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutDoctorInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedCreateNestedOneWithoutDoctorInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedCreateNestedOneWithoutDoctorInput
    subordinates?: StaffEmploymentInfoUncheckedCreateNestedManyWithoutReportingToInput
  }

  export type DoctorCreateOrConnectWithoutSessionsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutSessionsInput, DoctorUncheckedCreateWithoutSessionsInput>
  }

  export type AdminUpsertWithoutSessionsInput = {
    update: XOR<AdminUpdateWithoutSessionsInput, AdminUncheckedUpdateWithoutSessionsInput>
    create: XOR<AdminCreateWithoutSessionsInput, AdminUncheckedCreateWithoutSessionsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutSessionsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutSessionsInput, AdminUncheckedUpdateWithoutSessionsInput>
  }

  export type AdminUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutAdminsNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedAdminNestedInput
  }

  export type DoctorUpsertWithoutSessionsInput = {
    update: XOR<DoctorUpdateWithoutSessionsInput, DoctorUncheckedUpdateWithoutSessionsInput>
    create: XOR<DoctorCreateWithoutSessionsInput, DoctorUncheckedCreateWithoutSessionsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutSessionsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutSessionsInput, DoctorUncheckedUpdateWithoutSessionsInput>
  }

  export type DoctorUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutDoctorsNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    calls?: CallUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    calls?: CallUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUncheckedUpdateManyWithoutReportingToNestedInput
  }

  export type AdminCreateManyClinicInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type DoctorCreateManyClinicInput = {
    id?: string
    email?: string | null
    passwordHash?: string | null
    firstName?: string | null
    lastName?: string | null
    otp?: string | null
    licenceNo?: string | null
    specialities?: DoctorCreatespecialitiesInput | string[]
    emailVerifiedAt?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type PatientCreateManyClinicInput = {
    id?: string
    firstNameCipher?: string | null
    lastNameCipher?: string | null
    phoneCipher?: string | null
    emailCipher?: string | null
    insuranceIdCipher?: string | null
    addressCipher?: string | null
    emergencyContactCipher?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodGroup?: string | null
    conditionName?: string | null
    diagnosedDate?: Date | string | null
    severity?: string | null
    status?: string | null
    retentionExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    firstNameBlind?: string | null
    lastNameBlind?: string | null
    insuranceIdBlind?: string | null
  }

  export type AppointmentCreateManyClinicInput = {
    id?: string
    patientId?: string | null
    doctorId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.AppointmentStatus | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type CallCreateManyClinicInput = {
    id?: string
    patientId?: string | null
    doctorId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    durationSeconds?: number | null
    status?: $Enums.CallStatus | null
    recordingUrlCipher?: string | null
    transcript?: string | null
    aiSummary?: string | null
    sentiment?: $Enums.Sentiment | null
    escalated?: boolean | null
    minutesUsed?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    aiModelId?: string | null
    aiDecision?: string | null
  }

  export type LabCreateManyClinicInput = {
    id?: string
    patientId?: string | null
    testDate?: Date | string | null
    pdfKeyCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type PrescriptionCreateManyClinicInput = {
    id?: string
    patientId?: string | null
    doctorId?: string | null
    prescriptionNo?: number | null
    status?: $Enums.PrescriptionStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type TaskCreateManyClinicInput = {
    id?: string
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assigneeDoctorId?: string | null
    assigneeAdminId?: string | null
    patientId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type InvoiceCreateManyClinicInput = {
    id?: string
    stripeInvoiceId?: string | null
    invoiceNo?: string | null
    amountDue?: number | null
    amountPaid?: number | null
    currency?: string | null
    status?: string | null
    invoicePdfUrl?: string | null
    createdAt?: Date | string | null
  }

  export type NotificationQueueCreateManyClinicInput = {
    id?: string
    type?: $Enums.NotificationType | null
    recipient?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.NotificationStatus | null
    sentAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type AuditLogCreateManyClinicInput = {
    id?: string
    table?: string | null
    rowId?: string | null
    action?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    adminId?: string | null
    doctorId?: string | null
    ip?: string | null
    userAgent?: string | null
    occurredAt?: Date | string | null
  }

  export type DataRequestCreateManyClinicInput = {
    id?: string
    patientId?: string | null
    type?: $Enums.DataRequestType | null
    status?: $Enums.DataRequestStatus | null
    requestReason?: string | null
    requestedAt?: Date | string | null
    completedAt?: Date | string | null
    downloadUrl?: string | null
    downloadExpiresAt?: Date | string | null
  }

  export type ConsentVersionCreateManyClinicInput = {
    id?: string
    type?: $Enums.ConsentType | null
    version?: string | null
    title?: string | null
    body?: string | null
    effectiveDate?: Date | string | null
    createdAt?: Date | string | null
  }

  export type AdminUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedAdminNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DoctorUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    calls?: CallUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    calls?: CallUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutDoctorNestedInput
    staffPersonalInfo?: StaffPersonalInfoUncheckedUpdateOneWithoutDoctorNestedInput
    staffEmploymentInfo?: StaffEmploymentInfoUncheckedUpdateOneWithoutDoctorNestedInput
    subordinates?: StaffEmploymentInfoUncheckedUpdateManyWithoutReportingToNestedInput
  }

  export type DoctorUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    licenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    specialities?: DoctorUpdatespecialitiesInput | string[]
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatientUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    calls?: CallUpdateManyWithoutPatientNestedInput
    labs?: LabUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    tasks?: TaskUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    calls?: CallUncheckedUpdateManyWithoutPatientNestedInput
    labs?: LabUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutPatientNestedInput
    dataRequests?: DataRequestUncheckedUpdateManyWithoutPatientNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutPatientNestedInput
    diagnoses?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    consents?: PatientConsentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emailCipher?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdCipher?: NullableStringFieldUpdateOperationsInput | string | null
    addressCipher?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactCipher?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    conditionName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    retentionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameBlind?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceIdBlind?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneWithoutAppointmentsNestedInput
    doctor?: DoctorUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CallUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus | null
    recordingUrlCipher?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    escalated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    minutesUsed?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    aiDecision?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneWithoutCallsNestedInput
    doctor?: DoctorUpdateOneWithoutCallsNestedInput
  }

  export type CallUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus | null
    recordingUrlCipher?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    escalated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    minutesUsed?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    aiDecision?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CallUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus | null
    recordingUrlCipher?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    escalated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    minutesUsed?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    aiDecision?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    testDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfKeyCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneWithoutLabsNestedInput
    results?: LabResultUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    testDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfKeyCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    results?: LabResultUncheckedUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    testDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfKeyCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PrescriptionUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneWithoutPrescriptionsNestedInput
    doctor?: DoctorUpdateOneWithoutPrescriptionsNestedInput
    medicines?: PrescriptionMedicineUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicines?: PrescriptionMedicineUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDoctor?: DoctorUpdateOneWithoutAssignedTasksNestedInput
    assignedAdmin?: AdminUpdateOneWithoutAssignedTasksNestedInput
    patient?: PatientUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    amountDue?: NullableIntFieldUpdateOperationsInput | number | null
    amountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    amountDue?: NullableIntFieldUpdateOperationsInput | number | null
    amountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    amountDue?: NullableIntFieldUpdateOperationsInput | number | null
    amountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationQueueUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableEnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationQueueUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableEnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationQueueUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableEnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneWithoutAuditLogsNestedInput
    doctor?: DoctorUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataRequestUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType | null
    status?: NullableEnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus | null
    requestReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneWithoutDataRequestsNestedInput
  }

  export type DataRequestUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType | null
    status?: NullableEnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus | null
    requestReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataRequestUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType | null
    status?: NullableEnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus | null
    requestReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConsentVersionUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientConsents?: PatientConsentUpdateManyWithoutConsentVersionNestedInput
  }

  export type ConsentVersionUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientConsents?: PatientConsentUncheckedUpdateManyWithoutConsentVersionNestedInput
  }

  export type ConsentVersionUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatientConsentCreateManyConsentVersionInput = {
    id?: string
    patientId?: string | null
    type?: $Enums.ConsentType | null
    given?: boolean | null
    givenAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PatientConsentUpdateWithoutConsentVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    given?: NullableBoolFieldUpdateOperationsInput | boolean | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneWithoutConsentsNestedInput
  }

  export type PatientConsentUncheckedUpdateWithoutConsentVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    given?: NullableBoolFieldUpdateOperationsInput | boolean | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatientConsentUncheckedUpdateManyWithoutConsentVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    given?: NullableBoolFieldUpdateOperationsInput | boolean | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LabResultCreateManyLabInput = {
    id?: string
    testName?: string | null
    result?: string | null
    unit?: string | null
    normalMin?: number | null
    normalMax?: number | null
    flag?: $Enums.Flag | null
  }

  export type LabResultUpdateWithoutLabInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    normalMin?: NullableFloatFieldUpdateOperationsInput | number | null
    normalMax?: NullableFloatFieldUpdateOperationsInput | number | null
    flag?: NullableEnumFlagFieldUpdateOperationsInput | $Enums.Flag | null
  }

  export type LabResultUncheckedUpdateWithoutLabInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    normalMin?: NullableFloatFieldUpdateOperationsInput | number | null
    normalMax?: NullableFloatFieldUpdateOperationsInput | number | null
    flag?: NullableEnumFlagFieldUpdateOperationsInput | $Enums.Flag | null
  }

  export type LabResultUncheckedUpdateManyWithoutLabInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    normalMin?: NullableFloatFieldUpdateOperationsInput | number | null
    normalMax?: NullableFloatFieldUpdateOperationsInput | number | null
    flag?: NullableEnumFlagFieldUpdateOperationsInput | $Enums.Flag | null
  }

  export type PrescriptionMedicineCreateManyPrescriptionInput = {
    id?: string
    medicine?: string | null
    strength?: string | null
    dose?: string | null
    frequency?: string | null
    route?: string | null
    duration?: string | null
    refill?: number | null
  }

  export type PrescriptionMedicineUpdateWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicine?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    refill?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PrescriptionMedicineUncheckedUpdateWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicine?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    refill?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PrescriptionMedicineUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicine?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    refill?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AppointmentCreateManyPatientInput = {
    id?: string
    clinicId?: string | null
    doctorId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.AppointmentStatus | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type CallCreateManyPatientInput = {
    id?: string
    clinicId?: string | null
    doctorId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    durationSeconds?: number | null
    status?: $Enums.CallStatus | null
    recordingUrlCipher?: string | null
    transcript?: string | null
    aiSummary?: string | null
    sentiment?: $Enums.Sentiment | null
    escalated?: boolean | null
    minutesUsed?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    aiModelId?: string | null
    aiDecision?: string | null
  }

  export type LabCreateManyPatientInput = {
    id?: string
    clinicId?: string | null
    testDate?: Date | string | null
    pdfKeyCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type PrescriptionCreateManyPatientInput = {
    id?: string
    clinicId?: string | null
    doctorId?: string | null
    prescriptionNo?: number | null
    status?: $Enums.PrescriptionStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type TaskCreateManyPatientInput = {
    id?: string
    clinicId?: string | null
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assigneeDoctorId?: string | null
    assigneeAdminId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type DataRequestCreateManyPatientInput = {
    id?: string
    clinicId?: string | null
    type?: $Enums.DataRequestType | null
    status?: $Enums.DataRequestStatus | null
    requestReason?: string | null
    requestedAt?: Date | string | null
    completedAt?: Date | string | null
    downloadUrl?: string | null
    downloadExpiresAt?: Date | string | null
  }

  export type EmergencyContactCreateManyPatientInput = {
    id?: string
    nameCipher?: string | null
    relationship?: string | null
    phoneCipher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DiagnosisCreateManyPatientInput = {
    id?: string
    doctorId?: string | null
    diagnosisCode?: string | null
    diagnosisName?: string | null
    description?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    resolvedDate?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PatientConsentCreateManyPatientInput = {
    id?: string
    consentVersionId?: string | null
    type?: $Enums.ConsentType | null
    given?: boolean | null
    givenAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AppointmentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutAppointmentsNestedInput
    doctor?: DoctorUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CallUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus | null
    recordingUrlCipher?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    escalated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    minutesUsed?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    aiDecision?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClinicUpdateOneWithoutCallsNestedInput
    doctor?: DoctorUpdateOneWithoutCallsNestedInput
  }

  export type CallUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus | null
    recordingUrlCipher?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    escalated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    minutesUsed?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    aiDecision?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CallUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus | null
    recordingUrlCipher?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    escalated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    minutesUsed?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    aiDecision?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    testDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfKeyCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutLabsNestedInput
    results?: LabResultUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    testDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfKeyCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    results?: LabResultUncheckedUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    testDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfKeyCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PrescriptionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutPrescriptionsNestedInput
    doctor?: DoctorUpdateOneWithoutPrescriptionsNestedInput
    medicines?: PrescriptionMedicineUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicines?: PrescriptionMedicineUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutTasksNestedInput
    assignedDoctor?: DoctorUpdateOneWithoutAssignedTasksNestedInput
    assignedAdmin?: AdminUpdateOneWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataRequestUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType | null
    status?: NullableEnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus | null
    requestReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutDataRequestsNestedInput
  }

  export type DataRequestUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType | null
    status?: NullableEnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus | null
    requestReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataRequestUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumDataRequestTypeFieldUpdateOperationsInput | $Enums.DataRequestType | null
    status?: NullableEnumDataRequestStatusFieldUpdateOperationsInput | $Enums.DataRequestStatus | null
    requestReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyContactUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyContactUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyContactUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameCipher?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCipher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiagnosisUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosisCode?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: DoctorUpdateOneWithoutDiagnosesNestedInput
  }

  export type DiagnosisUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisCode?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiagnosisUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisCode?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatientConsentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    given?: NullableBoolFieldUpdateOperationsInput | boolean | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consentVersion?: ConsentVersionUpdateOneWithoutPatientConsentsNestedInput
  }

  export type PatientConsentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    given?: NullableBoolFieldUpdateOperationsInput | boolean | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatientConsentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType | null
    given?: NullableBoolFieldUpdateOperationsInput | boolean | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateManyAdminInput = {
    id?: string
    doctorId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
  }

  export type AuditLogCreateManyAdminInput = {
    id?: string
    table?: string | null
    rowId?: string | null
    action?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: string | null
    clinicId?: string | null
    ip?: string | null
    userAgent?: string | null
    occurredAt?: Date | string | null
  }

  export type TaskCreateManyAssignedAdminInput = {
    id?: string
    clinicId?: string | null
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assigneeDoctorId?: string | null
    patientId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type SessionUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: DoctorUpdateOneWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutAuditLogsNestedInput
    doctor?: DoctorUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUpdateWithoutAssignedAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutTasksNestedInput
    assignedDoctor?: DoctorUpdateOneWithoutAssignedTasksNestedInput
    patient?: PatientUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssignedAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUncheckedUpdateManyWithoutAssignedAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateManyDoctorInput = {
    id?: string
    adminId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string | null
  }

  export type AppointmentCreateManyDoctorInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.AppointmentStatus | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type CallCreateManyDoctorInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    durationSeconds?: number | null
    status?: $Enums.CallStatus | null
    recordingUrlCipher?: string | null
    transcript?: string | null
    aiSummary?: string | null
    sentiment?: $Enums.Sentiment | null
    escalated?: boolean | null
    minutesUsed?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    aiModelId?: string | null
    aiDecision?: string | null
  }

  export type PrescriptionCreateManyDoctorInput = {
    id?: string
    clinicId?: string | null
    patientId?: string | null
    prescriptionNo?: number | null
    status?: $Enums.PrescriptionStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type DiagnosisCreateManyDoctorInput = {
    id?: string
    patientId?: string | null
    diagnosisCode?: string | null
    diagnosisName?: string | null
    description?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    resolvedDate?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TaskCreateManyAssignedDoctorInput = {
    id?: string
    clinicId?: string | null
    title?: string | null
    description?: string | null
    status?: $Enums.TaskStatus | null
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assigneeAdminId?: string | null
    patientId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type AuditLogCreateManyDoctorInput = {
    id?: string
    table?: string | null
    rowId?: string | null
    action?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    adminId?: string | null
    clinicId?: string | null
    ip?: string | null
    userAgent?: string | null
    occurredAt?: Date | string | null
  }

  export type StaffEmploymentInfoCreateManyReportingToInput = {
    id?: string
    doctorId?: string | null
    employeeId?: string | null
    department?: $Enums.Department | null
    position?: string | null
    joinDate?: Date | string | null
    employmentType?: $Enums.EmploymentType | null
    workSchedule?: string | null
    weeklyHours?: number | null
    salaryCipher?: string | null
    employmentStatus?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SessionUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppointmentUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutAppointmentsNestedInput
    patient?: PatientUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CallUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus | null
    recordingUrlCipher?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    escalated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    minutesUsed?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    aiDecision?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: ClinicUpdateOneWithoutCallsNestedInput
    patient?: PatientUpdateOneWithoutCallsNestedInput
  }

  export type CallUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus | null
    recordingUrlCipher?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    escalated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    minutesUsed?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    aiDecision?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CallUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus | null
    recordingUrlCipher?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    escalated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    minutesUsed?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    aiDecision?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutPrescriptionsNestedInput
    patient?: PatientUpdateOneWithoutPrescriptionsNestedInput
    medicines?: PrescriptionMedicineUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicines?: PrescriptionMedicineUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionNo?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiagnosisUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosisCode?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneWithoutDiagnosesNestedInput
  }

  export type DiagnosisUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisCode?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiagnosisUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisCode?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUpdateWithoutAssignedDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutTasksNestedInput
    assignedAdmin?: AdminUpdateOneWithoutAssignedTasksNestedInput
    patient?: PatientUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssignedDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUncheckedUpdateManyWithoutAssignedDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic?: ClinicUpdateOneWithoutAuditLogsNestedInput
    admin?: AdminUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StaffEmploymentInfoUpdateWithoutReportingToInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableEnumDepartmentFieldUpdateOperationsInput | $Enums.Department | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null
    workSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    salaryCipher?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: DoctorUpdateOneWithoutStaffEmploymentInfoNestedInput
  }

  export type StaffEmploymentInfoUncheckedUpdateWithoutReportingToInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableEnumDepartmentFieldUpdateOperationsInput | $Enums.Department | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null
    workSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    salaryCipher?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StaffEmploymentInfoUncheckedUpdateManyWithoutReportingToInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableEnumDepartmentFieldUpdateOperationsInput | $Enums.Department | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null
    workSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    salaryCipher?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
model Appointment {
  id          String  @id @default(uuid())
  patientId   String?
  insuranceId String?
  doctorId    String?

  firstName          String?
  lastName           String?
  email              String?
  phone              String?
  dob                DateTime?
  gender             Gender?
  bloodGroup         BloodGroup?
  scheduleSlotId     String?
  appointmentDate    DateTime? // Specific date for the appointment
  appointmentDetails String?
  address            String?
  status             AppointmentStatus? @default(SCHEDULED)
  type               AppointmentType?   @default(CHECKUP)

  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt
  deletedAt DateTime?

  // Relations
  doctor       Doctor?             @relation("DoctorAppointments", fields: [doctorId], references: [id])
  patient      Patient?            @relation("PatientAppointments", fields: [patientId], references: [id])
  scheduleSlot DoctorScheduleSlot? @relation("AppointmentScheduleSlot", fields: [scheduleSlotId], references: [id])

  prescriptions Prescription[]
  labs          Lab[]
  // AI Agent Relations
  callTranscription CallTranscription? @relation("AppointmentCallTranscription")

  @@map("appointments")
}

model DoctorWeeklySchedule {
  id       String  @id @default(uuid())
  doctorId String
  day      WeekDay
  isClosed Boolean @default(false)

  // One-to-many: multiple time slots allowed
  slots DoctorScheduleSlot[]

  doctor Doctor @relation(fields: [doctorId], references: [id])

  @@unique([doctorId, day]) // Only one schedule record per day per doctor
  @@map("doctor_weekly_schedules")
}

model DoctorScheduleSlot {
  id         String @id @default(uuid())
  scheduleId String

  startTime String // e.g., "09:00"
  endTime   String // e.g., "13:00"

  schedule     DoctorWeeklySchedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  appointments Appointment[]        @relation("AppointmentScheduleSlot")

  @@map("doctor_schedule_slots")
}

model Call {
  id                 String      @id @default(uuid())
  patientId          String?
  doctorId           String?
  startAt            DateTime?
  endAt              DateTime?
  durationSeconds    Int?
  status             CallStatus?
  recordingUrlCipher String?
  transcript         String?
  aiSummary          String?
  sentiment          Sentiment?
  escalated          Boolean?
  minutesUsed        Int?
  createdAt          DateTime?   @default(now())
  updatedAt          DateTime?   @updatedAt
  aiModelId          String?
  aiDecision         String?
  patient            Patient?    @relation(fields: [patientId], references: [id])
  doctor             Doctor?     @relation("DoctorCalls", fields: [doctorId], references: [id])

  @@map("calls")
}

model Diagnosis {
  id            String    @id @default(uuid())
  patientId     String?
  doctorId      String?
  diagnosisCode String?
  diagnosisName String?
  description   String?
  status        String?
  diagnosedDate DateTime?
  resolvedDate  DateTime?
  createdAt     DateTime? @default(now())
  updatedAt     DateTime? @updatedAt

  patient Patient? @relation(fields: [patientId], references: [id])
  doctor  Doctor?  @relation("DoctorDiagnoses", fields: [doctorId], references: [id])

  @@map("diagnoses")
}

model Lab {
  id              String    @id @default(uuid())
  patientId       String?
  doctorId        String?
  appointmentId   String?
  testDate        DateTime?
  additionalNotes String?

  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt
  deletedAt DateTime?

  doctor      Doctor?      @relation("DoctorLabs", fields: [doctorId], references: [id])
  appointment Appointment? @relation(fields: [appointmentId], references: [id])
  patient     Patient?     @relation(fields: [patientId], references: [id])
  results     LabResult[]

  @@map("labs")
}

model LabResult {
  id        String  @id @default(uuid())
  labId     String?
  testName  String?
  result    String?
  unit      String?
  normalMin Float?
  normalMax Float?
  flag      Flag?

  lab Lab? @relation(fields: [labId], references: [id])

  @@map("lab_results")
}

model Prescription {
  id            String  @id @default(uuid())
  patientId     String?
  doctorId      String?
  appointmentId String?

  prescriptionNo String?             @unique
  status         PrescriptionStatus? @default(ACTIVE)

  // General prescription instructions (optional)
  instructions String?

  // Additional notes (optional)
  additionalNotes String?

  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt
  deletedAt DateTime?

  patient Patient? @relation(fields: [patientId], references: [id])
  doctor  Doctor?  @relation("DoctorPrescriptions", fields: [doctorId], references: [id])

  appointment Appointment? @relation(fields: [appointmentId], references: [id])

  // One prescription can have multiple medicines
  items PrescriptionItem[]

  @@map("prescriptions")
}

model PrescriptionItem {
  id             String @id @default(uuid())
  prescriptionId String

  medicineName         String?
  medicineInstructions String?

  // Dosage per time of day (e.g., 0, 0.5, 1, 2 tablets/spoons)
  morningDosage   Float?
  afternoonDosage Float?
  nightDosage     Float?

  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt

  prescription Prescription @relation(fields: [prescriptionId], references: [id], onDelete: Cascade)

  @@map("prescription_items")
}

// AI Agent Models

model CallTranscription {
  id            String    @id @default(uuid())
  doctorId      String
  patientId     String?
  
  // Call metadata
  callSid       String?   @unique // ElevenLabs/Twilio call identifier
  phoneNumber   String?
  duration      Int?      // Duration in seconds
  
  // Audio & transcription
  audioUrl      String?   // Path to stored audio file
  transcription String?   @db.Text
  
  // AI analysis
  intent        CallIntent?
  sentiment     Sentiment?
  summary       String?   @db.Text
  
  // Appointment context (if booking was made)
  appointmentId String?   @unique
  
  // Fallback info
  fallbackNumber String?  // Physical assistant number if agent is busy
  wasTransferred Boolean? @default(false)
  
  // Timestamps
  callStartedAt DateTime?
  callEndedAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Relations
  doctor        Doctor      @relation("DoctorCallTranscriptions", fields: [doctorId], references: [id])
  patient       Patient?    @relation("PatientCallTranscriptions", fields: [patientId], references: [id])
  appointment   Appointment? @relation("AppointmentCallTranscription", fields: [appointmentId], references: [id])
  
  @@index([doctorId, createdAt])
  @@index([patientId, createdAt])
  @@map("call_transcriptions")
}

model DoctorKnowledgeBase {
  id          String    @id @default(uuid())
  doctorId    String
  
  // Knowledge content
  category    KnowledgeBaseCategory? @default(GENERAL)
  question    String    @db.Text
  answer      String    @db.Text
  keywords    String[]  // Array of keywords for better matching
  
  // Metadata
  isActive    Boolean   @default(true)
  priority    Int       @default(0) // Higher priority answers shown first
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  doctor      Doctor    @relation("DoctorKnowledgeBase", fields: [doctorId], references: [id])
  
  @@index([doctorId, category])
  @@index([doctorId, isActive])
  @@map("doctor_knowledge_base")
}

